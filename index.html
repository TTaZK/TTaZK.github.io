
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>ZK</title>
	<meta name="author" content="Z K">

	
	<meta name="description" content="31.数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 package test; //在数组中的两个数字， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="" rel="alternate" title="ZK" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">ZK</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.baidu.com/" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:ttazk.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
    
	</div>
	<form class="search" action="https://www.baidu.com/" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:ttazk.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/09/07/jianzhioffer3/">
		
			剑指Offer3</a>
	</h2>
	<div class="entry-content">
		<h3>31.数组中的逆序对</h3>

<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
    package test;
    //在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
    //输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
    public class InversePairs {
        //该种方法的时间复杂度为O(n<sup>2</sup>)，比较复杂
        public static int inversePairs(int [] array) {
            int length=array.length;
            int count=0;
            for(int i=0;i&lt;length;i++){
             int temp=array[i];
             for(int j=i;j&lt;length;j++){
                 if (array[i]>array[j]) {
                         count++;
                     }
             }
            }
            return count;
        }
        //下面的方法类似于归并排序，先将数组分开，分别统计子数组的逆序对，再合并统计子数组之间的逆序对
        //时间复杂度为O(nlogn)
        private int[] temp;//临时数组
        public int inversePairs1(int[] array){
             temp=new int[array.length];
             return mergeInverse(array, 0, array.length-1)%1000000007;
        }
        public int mergeInverse(int[] array,int low,int high){</p>

<pre><code>         if (low&gt;=high) {
             return 0;
         }
         int mid=(high+low)/2;
         int a=mergeInverse(array, low, mid)%1000000007;//对左半边进行统计
         int b=mergeInverse(array, mid+1, high)%1000000007;//对右半边进行统计
         int c=merge(array, low, mid, high)%1000000007;//归并统计
         return (a+b+c)%1000000007;
    }
    //原地归并,并统计两个子数组之间的逆序对数
    public int merge(int[] array,int low,int mid,int high){
         for(int i=low;i&lt;=high;i++){
             temp[i]=array[i];//将待排序的元素复制到临时数组中
         }
         int count=0;
         int m=low;int n=mid+1;//标记待归并的两个起始位置,这两个位置是在临时数组中的位置

         for(int i=low;i&lt;=high;i++){
             //将临时数组中的元素按顺序归并到原数组中
             //前两个判断一定要放在后两个判断之前
             if (m&gt;mid){
                 array[i]=temp[n];
                 n++;
             }
             else if(n&gt;high){
                 array[i]=temp[m];
                 m++;
             }
             else if(temp[m]&lt;=temp[n]) {
                 array[i]=temp[m];
                 m++;
             }
             else if(temp[m]&gt;temp[n]){
                 array[i]=temp[n];
                 n++;
                 count=(count+(mid-m+1))%1000000007;//当左半边子数组的其中一个值m大于右半边一个数组值n，则左半边m以后的值都大于n
             }

         }
         return count;
    }
    public static void main(String[] args) {
         System.out.println(inversePairs(new int[]{1,2,3,4,5,6,7,0}));
    }
}
</code></pre>

<h3>32.两个链表的第一个公共节点</h3>

<p>输入两个链表，找出它们的第一个公共结点。
    package test;</p>

<pre><code>import java.util.HashMap;
import java.util.Map;

//输入两个链表，找出它们的第一个公共结点。
public class FindFirstCommonNode {
    class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }
    //直接先遍历一个链表，记录其中的元素，再遍历第二条链表，找到相同的元素
    public ListNode findFirstCommonNode(ListNode pHead1, ListNode pHead2) {
         Map&lt;ListNode, Integer&gt; map=new HashMap&lt;&gt;();
         int i=0;
         while(pHead1!=null){
             map.put(pHead1,i);
             pHead1=pHead1.next;
             i++;
         }
         while(pHead2!=null){
             if (map.get(pHead2)!=null) {
                return pHead2;
            }
             pHead2=pHead2.next;
         }
         return null;
    }
    //另一种方法：找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走
    //（因为2个链表用公共的尾部）
    //类比于找出链表的倒数第k个节点（使用两个指针），时间复杂度为O(m+n)
    public int getLength(ListNode head){
        int count=0;
        while(head!=null){
            count++;
            head=head.next;
        }
        return count;
    }
    public ListNode findFirstCommonNode1(ListNode pHead1, ListNode pHead2){
        int length1=getLength(pHead1);
        int length2=getLength(pHead2);
        int sub=length1-length2;
        while(sub&gt;0) {
            pHead1=pHead1.next;
            sub--;
        }
        while(sub&lt;0){
            pHead2=pHead2.next;
            sub++;
        }
        while(pHead1!=null){
            if (pHead1.val==pHead2.val) {
                return pHead1;
            }
            pHead1=pHead1.next;
            pHead2=pHead2.next;
        }
        return null;
    }

}
</code></pre>

<h3>33.统计一个数字在排序数组中出现的次数。</h3>

<pre><code>package test;

import java.util.HashMap;
import java.util.Map;

//统计一个数字在排序数组中出现的次数。
public class GetNumberOfK {
    //使用map
    public int getNumberOfK(int [] array , int k) {
        int count=0;
         Map&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;();
         for (int i = 0; i &lt; array.length; i++) {
            if (map.get(array[i])==null) {
                map.put(array[i], 1);
            }
            else {
                map.put(array[i], map.get(array[i])+1);
            }
        }
         if (map.get(k)==null) {
            return 0;
        }
         else {
            count=map.get(k);
        }
         return count;
    }
    //不使用map
    public int getNumberOfK2(int [] array , int k){
        int count=0;
        for (int i = 0; i &lt; array.length; i++) {
            if (array[i]==k) {
                count++;
            }

        }
        return count;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>34.二叉树的深度</h3>

<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
    package test;
    //输入一棵二叉树，求该树的深度。
    //从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
    public class TreeDepth {
        class TreeNode {
            int val = 0;
            TreeNode left = null;
            TreeNode right = null;</p>

<pre><code>        public TreeNode(int val) {
            this.val = val;
        }
    }
     public int treeDepth(TreeNode root) {
          if (root==null) {
             return 0;
         }
          else {
             int depth1=treeDepth(root.left)+1;
             int depth2=treeDepth(root.right)+1;
             return Math.max(depth1, depth2);
         }
     }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>35.判断是否是平衡二叉树</h3>

<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。
    package test;</p>

<pre><code>import test.TreeDepth.TreeNode;

//输入一棵二叉树，判断该二叉树是否是平衡二叉树
public class IsBalancedTree {
    class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        public TreeNode(int val) {
            this.val = val;
        }
    }
    //还可以利用后续遍历的思想，
     public boolean isBalanced(TreeNode root) {
          if (root==null) {
             return true;
         }
          else {
             int left=getDepth(root.left);
             int right=getDepth(root.right);
             int abs=Math.abs(left-right);
             return abs&lt;=1?true:false;
         }
     }
     public int getDepth(TreeNode root){
          if (root==null) {
             return 0;
         }
          else {
             int depth1=getDepth(root.left)+1;
             int depth2=getDepth(root.right)+1;
             return (depth1&gt;depth2)?depth1:depth2;
         }
     }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>36.数组中只出现一次的数字</h3>

<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
    package test;</p>

<pre><code>import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
public class FindNumsAppearOnce {
    //num1,num2分别为长度为1的数组。传出参数
    //将num1[0],num2[0]设置为返回结果
     public void findNumsAppearOnce(int [] array,int num1[] , int num2[]) {
           Map&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;();
           for (int i = 0; i &lt; array.length; i++) {
               if (map.get(array[i])==null) {
                   map.put(array[i], 1);
            }
               else {
                map.put(array[i], map.get(array[i])+1);
            }
        }
           ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();
           for (int i = 0; i &lt; array.length; i++) {
            if (map.get(array[i])==1) {
                arrayList.add(array[i]);
            }
        }
          num1[0]=arrayList.get(0);
          num2[0]=arrayList.get(1);
     }
}
</code></pre>

<h3>37.和为S的正数序列</h3>

<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
    package test;</p>

<pre><code>import java.util.ArrayList;

//小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。
//但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。
//没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。
//现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
public class FindContinuousSequence {
    static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists=new ArrayList&lt;&gt;();
     public static ArrayList&lt;ArrayList&lt;Integer&gt; &gt; findContinuousSequence(int sum) {

          int low=1;int high=2;
          while(low&lt;(sum+1)/2){
          //System.out.println("low="+low);
          //System.out.println("high="+high);
          if (getSum(low, high)==sum) {
               //System.out.println(high);
                 ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();
                 for (int i = low; i &lt;=high; i++) {
                     arrayList.add(i);
                 }
                 System.out.println(arrayList.toString());
                 arrayLists.add(arrayList);
                 high++;//将序列添加之后
                 low++;
               }
          //如果和偏小，就需要更多的数字，所以高位右移
          else if (getSum(low, high)&lt;sum) {
               System.out.println("low="+low+"high="+high+"sum="+sum+"getSum="+getSum(low, high));
                 high++;
             }
          //如果和偏大，需要减小数字，所以低位右移
          else if (getSum(low, high)&gt;sum){
               low++;
          }
          }
          return arrayLists;
     }
     public static int getSum(int low,int high){
          int sum=0;
          for(int i=low;i&lt;=high;i++){
              sum=sum+i;
             // System.out.println("sum"+i+"="+sum);
          }
          return sum;
     }
     public static void main(String[] args) {
        //System.out.println(findContinuousSequence(3).toString());
         System.out.println("sum="+getSum(1, 2));
    }
}
</code></pre>

<h3>38.和为S的两个数字</h3>

<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
    package test;</p>

<pre><code>import java.util.ArrayList;

//输入一个递增排序的数组和一个数字S，在数组中查找两个数，
//使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
public class FindNumbersWithSum {
     public ArrayList&lt;Integer&gt; findNumbersWithSum(int [] array,int sum) {
            ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();
            int low=0;int high=array.length-1;
            while(low&lt;=high){
             if (array[low]+array[high]==sum) {
                     arrayList.add(array[low]);
                     arrayList.add(array[high]);
                     break;
                 }
             else if (array[low]+array[high]&lt;sum) {
                     low++;
                 }
             else if(array[low]+array[high]&gt;sum){
                     high--;
                 }
            }
            return arrayList;
     }
}
</code></pre>

<h3>39.左旋转字符串</h3>

<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！
    package test;
    //汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。
    //对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。
    //例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！
    public class LeftRotateString {
        public String leftRotateString(String str,int n) {
            int length=str.length();
            if (length&lt;n) {
                 return &ldquo;&rdquo;;
             }
            StringBuilder stringBuilder=new StringBuilder();
            for(int i=n;i&lt;length;i++){
             stringBuilder.append(str.charAt(i));
            }
            for(int i=0;i&lt;n;i++){
             stringBuilder.append(str.charAt(i));
            }
            return stringBuilder.toString();
        }</p>

<pre><code>    //另一种巧妙的方法，可以先将str复制在原来字符串的末尾，再截取
    public String leftRotateString2(String str, int n) {
         int len = str.length();
         if(len == 0) return "";
         n = n % len;
         str += str;
         return str.substring(n, len+n-1);
    }
}
</code></pre>

<h3>40.翻转单词序列</h3>

<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？
    public class ReverseSentence {
         public String reverseSentence(String str) {
                 String[] strings=str.split(&ldquo; &rdquo;);
                 StringBuilder stringBuilder2=new StringBuilder();</p>

<pre><code>             if(str.trim().equals(""))return str;
             for (int i = strings.length-1; i &gt;=0; i--) {
                 if (i&gt;0) {
                     stringBuilder2.append(strings[i]+" ");
                 }else {
                     stringBuilder2.append(strings[i]);
                 }
             }
             //System.out.println(stringBuilder2.toString());
             return stringBuilder2.toString();
        }
    public static void main(String[] args) {

    }
}
</code></pre>

		
		
	</div>


<div class="meta">
	<div class="date">




Sep 7th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/algorithm/'>algorithm</a>


</div>
	
	<div class="comments"><a href="/blog/2017/09/07/jianzhioffer3/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/08/29/hashmap/">
		
			HashMap及源码分析</a>
	</h2>
	<div class="entry-content">
		<h3>映射</h3>

<ul>
<li><p>映射用来存放键值对。如果提供了键，就可以查找到对应的值。</p>

<ul>
<li>Java类库为映射提供了两种通用的实现：<strong>TreeMap，HashMap</strong>。它们都实现了Map接口。</li>
<li>散列映射对键进行散列。树映射用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键，与键关联的值不能进行散列或比较。散列要比树快点。</li>
<li>每当往映射中添加对象时，必须同时提供一个键。想要检索一个对象也必须使用键。</li>
<li><p><strong>键必须是唯一的，不能对同一个键存放两个值</strong>。如果对同一个键两次调用put，第二个值就会取代第一个值。实际上，put 将返回用这个键参数存储的上一个值。</p>

<pre><code>  V getOrDefault(Object key,V defaultValue)
  获得与键关联的值，或者如果未在映射中找到这个键，则返回defaultValue.
  V put(K key,V value)
  将键值对插入，并返回键对应的旧值。如果这个键以前没有出现过，则返回null。
  键可以为null,但值不可以为null。
</code></pre></li>
</ul>
</li>
<li><p>映射视图是实现了Collection接口或者其子接口的对象。有三种视图：<strong><em>键集(Set<K> keySet)，值集合(Collection<V> values)，键值对集(Set&lt;Map.Entry&lt;K,V>> entrySet)</em></strong>。需要说明的是，keySet不是hashSet或TreeSet，而是实现了Set接口的另外某个类的对象。
      <table>
      <tr>
      <td>public interface Map&lt;K,V><br></td>
      <td>将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值</td>
      </tr>
      <tr>
      <td>Set(Map.Entry&lt;K,V>) entrySet()</td>
      <td>返回此映射中包含的映射关系的 Set 视图。该 set 受映射支持，所以对映射的更改可在此 set 中反映出来，反之亦然。如果对该 set 进行迭代的同时修改了映射（通过迭代器自己的 remove 操作，或者通过对迭代器返回的映射项执行 setValue 操作除外），则迭代结果是不确定的。<strong><em>set 支持元素移除，通过 Iterator.remove、Set.remove、removeAll、retainAll 和 clear 操作可从映射中移除相应的映射关系。它不支持 add 或 addAll 操作</em></strong>。</td>
      </tr>
      <tr>
      <td>Set<K> keySet()</td>
      <td>返回此映射中包含的键的 Set 视图。该 set 受映射支持，所以对映射的更改可在此 set 中反映出来，反之亦然。如果对该 set 进行迭代的同时修改了映射（通过迭代器自己的 remove 操作除外），则迭代结果是不确定的。<strong><em>set 支持元素移除，通过 Iterator.remove、Set.remove、removeAll、retainAll 和 clear 操作可从映射中移除相应的映射关系。它不支持 add 或 addAll 操作。</em></strong></td>
      </tr>
      <tr>
      <td>Collection<V> values()</td>
      <td>返回此映射中包含的值的 Collection 视图。该 collection 受映射支持，所以对映射的更改可在此 collection 中反映出来，反之亦然。如果对该 collection 进行迭代的同时修改了映射（通过迭代器自己的 remove 操作除外），则迭代结果是不确定的。<strong><em>collection 支持元素移除，通过 Iterator.remove、Collection.remove、removeAll、retainAll 和 clear 操作可从映射中移除相应的映射关系。它不支持 add 或 addAll 操作。</em></strong></td>
      </tr>
      </table></p>

<ul>
<li>如果在视图上调用迭代器的remove()方法，实际上会从映射中删除键值对。不过不能向视图中增加元素。</li>
</ul>
</li>
</ul>


<h3>HashMap</h3>

<h4>HashMap类</h4>

<table>
<tr>
<td>
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable
</td>
</tr>
</table>


<ul>
<li>基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</li>
<li>此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。<br/></li>
<li>HashMap 的实例有两个参数影响其性能：初始容量 和加载因子。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br/></li>
<li>通常，默认加载因子 (.75) 在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。<br/></li>
<li>如果很多映射关系要存储在 HashMap 实例中，则相对于按需执行自动的 rehash 操作以增大表的容量来说，使用足够大的初始容量创建它将使得映射关系能更有效地存储。<br/>

<ul>
<li>注意，此实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须 保持外部同步。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用 Collections.synchronizedMap 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，如下所示：<br>
Map m = Collections.synchronizedMap(new HashMap(&hellip;));</li>
</ul>
</li>
<li>由所有此类的“collection 视图方法”所返回的迭代器都是快速失败 的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器本身的 remove 方法，其他任何时间任何方式的修改，迭代器都将抛出 ConcurrentModificationException。因此，面对并发的修改，迭代器很快就会完全失败，而不冒在将来不确定的时间发生任意不确定行为的风险。<br/>

<ul>
<li>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。

<h4>HashMap源码</h4></li>
</ul>
</li>
<li><p>HashMap中的属性</p>

<pre><code>  private static final long serialVersionUID = 362498820763181265L;
  //默认的初始容量，16        
  static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
  //最大容量
  static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
  //装载因子
  static final float DEFAULT_LOAD_FACTOR = 0.75f;
  static final int TREEIFY_THRESHOLD = 8;
  static final int UNTREEIFY_THRESHOLD = 6;
  static final int MIN_TREEIFY_CAPACITY = 64;

  //存储Entry的table数组
  transient Node&lt;K,V&gt;[] table;
  transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;
  //map中保存的键值对的数量
  transient int size;
  //map结构被改变的次数
  transient int modCount;
  //需要调整大小的极限值（容量*装载因子）
  int threshold;
  //装载因子
  final float loadFactor;
</code></pre></li>
</ul>


		
		
	</div>


<div class="meta">
	<div class="date">




Aug 29th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/08/29/hashmap/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/08/23/2dp/">
		
			两个相似的DP例子</a>
	</h2>
	<div class="entry-content">
		<ul>
<li><p>如果一个01串任意两个相邻位置的字符都是不一样的,我们就叫这个01串为交错01串。例如: &ldquo;1&rdquo;,&ldquo;10101&rdquo;,&ldquo;0101010"都是交错01串。
小易现在有一个01串s,小易想找出一个最长的连续子串,并且这个子串是一个交错01串。小易需要你帮帮忙            求出最长的这样的子串的长度是多少。</p>

<ul>
<li>使用动态规划求解：<br>
  设f(n)为以第n个位置结尾（包含第n个元素）的最长连续交错01串的长度，则f(n-1)为以第n-1个位置结尾的长度：当                s[n]==s[n-1]时，即第n个位置与第n-1个位置的值相同，那么f(n)应该放弃前面的长度，即f(n)=1;否则f(n)=f(n-1)+1.</li>
</ul>
</li>
</ul>



		
		<a href="/blog/2017/08/23/2dp/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Aug 23rd, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/algorithm/'>algorithm</a>


</div>
	
	<div class="comments"><a href="/blog/2017/08/23/2dp/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/08/05/string/">
		
			字符串讲解</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>String类没有提供用于修改字符串的方法。<strong><em>String类对象为不可变字符串</em></strong>，如字符串string=&ldquo;HELLO"永远只包含HELLO这几个字母，而不能修改其中任何一个字符。当然可以修改字符串变量string的引用，让它引用另一个字符串。</li>
<li><p>不可变字符串有一个优点：<strong><em>编译器可以让字符串实现共享</em></strong>。实际上只有字符串常量（使用“ ”声明，存储在字符串常量池中）是共享的，subStrng,+等操作产生的结果不能共享。（</p>

<ul>
<li>具体见JVM笔记</li>
<li>（1）只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。</li>
<li>（2）对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。）</li>
</ul>
</li>
<li><p>比较字符串值是否相等时使用equals()方法，不能使用==，==比较的是字符串的地址是否相同。如果字符串在常量池中，可以使用==比较，因为指向的都是同一个字符串。</p></li>
<li><p><strong><em>直接使用 &ldquo; &rdquo; 声明的String对象会直接存储在常量池中</em></strong>，（可以实现共享）</p>

<ul>
<li>1.String str1=&ldquo;first&rdquo;;
 jvm在运行时先查找常量池中是否有该字符串，如果有则直接返回该字符串的引用给first(实现了字符串     的共享) ；否则先在常量池中创建该字符串并返回引用。
 <strong><em>此时只会在常量池中创建String对象，不会在堆中创建。</em></strong></li>
<li>2.String str2=new String(&ldquo;second&rdquo;);
 该代码生成了两个String对象。因为使用了<strong><em>“”会先在常量池中查找是否存在second对象</em></strong>，没有则创建
 否则不创建；在常量池创建完成后，由于<strong><em>使用了new，jvm会在堆中创建内容相同的String对象</em></strong>，并将引用返回给str2.</li>
<li>3.String str3=&ldquo;what&rdquo;; String str4=str3+&ldquo;a nice day&rdquo;;
 运行时，+ 相当于new，所以堆中会有“what a nice day”对象；常量池中会有"what" &ldquo;a nice day"两个对象，而不会有"what a nice day”对象。</li>
</ul>
</li>
</ul>



		
		<a href="/blog/2017/08/05/string/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Aug 5th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/08/05/string/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/08/05/enum/">
		
			枚举类型</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>所有的枚举类型都是Enum类的子类，枚举类型包括有限个命名的值。枚举类型的变量只能存储该类型中指定的枚举常量，或者null值。</li>
<li>枚举类型在定义时，可以添加指定的域，方法或者构造函数；当然构造函数为private，只是在声明枚举常量时调用，用于传递值。</li>
<li><p>枚举类型可以简单定义为：</p>

<pre><code>  enum Size{
           //枚举常量列表必须写在前面，否则编译出错
           Small,Mid,Larger,SuperLager;  
      }
</code></pre></li>
<li><p>也可以给枚举类型增加构造方法，然后每个枚举类型的值通过构造函数传入对应的参数</p>

<pre><code>  enum Size_1{ 
           //定义枚举常量，并利用构造函数传递值,
          Small("1"),Mid("2"),Larger("3"),SuperLarger("4");
           //定义私有变量
           private String size;
           //定义构造函数，类型为private，用于给枚举常量传递值
           private Size_1(String size){
               this.size=size;
           }
           //重写toString()方法，用于返回枚举常量的值
           @Override
           public String toString() {
               // TODO Auto-generated method stub
               return this.size;
           }

      }
</code></pre></li>
<li>完整代码及具体使用如下：</li>
</ul>



		
		<a href="/blog/2017/08/05/enum/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Aug 5th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/08/05/enum/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/08/02/jianzhioffer2/">
		
			剑指Offer2</a>
	</h2>
	<div class="entry-content">
		<h3>16.树的子结构</h3>

<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
    package test;
    //输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
    public class HasSubTree {
        class TreeNode {
            int val = 0;
            TreeNode left = null;
            TreeNode right = null;</p>

<pre><code>        public TreeNode(int val) {
            this.val = val;
        }
    }
    public static boolean hasSubtree(TreeNode root1,TreeNode root2){
         boolean result=false;
         if (root1.val==root2.val) {
             if (root1==null) {
                 return false;
             }
             if (root2==null) {
                 return true;
             }
             result=hasSubtree(root1.left, root2.left)&amp;&amp;hasSubtree(root1.right, root2.right);
         }
         if (!result) {
             result=hasSubtree(root1.left, root2);
         }
         if (!result) {
             result=hasSubtree(root1.right, root2);
         }
         return result;
    }

    public boolean doesTree1hasTree2(TreeNode root1,TreeNode root2){
         if (root1==null&amp;&amp;root2!=null) {
             return false;
         }
         if (root2==null) {
             return true;
         }
         if (root1.val!=root2.val) {
             return false;
         }
         return doesTree1hasTree2(root1.left, root2.left)&amp;&amp;doesTree1hasTree2(root1.right, root2.right);
    }
    public boolean hasSubTree2(TreeNode root1,TreeNode root2){
         boolean result=false;
         if (root1!=null&amp;&amp;root2!=null) {
             if (root1.val==root2.val) {
                 result=doesTree1hasTree2(root1, root2);
             }
             if (!result) {
                 result=hasSubTree2(root1.left, root2);
             }
             if (!result) {
                 result=hasSubTree2(root1.right, root2);
             }
         }
         return result;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>17.二叉树镜像</h3>

<p>操作给定的二叉树，将其变换为源二叉树的镜像。
    package test;
    //操作给定的二叉树，将其变换为源二叉树的镜像
    public class Mirror {
        class TreeNode {
            int val = 0;
            TreeNode left = null;
            TreeNode right = null;</p>

<pre><code>        public TreeNode(int val) {
            this.val = val;
        }
    }

    public void mirror(TreeNode root) {
         if (root!=null) {
        if (root.left!=null||root.right!=null) {
             TreeNode node1=root.left;
             TreeNode node2=root.right;

             root.left=node2;root.right=node1;

         }
        mirror(root.left);
        mirror(root.right);
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>18.栈的压入弹出序列</h3>

<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
    package test;</p>

<pre><code>import java.util.Stack;

//输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。
//假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，
//序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
//（注意：这两个序列的长度是相等的）
public class IsPopOrder {
    public static boolean isPopOrder(int [] pushA,int [] popA) {
          //boolean result=true;
          int length=pushA.length;
          Stack&lt;Integer&gt; stack=new Stack&lt;&gt;();
          int index=0;
          for (int i = 0; i &lt; length; i++) {
        stack.push(pushA[i]);
        //每次要判断栈顶元素与要出栈的元素是否相同，如果相同，出栈且出栈元素后移；
        //当所有元素都入栈，且与出栈元素比较之后，栈为空，则是弹出序列
            while(!stack.isEmpty()&amp;&amp;stack.peek()==popA[index]) {
                 index++;
                 stack.pop();
             }
          }
          if (stack.isEmpty()) {
             return true;
         }else {
             return false;
         }
    }
    public static void main(String[] args) {
         int[] a={1,2,3,4,5};
         int[] b={4,5,3,2,1};
         System.out.println(isPopOrder(a,b));
    }
}
</code></pre>

<h3>19.从上到下打印二叉树&mdash;广度遍历</h3>

<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。
    package test;</p>

<pre><code>import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Queue;

//从上往下打印出二叉树的每个节点，同层节点从左至右打印。
public class PrintFromToptoBottom {
    class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        public TreeNode(int val) {
            this.val = val;
        }
    }

    public ArrayList&lt;Integer&gt; printFromTopToBottom(TreeNode root) {
        ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();
        Queue&lt;TreeNode&gt; queue=new ArrayDeque&lt;&gt;();
        if (root!=null) {
            queue.offer(root);
            while (!queue.isEmpty()) {
                TreeNode temp=queue.poll();
                if (temp.left!=null) {
                    queue.offer(temp.left);
                }
                if (temp.right!=null) {
                    queue.offer(temp.right);
                }
                arrayList.add(temp.val);
            }
        }
        return arrayList;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>20.二叉搜索树后序遍历序列</h3>

<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
    package test;
    //输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
    //如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同
    public class VerifySquenceOfBST {
        public boolean verifySquenceOfBST(int [] sequence) {
            return verifySquenceOfBST(sequence,0,sequence.length-1);
        }
        public boolean verifySquenceOfBST(int [] sequence,int start,int last){
             if (sequence.length&lt;=0) {
                 return false;
             }
             //该情况是对应于，对于一个根节点来说，只有右子树，没有左子树
             //如果只有左子树，没有右子树，则下面找不到分界点
             if (last&lt;start) {
                 return true;
             }
             int temp=sequence[last];
             int index=start;//记录左右子树的分界点
             for (int i = start; i &lt; last; i++) {
                 if (sequence[i]>temp) {
                     //用该种方法找到的分界点，说明该分界点的左半边都小于根节点
                     //所以，只需要判断右子树是不是全部都大于根节点
                     index=i;
                     for(int j=i;j&lt;last;j++){
                         if (sequence[j]&lt;=temp) {
                              return false;
                         }
                     }
                     return true;
                 }
             }
             return verifySquenceOfBST(sequence, start, index-1)&amp;&amp;verifySquenceOfBST(sequence, index, last-1);
        }
        public static void main(String[] args) {
             // TODO Auto-generated method stub</p>

<pre><code>    }

}
</code></pre>

<h3>21.二叉树中和为某一值的路径&mdash;-深度遍历</h3>

<p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
    package test;</p>

<pre><code>import java.util.ArrayList;
//输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。
//路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径
public class FindPath {
    class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        public TreeNode(int val) {
            this.val = val;
        }
    }
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;();//用于存储各条路径
    ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();//只是临时存储各条路径
    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(TreeNode root,int target) {
        if (root==null) {
             return lists;
         }
        list.add(root.val);//经过每个节点就将该节点保存在路径中
        target=target-root.val;
        //当遍历到根节点，且满足目标值时，将list添加到lists中
        if (target==0&amp;&amp;root.left==null&amp;&amp;root.right==null) {
             lists.add(new ArrayList&lt;&gt;(list));//用临时存储路径的列表构造新的列表，防止干扰
         }
        findPath(root.left, target);
        findPath(root.right, target);
        list.remove(list.size()-1);//对遍历到根节点却不满足条件的路径进行回退，返回其根节点
        return lists;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>22.复杂链表的复制</h3>

<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
    package test;
    //输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，
    //另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。
    //（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
    public class Clone {
        class RandomListNode {
            int label;
            RandomListNode next = null;
            RandomListNode random = null;</p>

<pre><code>        RandomListNode(int label) {
            this.label = label;
        }
    }
    public RandomListNode clone(RandomListNode pHead)
    {
        return pHead;
    }
    //先对链表中的每个节点进行复制，位于原节点的后面
    public void cloneNode(RandomListNode pHead1){
         RandomListNode pHead=pHead1;
         while(pHead!=null){
             RandomListNode clone=new RandomListNode(pHead.label);
             RandomListNode temp=pHead.next;//保存下一个要复制的节点
             clone.next=temp;
             pHead.next=clone;

             pHead=temp;//迭代要复制的节点
         }
    }
    //为复制的节点指明对应的random节点
    public void connectRandomNode(RandomListNode pHead1){
         RandomListNode pHead=pHead1;
         while(pHead!=null){
             if (pHead.random!=null) {
                 RandomListNode clone=pHead.next;
                 RandomListNode random=pHead.random;
                 clone.random=random.next;

             }
             pHead=pHead.next.next;//更新

         }
    }
    //把链表拆分成两个链表
    public RandomListNode reconnect(RandomListNode pHead1){
         RandomListNode pHead=pHead1;
         RandomListNode cloneHead=pHead.next;
         RandomListNode head=cloneHead;
         //同时更新两个链表的节点
         while(pHead!=null){
             pHead.next=pHead.next.next;
             if (cloneHead.next!=null) {
                 RandomListNode temp=cloneHead.next;
                 cloneHead.next=temp.next;
             }
             pHead=pHead.next;
             cloneHead=cloneHead.next;
         }
         return head;
    }
}
</code></pre>

<h3>22.二叉搜索树与双向链表</h3>

<p> 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
    package test;</p>

<pre><code>import java.util.ArrayList;

public class Convert {
    class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        public TreeNode(int val) {
            this.val = val;
        }
    }
    ArrayList&lt;TreeNode&gt; arrayList=new ArrayList&lt;&gt;();
    public TreeNode convert(TreeNode pRootOfTree) {
         if (pRootOfTree==null) {
             return null;
         }
         ArrayList&lt;TreeNode&gt; al=inorder(pRootOfTree);
         int length=al.size();
         TreeNode hNode=al.get(0);
         TreeNode tNode=al.get(al.size()-1);
         TreeNode head=hNode;head.left=null;
         TreeNode tail=tNode;tNode.right=null;

         for (int i = 1; i &lt; length; i++) {
             TreeNode temp=al.get(i);
             head.right=temp;
             head=temp;
         }
         for (int i = length-2; i &gt;=0; i--) {
             TreeNode temp=al.get(i);
             tail.left=temp;
             tail=temp;
         }
         return hNode;
    }
    public ArrayList&lt;TreeNode&gt; inorder(TreeNode pRootOfTree){
         if (pRootOfTree!=null) {
             inorder(pRootOfTree.left);
             arrayList.add(pRootOfTree);
             inorder(pRootOfTree.right);
         }
         return arrayList;
    }
}
</code></pre>

<h3>23.字符串的全排列&mdash;回溯法</h3>

<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba
    package test;</p>

<pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
//输入一个字符串,按字典序打印出该字符串中字符的所有排列。
//例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
public class Permutation {

    ArrayList&lt;String&gt; arrayList=new ArrayList&lt;&gt;();
    public ArrayList&lt;String&gt; permutation(String str){
        /*ArrayList&lt;String&gt; arrayList2=permutation(str.toCharArray(), 0);
        //去除arrayList2中的重复元素，因为在排序的时候可能由于String中有相同的字符，所以在排序结果中产生重复的字符串
        //如aaa,排序之后只有一个aaa
        Set&lt;String&gt; set=new HashSet&lt;&gt;(arrayList2);
        ArrayList&lt;String&gt; arrayList3=new ArrayList&lt;&gt;(set);
        //Collections.sort(arrayList3);//对结果进行字典排序，因为有的题目可能要求
        return arrayList3;*/
         ArrayList&lt;String&gt; arrayList2=permutation(str.toCharArray(), 0);
         Collections.sort(arrayList2);
         return arrayList2;
    }
    public ArrayList&lt;String&gt; permutation(char[] chars,int index){
        int length=chars.length;
        //index代表将要交换的字符的位置,from 0 to length-1
        if (index==length-1) {
            arrayList.add(new String(chars));
        }
        else {
            for(int i=index;i&lt;length;i++){
                //当第index(index!=i)字符与第i个字符相同时，没必要交换
                if (i!=index&amp;&amp;chars[i]==chars[index]) {
                    continue;
                }
                //将字符串中第index位置的字符，分别与后面的第i个字符交换
                char temp=chars[index];
                chars[index]=chars[i];
                chars[i]=temp;

                //递归对新生成的字符串进行排序，交换的字符位置为index+1
                permutation(chars, index+1);

                //将刚才交换的字符再交换回来，使字符串恢复原样，便于与第i+1个字符交换
                char temp1=chars[index];
                chars[index]=chars[i];
                chars[i]=temp1;
            }
        }
        return arrayList;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>24.数组中出现次数超过一半的数字</h3>

<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
    package test;</p>

<pre><code>import java.util.Arrays;
import java.util.HashMap;

public class MoreThanHalfNum {
    public static int moreThanHalfNum(int[] array){
        Arrays.sort(array);
        int count=1;
        for (int i = 1; i &lt; array.length; i++) {
            int a=array[i];
            if (array[i]==array[i-1]) {
                count++;
            }else {
                count=1;
            }
            if (count&gt;array.length/2) {
                return a;
            }
        }
        return -1;
    }
    public static int moreThanHalfNum2(int[] array){
        Arrays.sort(array);
        int count=0;
        for (int i = 0; i &lt; array.length; i++) {
            if (array[i]==array[array.length/2]) {
                count++;
            }
        }
        if (count&gt;array.length/2) {
            return array[array.length/2];
        }
        return -1;
    }
    //使用HashMap
    public static int moreThanHalfNum3(int[] array){
        HashMap&lt;Integer, Integer&gt; hashMap=new HashMap&lt;&gt;();
        for (int i = 0; i &lt; array.length; i++) {
            Integer count=hashMap.get(array[i]);
            if (count==null) {
                hashMap.put(array[i], 1);
            }
            else {
                hashMap.put(array[i], count+1);
            }
            if (hashMap.get(array[i])&gt;array.length/2) {
                return array[i];
            }
        }
        return 0;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] array={1,2,3,4,3,3,3,0,0,0,0,0,3,3,3,3,33,3,3,3,3};
        System.out.println(moreThanHalfNum3(array));
        System.out.println(moreThanHalfNum(array));
    }

}
</code></pre>

<h3>25.最小的k个数</h3>

<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
    package test;</p>

<pre><code>import java.util.ArrayList;
import java.util.PriorityQueue;
//输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
public class GetLeastNumbers {

     public ArrayList&lt;Integer&gt; getLeastNumbers(int [] input, int k) {
         if(k&gt;input.length||k&lt;=0){return new ArrayList&lt;Integer&gt;();}
         PriorityQueue&lt;Integer&gt; priorityQueue=new PriorityQueue&lt;&gt;(k);
         for(int i=0;i&lt;k;i++){
             priorityQueue.add(input[i]);
         }
         for (int i = k; i &lt; input.length; i++) {
            if (input[i]&lt;max(priorityQueue)) {
                priorityQueue.remove(max(priorityQueue));
                priorityQueue.add(input[i]);
            }
        }
         ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();
         for(int i=0;i&lt;k;i++){
             arrayList.add(priorityQueue.poll());
         }
         return arrayList;
     }
     public int max(PriorityQueue&lt;Integer&gt; priorityQueue){
         Object[] array=priorityQueue.toArray();
         int max=0;
         for (int i = 0; i &lt; array.length; i++) {
            if ((Integer)array[i]&gt;max) {
                max=(Integer)array[i];
            }
        }
         return max;
     }
}
</code></pre>

<h3>26.连续子数组最大和</h3>

<p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)
    package test;</p>

<pre><code>import java.util.ArrayList;
import java.util.Scanner;

public class FindGreatestSumOfSubArray {
    //求连续子数组的最大和
    public static int findGreatestSumOfSubArray(int[] array){
        int n=array.length;
        if (n==0||array==null) {
            return 0;
        }
        int[] f=new int[n];//用于存储对应位置的最大子数组的和
        f[0]=array[0];
        for(int i=1;i&lt;n;i++){
            if (f[i-1]&lt;0) {
                f[i]=array[i];
            }
            if (f[i-1]&gt;=0) {
                f[i]=f[i-1]+array[i];
            }
        }
        //求出f[]中最大的值，即为最大子数组的和
        int max=f[0];
        for(int i=0;i&lt;n;i++){
            if (max&lt;f[i]) {
                max=f[i];
            }
        }
        return max;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        System.out.println(findGreatestSumOfSubArray(new int[]{1,-2,3,10,-4,7,2,-5}));
        Scanner scanner=new Scanner(System.in);
        ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();
        while(scanner.hasNext()){
            int num=scanner.nextInt();
            arrayList.add(num);
        }
        int[] array=new int[arrayList.size()];
        for (int i = 0; i &lt; arrayList.size(); i++) {
            array[i]=arrayList.get(i);
        }
        System.out.println(findGreatestSumOfSubArray(array));
    }

}
</code></pre>

<h3>27.整数中1出现的次数</h3>

<p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>

<pre><code>package test;
//求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
//为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。
//ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。
public class NumberOf1Between1AndN {
    public int numberOf1Between1AndN(int n) {
        int sum=0;
        for(int i=0;i&lt;=n;i++){
        sum=sum+sumOfn(i);
        }
        return sum;
    }
    //先求每个整数中1的个数
    public int sumOfn(int n){
         int sum=0;
         while(n&gt;0){
             //对n的每一位进行判断，统计1的个数
             if (n%10==1) {
                 sum++;
                 n=n/10;
             }
             else {
                 n=n/10;
             }
         }
         return sum;
    }
}
</code></pre>

<h3>28.把数组排成最小的数</h3>

<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
    //定义一种新的排序规则
    package test;</p>

<pre><code>//数组拼接的最小值
public class PrintMinNumber {
    public static boolean compare(int m,int n){
         String m1=String.valueOf(m);
         String n1=String.valueOf(n);
         String str1=m1+n1;
         String str2=n1+m1;
         if (Long.valueOf(str1)&lt;Long.valueOf(str2)) {
             return true;
         }
         return false;
    }
    public static void swap(int[] array,int m,int n){
         int temp=array[m];
         array[m]=array[n];
         array[n]=temp;
    }
    public static String printMinNumber(int[] numbers){
         //int[] temp=new int[numbers.length];
         for (int i = 0; i &lt; numbers.length; i++) {
             int min=i;
             for (int j = i+1; j &lt; numbers.length; j++) {
                 if (compare(numbers[j], numbers[min])) {
                     min=j;
                 }
             }
             swap(numbers, min, i);
             //temp[i]=min;
         }
         StringBuffer stringBuffer=new StringBuffer();
         for (int i = 0; i &lt; numbers.length; i++) {
             stringBuffer.append(numbers[i]);

         }
         return stringBuffer.toString();
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] numbers={3,32,321,1,4,1};
        System.out.println(printMinNumber(numbers));
    }

}
</code></pre>

<h3>29.丑数</h3>

<p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>

<pre><code>package test;
//把只包含素因子2、3和5的数称作丑数（Ugly Number）。
//例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数
public class GetUglyNumber {
    //判断一个整数n是否只能被2整除，则将n连续除以2，如果最后结果为1，则只能被2整除
    //同样，判断一个数是否只能被2,3,5整除，将其连续地除以2,3,5，如果结果为1，则只包含因子2,3,5
    public boolean isUgly(int n){
         while(n&gt;1){
             while(n%2==0){
                 n=n/2;
             }
             while(n%3==0){
                 n=n/3;
             }
             while(n%5==0){
                 n=n/5;
             }
         }
         return n==1?true:false;
    }
    public int getUglyNumber(int index){
         int count=0;
         int i=0;
         while(count&lt;index){
             i++;
             if(isUgly(i)){
                 count++;
                 /*if (count==index) {
                     return i;
                 }*/
             }
             //i++;
         }
         return i;
    }
    //上面的时间复杂度太大，下面使用DP来进行简化
    //每个丑数都是由其他丑数乘以2,3,5得到的，现在将丑数按照顺序保存在数组中，
    //在更新下个丑数时，由前面的丑数乘以2,3,5得到，所以关键是如何从前面的丑数中选取
    public int getUglyNumber1(int index){
         if (index&lt;=0) {
             return 0;
         }
         if (index==1) {
             return 1;
         }
         int[] dp=new int[index];//保存丑数的数组
         dp[0]=1;
         int t2=0,t3=0,t5=0;//t2,t3,t5用来记录当计算下一个丑数时，应该从前面选取的丑数的位置(可以乘2、乘3或乘5的最小丑数)
         for(int i=1;i&lt;index;i++){
             dp[i]=min(dp[t2]*2, min(dp[t3]*3, dp[t5]*5));//计算下一个丑数
             //更新t2,t3,t5的位置
             if (dp[i]==dp[t2]*2) {
                 t2++;
             }
             if (dp[i]==dp[t3]*3) {
                 t3++;
             }
             if (dp[i]==dp[t5]*5) {
                 t5++;
             }
         }
         return dp[index-1];
    }
    public int min(int a,int b){
         return a&lt;b?a:b;
    }
}
</code></pre>

<h3>30.第一个只出现一次的字符</h3>

<p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p>

<pre><code>import java.util.HashMap;
public class Solution {
    public int FirstNotRepeatingChar(String str) {
        HashMap&lt;Character, Integer&gt; hashMap=new HashMap&lt;&gt;();
        for (int i = 0; i &lt; str.length(); i++) {
            hashMap.put(str.charAt(i), null);
        }
        for (int i = 0; i &lt; str.length(); i++) {
            Integer count=hashMap.get(str.charAt(i));
            if (count==null) {
                count=1;
                hashMap.put(str.charAt(i), count);
            }
            else {
                count++;
                hashMap.put(str.charAt(i), count);
            }
        }
        int first = -1;
        for (int i = 0; i &lt; str.length(); i++) {
            int count=hashMap.get(str.charAt(i));
            if (count==1) {
                first=i;
                break;
            }
        }
        return first;
    }
}
</code></pre>

		
		
	</div>


<div class="meta">
	<div class="date">




Aug 2nd, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/algorithm/'>algorithm</a>


</div>
	
	<div class="comments"><a href="/blog/2017/08/02/jianzhioffer2/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/08/02/sortanddp/">
		
			常见排序及两个经典DP</a>
	</h2>
	<div class="entry-content">
		<h3>1.插入排序</h3>

<pre><code>package Sort;

public class InsertSort {
    //将后面的元素与前面的有序元素进行比较，找到合适的位置进行插入
    public static void insertSort(int[] array){
         for (int i = 0; i &lt; array.length-1; i++) {
             for (int j = i+1; j &gt;0 &amp;&amp; array[j]&lt;array[j-1]; j--) {
                 int temp=array[j];
                 array[j]=array[j-1];
                 array[j-1]=temp;
             }
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] array={2,4,1,667,32,5,90,66,12,9,31};
         insertSort(array);
         for(int a:array){
             System.out.print(a+" ");
         }
    }

}
</code></pre>


		
		<a href="/blog/2017/08/02/sortanddp/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Aug 2nd, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/algorithm/'>algorithm</a>


</div>
	
	<div class="comments"><a href="/blog/2017/08/02/sortanddp/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/08/02/jianzhioffer1/">
		
			剑指offer1</a>
	</h2>
	<div class="entry-content">
		<h3>1.二维数组中的查找</h3>

<p>   在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数,输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>

<pre><code>        * 在一个二维数组中查找一个整数，数组是从左向右，从上向下递增
        * 分析：
        * 对于无序的数组，我们可以一行一行地进行比较，时间复杂度为O(n*n)
        * 由于该数组有序，按照一般的比较思路，我们一般从左上角到又开始比较，如果当前数字比待查找值小，则向右或者
        * 向下继续查找，这样的话便不容易进行选择。因此，我们可以尝试从右上角向左进行排查/从左下角向右进行排查，这样就不会像刚才一样
        * 面临两种选择，从而使问题简化。
        * 从左下角向右进行排查：如果当前数字比待查找值大，则向上进行查找（同时摈弃最下面一行，因为最下面一行的数字都比左下角的大）
        * 如果当前数字比待查找值小，则向右进行查找（同时摈弃该列，因为该列往上的数字都比待查找值小）
        *
        public class Question3 {

            //从左下角向右进行排查
            public static boolean findInArray(int[][] array,int a){
                if (array==null) {
                    return false;
                }
                int row=array.length-1;
                int column=array[0].length-1;


                int i=row,j=0;
                while(i&gt;=0&amp;&amp;j&lt;=column){
                    if (array[i][j]&gt;a) {
                        System.out.print(array[i][j]+" ");
                        i--;//往上走
                    }
                    else if (array[i][j]&lt;a) {
                        System.out.print(array[i][j]+" ");
                        j++;//往右走
                    }else {
                        System.out.print(array[i][j]+" ");
                        return true;
                    }
                }

                return false;
            }
            public static void main(String[] args) {
                int[][] array={.{1,2,3,4},{2,3,4,5},{3,4,5,6,},{4,5,6,7}.};
                System.out.println(findInArray(array, 3));
                //System.out.println(findInArray(array, 9));
            }

        }
        --------------------------------------------------------------------------------------------
        public class Solution {
            public boolean Find(int target, int [][] array) {
                int i=0;
                int j=array[0].length-1;
                while(i&lt;=array.length-1&amp;&amp;j&gt;=0){
                    if (array[i][j]==target) {
                        return true;
                    }
                    else if(target&gt;array[i][j]){
                        i++;
                    }
                    else{
                        j--;
                    }
                }
                return false;
            }
        }
</code></pre>


		
		<a href="/blog/2017/08/02/jianzhioffer1/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Aug 2nd, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/algorithm/'>algorithm</a>


</div>
	
	<div class="comments"><a href="/blog/2017/08/02/jianzhioffer1/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/07/30/algorithm/">
		
			动态规划与贪心</a>
	</h2>
	<div class="entry-content">
		

		
		
	</div>


<div class="meta">
	<div class="date">




Jul 30th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/algorithm/'>algorithm</a>


</div>
	
	<div class="comments"><a href="/blog/2017/07/30/algorithm/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/06/04/proxy/">
		
			Java代理</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>代理（Proxy）:利用代理可以在运行时创建一个实现了一组给定接口的新类。</li>
<li>代理类可以在运行时创建全新的类，这样的代理类能够实现指定的接口，代理类具有的方法如下：

<ul>
<li>指定接口所需要的全部方法。</li>
<li>Object类中的全部方法，（所有的代理类都覆盖了Object类中的方法toString,equals,hashCode,其他方法如，clone,getClass没有重新定义）</li>
<li><p>然而，不能在运行时定义这些方法的代码，而是要提供一个调用处理器(invocation Handler)。调用处理器是实现了InvocationHandler接口的类对象，在这个接口中只有一个方法：</p>

<pre><code>  Object invoke(Object proxy,Method method,Object[] args)
</code></pre></li>
</ul>
</li>
<li>无论何时调用代理对象的任何方法，调用处理器的invoke（）方法都会被调用，并向其传递Method对象和原始的调用参数。调用处理器必须给出处理调用的方式。</li>
</ul>



		
		<a href="/blog/2017/06/04/proxy/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Jun 4th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/06/04/proxy/#disqus_thread">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
    
        <a href="/posts/2" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2017

    Z K

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'zkatt';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>