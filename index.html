
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="YOU ARE MY GOLDNESS !!! LOVE YOU FORERVER ">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://ttazk.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="ttazk.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/03/07/love/">LOVE</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-03-07T13:29:18+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>1:29 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>YOU ARE  MY  GOLDNESS  !!!</h1>

<h1>LOVE  YOU  FORERVER</h1>

<p><img src="zkatt.jpg" alt="" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/03/07/ttazk/">Ttazk</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-03-07T01:12:11+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>1:12 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><pre><code>* 泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。
* 在增加泛型之前，泛型程序是利用继承实现的。
</code></pre>

<p>public class ArrayList{
     private Object[] data;
     &hellip;
     public Object get(int i){}
     public void add(Object o){}
}
     这种方法有两个问题：
     1.当获取一个值时必须进行强制类型转换。
     2.没有错误检查，可以向数组列表中添加任何类的对象。</p>

<pre><code>* 泛型提供了一个更好的解决方法：类型参数，用来指示存储元素的类型。如：ArrayList&lt;String&gt; arl=new ArrayList&lt;&gt;();   (jdk1.7之后，构造函数中可以省略泛型类型)。
* 对此编译器可以进行检查，避免插入错误的类型，同时在获取对象时不需要进行强制类型转换。
* 一个泛型类(generic class)就是具有一个或多个类型变量的类。
</code></pre>

<p>public class Pair<T> {
    private T first;
    private T second;</p>

<pre><code>public Pair(){
     this.first=null;
     this.second=null;
}
public Pair(T first,T second){
     this.first=first;
     this.second=second;
}

public T getFirst(){
     return first;
}
public T getSecond(){
     return second;
}
public void setFirst(T first){
     this.first=first;
}
public void setSecond(T second){
     this.second=second;
}
</code></pre>

<p>}</p>

<pre><code>* 如上所示，Pair类引入了一个类型变量T,用&lt;&gt;括起来，并放在类名之后。泛型类可以有多个类型变量。例如可以定义Pair类，两个域分别使用不同的类型变量：public class Pair&lt;T,V&gt;{...}.
* 类中定义的泛型变量指定方法的返回类型，以及域和局部变量的类型。（一般来说，K,V分别表示关键字与值的类型，T表示任意类型）。
* 用具体的类型替换类型变量就可以实例化泛型类型，如Pair&lt;String&gt;。换句话来说，泛型类可以看做普通类的工厂。




* 泛型方法
* 可以在一个普通类中定义一个带有类型参数的简单方法。
</code></pre>

<p>public class Generic {
    public static <T> void print(T t){
         System.out.println(t);
    }
}</p>

<pre><code>* 注意：类型变量放在修饰符的后面，返回类型的前面。
* 泛型方法可以定义在普通类中，也可以定义在泛型类中。
* 当调用一个泛型方法时，可以在方法名前的&lt;&gt;中放入具体的类型，也可以省略&lt;&gt;类型参数。
</code></pre>

<p>Generic.print(&ldquo;no&rdquo;);
Generic.<String>print(&ldquo;nothing&rdquo;);</p>

<pre><code>* 类型变量的限定
* 有时，需要对类或泛型方法中的类型变量加以限定。
</code></pre>

<p>public static <T extends Comparable> void sys(T t){
         System.out.println(t);
    }</p>

<pre><code>* 可以对泛型变量T进行限定，将其限定为实现了Comparable接口的类。
* &lt;T extends BoundingType&gt; 表示：T应该是绑定类型的子类型。T和绑定类型可以是类，也可以是接口。
* 一个类型变量或通配符可以有多个限定，如：T extends Comaprable &amp; Serializable
* 在Java的继承中，可以根据需要有多个接口的父类型，但是限定中至多只能有一个类，且必须是限定列表中的第一个。




* 类型擦除
* 在虚拟机中，没有泛型类型对象----所有的对象都属于普通类。
* 无论何时定义一个泛型类型，都会自动提供一个相应的原始类型(raw type)。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型（没有限定类型就用Object）。
* 例如，Pair&lt;T&gt;的原始类型为：
</code></pre>

<p>public class Pair{
    private Object first;
    private Object second;</p>

<pre><code>public Pair(){
     this.first=null;
     this.second=null;
}
public Pair(Object first,Object second){
     this.first=first;
     this.second=second;
}

public Object getFirst(){
     return first;
}
public Object getSecond(){
     return second;
}
public void setFirst(Object first){
     this.first=first;
}
public void setSecond(Object second){
     this.second=second;
}
</code></pre>

<p>}</p>

<pre><code>* 在程序中可以包含不同类型的Pair，如Pair&lt;String&gt;,Pair&lt;LocalDate&gt;，但是类型擦除后就变成了原始的Pair类型了。
* 原始类型用第一个限定类型来替换参数变量，如果没有给定限定类型，就用Object替换。
* 为了提高效率，应该将标签接口(没有方法的接口)放在列表的末尾。




* 翻译泛型表达式
* 当程序调用泛型方法时，如果擦除返回类型，编译器则插入强制类型转换。
* 
    * Pair&lt;Employee&gt; p=new Pair&lt;&gt;();
    * Employee e=p.getFirst();//先对原始方法调用Pair.getFirst();再将返回的Object类型强制转换成Employee类型。

* 关于java泛型转换的事实：
* 
    * 虚拟机中没有泛型，只有普通的类与方法。
    * 所有的参数类型都用它们的限定类型进行替换。
    * 为了保持类型安全，必要时插入强制类型转换。
    * 桥方法被合成来保持多态。





* 约束与局限性(大多数限制都是由类型擦除引起的)
* 不能用基本类型实例化类型参数
* 
    * 因此没有Pair&lt;double&gt;，只有Pair&lt;Double&gt;。原因是类型擦除，擦除之后，Pair类含有Object域，而Object域不能存储基本类型。

* 运行时类型查询只适用于原始类型
* 
    * 虚拟机中的对象总有一个特定的非泛型类型，因此，所有的类型查询只产生原始类型。
    * 
</code></pre>

<p>Pair<String> pair=new Pair<String>();
if (pair instanceof Pair<String>) {    //error
       System.out.println(true);
    }</p>

<pre><code>    * 
</code></pre>

<p>if (pair instanceof Pair) {         //true
    System.out.println(true);
   }</p>

<pre><code>    * 同样，getClass()方法返回的是原始类型。
    * 
</code></pre>

<p>Pair<String> pair=new Pair<String>();
Pair<Double> pair2=new Pair<Double>();
if (pair.getClass()==pair2.getClass()) {
    System.out.println(true);
   }      //输出为true</p>

<pre><code>* 不能创建泛型数组
* 
    * 
</code></pre>

<p>Pair<String>[] pairs=new Pair<String>[10];  //error</p>

<pre><code>    * 只是不能创建这些数组，但是声明类型Pair&lt;String&gt;[] 的变量仍是合法的，只能不过不能初始化。
    * 原因也是类型擦除。

* 不能实例化类型变量
* 
    * 即不能使用new T(...),new T[...],或T.class这样的表达式中的类型变量。

* 不能创建类型变量数组
* 
    * 
</code></pre>

<p>private T[] ts=new T[2];   //error</p>

<pre><code>* 不能在静态域或静态方法中引用类型变量
* 
    * private static T t;   //error
    * public static T print(){}   //error





* 泛型类型的继承规则
* 考虑一个类与一个子类，如Object,String，那么Pair&lt;String&gt;是Pair&lt;Object&gt;的子类吗？不是
* 无论T和S有什么关系，通常Pair&lt;S&gt;,Pair&lt;T&gt;是没有任何关系的。
</code></pre>

<p>Pair<Object>[] pair3=new Pair<String>[10];  //error</p>

<pre><code>* 注意泛型与Java数组之间的区别：可以将子类数组的变量赋给父类数组变量。
</code></pre>

<p>Object[] objects=new String[10];</p>

<pre><code>* 永远可以将参数化类型转换为一个原始类型。
</code></pre>

<p>Pair pair3=new Pair<String>();</p>

<pre><code>* 泛型类可以扩展或者实现其他泛型类，这点而言与普通类没有区别
* 
    * ArrayList&lt;T&gt;类实现了List&lt;T&gt;接口。
    * 意味着ArrayList&lt;String&gt;可以转换为List&lt;String&gt;




* 通配符类型
* 通配符类型中，允许类型参数变化。如  Pair&lt;? extends Comparable&gt;
* 类型Pair&lt;String&gt;是Pair&lt;? extends Object&gt;的子类型。

                                                                     &lt;---Pair&lt;Object&gt;
</code></pre>

<p>Pair(原始类型)&lt;&mdash;Pair&lt;? extends Object><---
                                                                          <---Pair<String></p>

<pre><code>* 通配符的超类型限定
* 
    * 可以指定一个父类型：  ? super Manager

* 带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。(P332)
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2017/03/07/zkatt/">JVM</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2017-03-07T00:20:35+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2017</span></span> <span class='time'>12:20 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><pre><code>* Java运行时数据区分为：方法区，堆，虚拟机栈，本地方法栈，程序计数器。其中，方法区与堆为所有线程共享；虚拟机栈，本地方法栈与程序计数器为线程私有。



* 程序计数器：
* 
    * 所占内存空间比较小，可以看做当前线程所执行字节码的行号指数器。字节码解释器在工作时就是通过这个计数器的值来选取下一条需要执行的字节码指令。
    * 每个线程都有一个独立的程序计数器，各个线程的程序计数器互不影响，独立存储，为“线程私有”。
    * 如果线程正在执行的是Java方法，那么程序计数器的值就是虚拟机字节码指令的地址；如果执行的是Native方法，那么程序计数器的值为空。
    * 此内存区域是Java虚拟机运行规范中没有规定任何OutOfMemoryError情况的区域。





* Java虚拟机栈：
* 
    * 与程序计数器一样，也是线程私有，它的生命周期与线程一样。
    * Java虚拟机栈描述的是Java方法执行时的内存模型：每一个方法在执行时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
    * 局部变量表存放了在编译期可知的各种基本数据类型（int,short,long,double,float,boolean），对象引用类型（reference类型，可能指向对象起始地址的指针）和returnAddress类型（指向一条字节码指令的地址）。
    * 局部变量表的内存大小在编译期确定并完成分配，当进入一个方法时，这个方法需要在帧中分配的局部变量表的大小确定，并且在运行期不改变。
    * Java虚拟机栈的内存大小是可以动态扩展的，在这个区域可能会发生两种异常：OutOfMemoryError与StackOverflowError。





* 本地方法栈：
* 
    * 与虚拟机栈的作用类似，只不过虚拟机栈是为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈是为虚拟机使用到的Native方法服务。有的虚拟机（如HotSpot）直接把这两个合二为一。
    * 在这个区域可能会发生两种异常：OutOfMemoryError与StackOverflowError，与虚拟机栈相同。

* Java堆：
* 
    * Java堆是Java虚拟机所管理的内存最大的一块区域。
    * Java堆是所有线程共享的一块区域，随着虚拟机的启动而创建。此区域的唯一目的就是存放对象的实例，几乎所有的对象实例都在这里分配内存。Java虚拟机规范描述的是：所有的对象实例及数组都在堆上分配。
    * Java堆是垃圾收集器管理的主要区域。
    * Java堆可以处在物理上连续的内存空间中，也可以处于不连续的内存空间中（只要是逻辑上连续即可）。在实现时，可以是固定大小的，也可以是可扩展的。
    * 当堆中没有内存完成实例分配时，且堆也无法扩展时，可能会发生的异常为：OutOfMemoryError。





* 方法区：
* 
    * 方法区与Java堆一样也是线程共享的，它用于存储已被虚拟机加载的类信息，常量，静态变量，及时编译器编译后的代码等数据。
    * 除了与Java堆一样可以不需要连续的内存，可以选择固定的大小或可扩展的外，还可以选择不实现垃圾收集。相对而言，垃圾收集在这里的行为很少（这一区域的回收主要是对常量池的回收和对类型的卸载）。
    * 当内存无法满足要求时，会抛出：OutOfMemoryError。





* 运行时常量池：
* 
    * 运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还包括一项信息是常量池。
    * 常量池用于存放编译期生成的各种字面量和符号引用。
    * 字面量和符号引用量：字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：
    * 
        * 类和接口的全限定名
        * 字段名称和描述符
        * 方法名称和描述符

    * 运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。
    * java中基本类型的包装类的大部分都实现了常量池技术，即（Byte,Short,Integer,Long,Character,Boolean）。类比于Integer类型在自动装箱时，如果值[-128,127]之间，那么就存储在常量池中。两种浮点数类型的包装类Float,Double并没有实现常量池技术。
    * 
        * 只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。
        * 对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。



    String string1="te";
     String string2="st";
     String string3="test";
     String string4=string1+string2;
     String string5="te"+"st";
     String string6=new StringBuilder("test").toString();
 　　String string7=new String("test").intern();


    System.out.println(string3==string4);//false
    System.out.println(string3==string5);//true
    System.out.println(string4==string5);//false
    System.out.println(string3==string6);//false
</code></pre>

<p>　　System.out.println(string3==string7);//true</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/03/07/love/">LOVE</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/03/07/ttazk/">Ttazk</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/03/07/zkatt/">JVM</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
