
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>ZK</title>
	<meta name="author" content="Z K">

	
	<meta name="description" content="/* * 在一个二维数组中查找一个整数，数组是从左向右，从上向下递增 * 分析： * 对于无序的数组，我们可以一行一行地进行比较，时间复杂度为O(n*n) * 由于该数组有序，按照一般的比较思路，我们一般从左上角到又开始比较，如果当前数字比待查找值小，则向右或者 * 向下继续查找， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="" rel="alternate" title="ZK" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">ZK</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.baidu.com/" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:ttazk.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
    
	</div>
	<form class="search" action="https://www.baidu.com/" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:ttazk.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/08/02/question3/">
		
			剑指offer_Question3</a>
	</h2>
	<div class="entry-content">
		<pre><code>/*
 * 在一个二维数组中查找一个整数，数组是从左向右，从上向下递增
 * 分析：
 * 对于无序的数组，我们可以一行一行地进行比较，时间复杂度为O(n*n)
 * 由于该数组有序，按照一般的比较思路，我们一般从左上角到又开始比较，如果当前数字比待查找值小，则向右或者
 * 向下继续查找，这样的话便不容易进行选择。因此，我们可以尝试从右上角向左进行排查/从左下角向右进行排查，这样就不会像刚才一样
 * 面临两种选择，从而使问题简化。
 * 从左下角向右进行排查：如果当前数字比待查找值大，则向上进行查找（同时摈弃最下面一行，因为最下面一行的数字都比左下角的大）
 * 如果当前数字比待查找值小，则向右进行查找（同时摈弃该列，因为该列往上的数字都比待查找值小）
 */
public class Question3 {

    //从左下角向右进行排查
    public static boolean findInArray(int[][] array,int a){
        if (array==null) {
            return false;
        }
        int row=array.length-1;
        int column=array[0].length-1;
</code></pre>


		
		<a href="/blog/2017/08/02/question3/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Aug 2nd, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/algorithm/'>algorithm</a>


</div>
	
	<div class="comments"><a href="/blog/2017/08/02/question3/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/08/02/question4/">
		
			剑指offer_Question4</a>
	</h2>
	<div class="entry-content">
		<pre><code>package test;

/*
 * 替换空格
 * 实现一个函数，将字符串中的空格替换成%20
 */
public class Question4 {

    public static String replaceBlank(String string){
        /*
         * 可以直接创建一个新的字符串/StringBuffer,然后对输入的字符串进行遍历，如果遇到字符，
         * 则加在新字符串的末尾；如果遇到空格，就在新字符串的末尾加入%20,返回新的字符串即可。
         */
        StringBuffer stringBuffer=new StringBuffer();
        for(int i=0;i&lt;string.length();i++){
            if (string.charAt(i)==' ') {
                stringBuffer.append("%20");
            }else{
                stringBuffer.append(string.charAt(i));
            }
        }
        return stringBuffer.toString();
    }

    public static String replaceBlank2(String string){
        /*
         * 直接使用String.repalce(char old,char new)
         * 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。
         * 该方法只能替换一个字符
         * 
         * replace(CharSequence target, CharSequence replacement) 
         *使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。
         *该方法可以替换字符串
         * 
         *replaceAll(String regex, String replacement) 
         *使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。。
         */
        return string.replace(" ","%20");
    }
</code></pre>


		
		<a href="/blog/2017/08/02/question4/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Aug 2nd, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/algorithm/'>algorithm</a>


</div>
	
	<div class="comments"><a href="/blog/2017/08/02/question4/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/07/30/algorithm/">
		
			动态规划与贪心</a>
	</h2>
	<div class="entry-content">
		

		
		
	</div>


<div class="meta">
	<div class="date">




Jul 30th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/algorithm/'>algorithm</a>


</div>
	
	<div class="comments"><a href="/blog/2017/07/30/algorithm/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/06/04/proxy/">
		
			Java代理</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>代理（Proxy）:利用代理可以在运行时创建一个实现了一组给定接口的新类。</li>
<li>代理类可以在运行时创建全新的类，这样的代理类能够实现指定的接口，代理类具有的方法如下：

<ul>
<li>指定接口所需要的全部方法。</li>
<li>Object类中的全部方法，（所有的代理类都覆盖了Object类中的方法toString,equals,hashCode,其他方法如，clone,getClass没有重新定义）</li>
<li><p>然而，不能在运行时定义这些方法的代码，而是要提供一个调用处理器(invocation Handler)。调用处理器是实现了InvocationHandler接口的类对象，在这个接口中只有一个方法：</p>

<pre><code>  Object invoke(Object proxy,Method method,Object[] args)
</code></pre></li>
</ul>
</li>
<li>无论何时调用代理对象的任何方法，调用处理器的invoke（）方法都会被调用，并向其传递Method对象和原始的调用参数。调用处理器必须给出处理调用的方式。</li>
</ul>



		
		<a href="/blog/2017/06/04/proxy/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Jun 4th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/06/04/proxy/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/04/22/btree/">
		
			B树，B+树，B*树简介</a>
	</h2>
	<div class="entry-content">
		<ul>
<li><h3>B树又叫平衡多路查找树（Balance-Tree)，一棵m阶B树满足以下条件：</h3>

<ul>
<li>每个节点至多有m棵子树</li>
<li>除根节点外，其他节点至少有|m/2|棵子树</li>
<li>根节点至少有两棵子树（除非B树只有一个节点）</li>
<li>所有的叶子节点位于同一层上。B树的叶子节点可以看做一种外部节点，不包含任何信息。</li>
<li>有j个孩子的非叶子节点恰好有（j-1）个关键字，关键字按照递增的次序排列。</li>
<li>对于一棵包含N个关键字，高度为h，最小度数t>=2的B树，有h&lt;=logt（(N+1)/2）
</br></br></li>
</ul>
</li>
</ul>



		
		<a href="/blog/2017/04/22/btree/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Apr 22nd, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/04/22/btree/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/04/22/index/">
		
			MySql索引</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>根据存储介质的不同，数据库分为<strong>基于磁盘的数据库</strong>（最为常见的关系型数据库，如MySQL，SQLserver，Oracle等），<strong>基于内存的数据库</strong>。而混合型数据库将这两种类型的数据库进行整合。</li>
<li>基于内存的数据库系统是最快的，因为数据库不需要对磁盘进行操作。因此，基于磁盘的数据库系统一般都有缓冲池，即一块内存区域，其作用是将从磁盘上读取的指定大小的数据&mdash;称为页或块，放入缓冲池。当再次读取时，首先判断该页是否在缓冲池中，如果在则直接读取缓冲池中的页，如果不在则读取磁盘上的页。 对于写操作，数据库将页读入缓冲池，然后在缓冲池中对页进行修改，最后将修改完成的页异步（一般为异步）写入磁盘上。
		
		<a href="/blog/2017/04/22/index/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Apr 22nd, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/mysql/'>mysql</a>


</div>
	
	<div class="comments"><a href="/blog/2017/04/22/index/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/04/19/object/">
		
			Object详解</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>Object类是所有类的父类，每个类都是由Object类扩展而来。如果没有明确指出父类，则默认为Object类为该类的父类。</li>
<li>可以使用Object类型的变量引用任何类型的对象。</li>
<li><p>在Java中，只有基本数据类型（数字，字符，布尔）不是对象。所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。</p>

<pre><code>  int[] i=new int[5];
  Object obj=i;
</code></pre>

<h3>equals()方法</h3></li>
<li>在Object类中，该方法用于判断两个对象是否具有相同的引用。</li>
<li><p>然而，经常需要检测两个对象的状态的相等性，所以一般需要覆写equals()方法。</p>

<pre><code>  public class Test{
             public boolean equals(Object otherObject){
                  }
         }
</code></pre></li>
<li>在子类中定义equals方法时，首先调用父类的equals方法。如果检测失败，则对象不可能相等。如果父类中的域都相等，就需要比较子类中的实例域。</li>
</ul>



		
		<a href="/blog/2017/04/19/object/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Apr 19th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/04/19/object/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/04/12/jmm/">
		
			Java内存模型</a>
	</h2>
	<div class="entry-content">
		<ul>
<li><p><strong>Java 内存模型中的可见性、原子性和有序性。</strong></p></li>
<li><p><strong>可见性：</strong></p>

<ul>
<li>可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</li>
<li>可见性，是<strong>指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到</strong>。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</li>
<li><strong>在 Java 中 volatile、synchronized 和 final 实现可见性。</strong><br/><br/></li>
</ul>
</li>
</ul>



		
		<a href="/blog/2017/04/12/jmm/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Apr 12th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/jvm/'>jvm</a>


</div>
	
	<div class="comments"><a href="/blog/2017/04/12/jmm/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/04/11/threadpool/">
		
			线程池详解</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>线程池是管理一组同构线程的资源池。线程池与工作队列密切相关，其中在工作队列中保存了所有等待执行的任务。<strong>工作者线程的任务是：从工作队列中取出一个任务，执行任务，然后返回线程等待下一个任务。线程池通过重用线程，而不是新建线程，减小线程创建与销毁的开销</strong>。</li>
<li>Excutor是顶级线程池接口</li>
<li>ExecutorService是真正的线程池接口。</li>
<li>Executors类提供了一些静态工厂用于生成一些常用的线程池，当将一个任务添加到线程池时，线程池会为每个任务创建一个线程，该线程会在某个时刻执行。</li>
</ul>



		
		<a href="/blog/2017/04/11/threadpool/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Apr 11th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/04/11/threadpool/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/03/22/generic/">
		
			泛型程序设计</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。</li>
<li><p>在增加泛型之前，泛型程序是利用继承实现的。</p>

<pre><code>  public class ArrayList{
  private Object[] data;
   ...
  public Object get(int i){}
  public void add(Object o){}
  }
</code></pre></li>
<li>这种方法有两个问题：</li>
<li>1.当获取一个值时必须进行强制类型转换。</li>
<li><p>2.没有错误检查，可以向数组列表中添加任何类的对象。</br></br></p></li>
<li><p>泛型提供了一个更好的解决方法：类型参数，用来指示存储元素的类型。如：ArrayList<String> arl=new ArrayList&lt;>();   (jdk1.7之后，构造函数中可以省略泛型类型)。</p>

<ul>
<li>对此编译器可以进行检查，避免插入错误的类型，同时在获取对象时不需要进行强制类型转换。</li>
<li><p>一个泛型类(generic class)就是具有一个或多个类型变量的类。
      public class Pair<T> {
      private T first;
      private T second;</p>

<pre><code>  public Pair(){
       this.first=null;
       this.second=null;
  }
  public Pair(T first,T second){
       this.first=first;
       this.second=second;
  }

  public T getFirst(){
       return first;
  }
  public T getSecond(){
       return second;
  }
  public void setFirst(T first){
       this.first=first;
  }
  public void setSecond(T second){
       this.second=second;
      }
  }
</code></pre></li>
<li>如上所示，Pair类引入了一个类型变量T,用&lt;>括起来，并放在类名之后。泛型类可以有多个类型变量。例如可以定义Pair类，两个域分别使用不同的类型变量：public class Pair&lt;T,V>{&hellip;}.</li>
<li>类中定义的泛型变量指定方法的返回类型，以及域和局部变量的类型。（一般来说，K,V分别表示关键字与值的类型，T表示任意类型）。</li>
<li>用具体的类型替换类型变量就可以实例化泛型类型，如Pair<String>。换句话来说，泛型类可以看做普通类的工厂。
</br></br></li>
</ul>
</li>
</ul>



		
		<a href="/blog/2017/03/22/generic/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Mar 22nd, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/03/22/generic/#disqus_thread">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
    
        <a href="/posts/2" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2017

    Z K

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'zkatt';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>