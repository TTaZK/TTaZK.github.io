
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->

<head>


<meta charset="utf-8">
<meta http-equiv="cleartype" content="on">

<title>Blog by ZK - Coding BY ZK</title>
<meta name="author" content="Z K">




<meta name="description" content="April 22, 2017 Z K &nbsp; &bull; &nbsp; Comment B树，B+树，B*树简介 B树又叫平衡多路查找树（Balance-Tree)，一棵m阶B树满足以下条件： 每个节点至多有m棵子树
除根节点外，其他节点至少有|m/2|棵子树
根节点至少有两棵子树（ &hellip;">

<meta name="keywords" content=" ">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Twitter Cards -->


<!-- Open Graph -->
<meta property="og:local" content="en_US">
<meta property="og:type" content="article">
<meta property="og:url" content="http://ttazk.github.io">
<meta property="og:title" content="Blog by ZK">
<meta property="og:description" content="April 22, 2017 Z K &nbsp; &bull; &nbsp; Comment B树，B+树，B*树简介 B树又叫平衡多路查找树（Balance-Tree)，一棵m阶B树满足以下条件： 每个节点至多有m棵子树
除根节点外，其他节点至少有|m/2|棵子树
根节点至少有两棵子树（ &hellip;">

  <meta property="og:image" content="/images/threaded-blue-on-black-cropped.jpg">

<meta property="og:site_name" content="Coding BY ZK">

<link rel="canonical" href="http://ttazk.github.io">
<link href="/favicon.png" rel="icon">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
<link href="/atom.xml" rel="alternate" title="Coding BY ZK" type="application/atom+xml">

<script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
<script>Modernizr || document.write('<script src="/javascripts/vendor/modernizr-2.6.2.custom.min.js"><\/script>') </script>



<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">


</head>

<body id="post-index" class="feature">
  <!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
  <nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="" alt="Z K photo" class="author-photo">
					<h4>Z K</h4>
					<p></p>
				</li>
				
				
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="/posts/">All Posts</a></li>
				<li><a href="/categories/">All Categories</a></li>
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->


  <div class="entry-header">
    
    
      <div class="entry-image">
        <img src="/images/threaded-blue-on-black-cropped.jpg" alt="Blog by ZK">
      </div><!-- /.entry-image -->
    
    <div class="header-title">
      <div class="header-title-wrap">
        <h1>Coding BY ZK</h1>
        <h2>A Java Coder</h2>
      </div><!-- /.header-title-wrap -->
    </div><!-- /.header-title -->
  </div><!-- /.entry-header -->

  <div id="main" role="main">
    

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2017-04-22T11:30:13+08:00">
        <a href="/blog/2017/04/22/btree/">April 22, 2017</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About Z K">Z K</a>
      </span>
    </span>
    
      &nbsp; &bull; &nbsp;<span class="entry-comments">
        <a href="/blog/2017/04/22/btree/#disqus_thread">Comment</a>
      </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2017/04/22/btree/" rel="bookmark" title="B树，B+树，B*树简介" itemprop="url">B树，B+树，B*树简介</a>
    </h1>
  
</header>

<div class="entry-content">
  <ul>
<li><h3>B树又叫平衡多路查找树（Balance-Tree)，一棵m阶B树满足以下条件：</h3>

<ul>
<li>每个节点至多有m棵子树</li>
<li>除根节点外，其他节点至少有|m/2|棵子树</li>
<li>根节点至少有两棵子树（除非B树只有一个节点）</li>
<li>所有的叶子节点位于同一层上。B树的叶子节点可以看做一种外部节点，不包含任何信息。</li>
<li>有j个孩子的非叶子节点恰好有（j-1）个关键字，关键字按照递增的次序排列。</li>
<li>对于一棵包含N个关键字，高度为h，最小度数t>=2的B树，有h&lt;=logt（(N+1)/2）
</br></br></li>
</ul>
</li>
</ul>



  
  
    <footer>
      <a class="btn" rel="full-article" href="/blog/2017/04/22/btree/">Read on &rarr;</a>
    </footer>
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2017-04-22T00:47:49+08:00">
        <a href="/blog/2017/04/22/index/">April 22, 2017</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About Z K">Z K</a>
      </span>
    </span>
    
      &nbsp; &bull; &nbsp;<span class="entry-comments">
        <a href="/blog/2017/04/22/index/#disqus_thread">Comment</a>
      </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2017/04/22/index/" rel="bookmark" title="MySql索引" itemprop="url">MySql索引</a>
    </h1>
  
</header>

<div class="entry-content">
  <ul>
<li>根据存储介质的不同，数据库分为<strong>基于磁盘的数据库</strong>（最为常见的关系型数据库，如MySQL，SQLserver，Oracle等），<strong>基于内存的数据库</strong>。而混合型数据库将这两种类型的数据库进行整合。</li>
<li>基于内存的数据库系统是最快的，因为数据库不需要对磁盘进行操作。因此，基于磁盘的数据库系统一般都有缓冲池，即一块内存区域，其作用是将从磁盘上读取的指定大小的数据&mdash;称为页或块，放入缓冲池。当再次读取时，首先判断该页是否在缓冲池中，如果在则直接读取缓冲池中的页，如果不在则读取磁盘上的页。 对于写操作，数据库将页读入缓冲池，然后在缓冲池中对页进行修改，最后将修改完成的页异步（一般为异步）写入磁盘上。
  
  
    <footer>
      <a class="btn" rel="full-article" href="/blog/2017/04/22/index/">Read on &rarr;</a>
    </footer>
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2017-04-19T20:07:37+08:00">
        <a href="/blog/2017/04/19/object/">April 19, 2017</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About Z K">Z K</a>
      </span>
    </span>
    
      &nbsp; &bull; &nbsp;<span class="entry-comments">
        <a href="/blog/2017/04/19/object/#disqus_thread">Comment</a>
      </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2017/04/19/object/" rel="bookmark" title="Object详解" itemprop="url">Object详解</a>
    </h1>
  
</header>

<div class="entry-content">
  <ul>
<li>Object类是所有类的父类，每个类都是由Object类扩展而来。如果没有明确指出父类，则默认为Object类为该类的父类。</li>
<li>可以使用Object类型的变量引用任何类型的对象。</li>
<li><p>在Java中，只有基本数据类型（数字，字符，布尔）不是对象。所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。</p>

<pre><code>   int[] i=new int[5];
   Object obj=i;
</code></pre></li>
</ul>


<h3>equals()方法</h3>

<ul>
<li>在Object类中，该方法用于判断两个对象是否具有相同的引用。</li>
<li><p>然而，经常需要检测两个对象的状态的相等性，所以一般需要覆写equals()方法。</p>

<pre><code>         public class Test{
             public boolean equals(Object otherObject){
                  }
         }
</code></pre></li>
<li><p>在子类中定义equals方法时，首先调用父类的equals方法。如果检测失败，则对象不可能相等。如果父类中的域都相等，就需要比较子类中的实例域。</p></li>
</ul>



  
  
    <footer>
      <a class="btn" rel="full-article" href="/blog/2017/04/19/object/">Read on &rarr;</a>
    </footer>
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2017-04-12T11:05:15+08:00">
        <a href="/blog/2017/04/12/jmm/">April 12, 2017</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About Z K">Z K</a>
      </span>
    </span>
    
      &nbsp; &bull; &nbsp;<span class="entry-comments">
        <a href="/blog/2017/04/12/jmm/#disqus_thread">Comment</a>
      </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2017/04/12/jmm/" rel="bookmark" title="Java内存模型" itemprop="url">Java内存模型</a>
    </h1>
  
</header>

<div class="entry-content">
  <ul>
<li><p><strong>Java 内存模型中的可见性、原子性和有序性。</strong></p></li>
<li><p><strong>可见性：</strong></p>

<ul>
<li>可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</li>
<li>可见性，是<strong>指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到</strong>。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</li>
<li><strong>在 Java 中 volatile、synchronized 和 final 实现可见性。</strong><br/><br/></li>
</ul>
</li>
</ul>



  
  
    <footer>
      <a class="btn" rel="full-article" href="/blog/2017/04/12/jmm/">Read on &rarr;</a>
    </footer>
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2017-04-11T21:00:36+08:00">
        <a href="/blog/2017/04/11/threadpool/">April 11, 2017</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About Z K">Z K</a>
      </span>
    </span>
    
      &nbsp; &bull; &nbsp;<span class="entry-comments">
        <a href="/blog/2017/04/11/threadpool/#disqus_thread">Comment</a>
      </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2017/04/11/threadpool/" rel="bookmark" title="线程池详解" itemprop="url">线程池详解</a>
    </h1>
  
</header>

<div class="entry-content">
  <ul>
<li>线程池是管理一组同构线程的资源池。线程池与工作队列密切相关，其中在工作队列中保存了所有等待执行的任务。<strong>工作者线程的任务是：从工作队列中取出一个任务，执行任务，然后返回线程等待下一个任务。线程池通过重用线程，而不是新建线程，减小线程创建与销毁的开销</strong>。</li>
<li>Excutor是顶级线程池接口</li>
<li>ExecutorService是真正的线程池接口。</li>
<li>Executors类提供了一些静态工厂用于生成一些常用的线程池，当将一个任务添加到线程池时，线程池会为每个任务创建一个线程，该线程会在某个时刻执行。</li>
</ul>



  
  
    <footer>
      <a class="btn" rel="full-article" href="/blog/2017/04/11/threadpool/">Read on &rarr;</a>
    </footer>
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2017-03-22T14:06:10+08:00">
        <a href="/blog/2017/03/22/generic/">March 22, 2017</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About Z K">Z K</a>
      </span>
    </span>
    
      &nbsp; &bull; &nbsp;<span class="entry-comments">
        <a href="/blog/2017/03/22/generic/#disqus_thread">Comment</a>
      </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2017/03/22/generic/" rel="bookmark" title="泛型程序设计" itemprop="url">泛型程序设计</a>
    </h1>
  
</header>

<div class="entry-content">
  <ul>
<li>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。</li>
<li><p>在增加泛型之前，泛型程序是利用继承实现的。</p>

<pre><code>  public class ArrayList{
  private Object[] data;
   ...
  public Object get(int i){}
  public void add(Object o){}
  }
</code></pre></li>
<li>这种方法有两个问题：</li>
<li>1.当获取一个值时必须进行强制类型转换。</li>
<li><p>2.没有错误检查，可以向数组列表中添加任何类的对象。</br></br></p></li>
<li><p>泛型提供了一个更好的解决方法：类型参数，用来指示存储元素的类型。如：ArrayList<String> arl=new ArrayList&lt;>();   (jdk1.7之后，构造函数中可以省略泛型类型)。</p>

<ul>
<li>对此编译器可以进行检查，避免插入错误的类型，同时在获取对象时不需要进行强制类型转换。</li>
<li><p>一个泛型类(generic class)就是具有一个或多个类型变量的类。
      public class Pair<T> {
      private T first;
      private T second;</p>

<pre><code>  public Pair(){
       this.first=null;
       this.second=null;
  }
  public Pair(T first,T second){
       this.first=first;
       this.second=second;
  }

  public T getFirst(){
       return first;
  }
  public T getSecond(){
       return second;
  }
  public void setFirst(T first){
       this.first=first;
  }
  public void setSecond(T second){
       this.second=second;
      }
  }
</code></pre></li>
<li>如上所示，Pair类引入了一个类型变量T,用&lt;>括起来，并放在类名之后。泛型类可以有多个类型变量。例如可以定义Pair类，两个域分别使用不同的类型变量：public class Pair&lt;T,V>{&hellip;}.</li>
<li>类中定义的泛型变量指定方法的返回类型，以及域和局部变量的类型。（一般来说，K,V分别表示关键字与值的类型，T表示任意类型）。</li>
<li>用具体的类型替换类型变量就可以实例化泛型类型，如Pair<String>。换句话来说，泛型类可以看做普通类的工厂。
</br></br></li>
</ul>
</li>
</ul>



  
  
    <footer>
      <a class="btn" rel="full-article" href="/blog/2017/03/22/generic/">Read on &rarr;</a>
    </footer>
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2017-03-22T13:33:24+08:00">
        <a href="/blog/2017/03/22/thread/">March 22, 2017</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About Z K">Z K</a>
      </span>
    </span>
    
      &nbsp; &bull; &nbsp;<span class="entry-comments">
        <a href="/blog/2017/03/22/thread/#disqus_thread">Comment</a>
      </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2017/03/22/thread/" rel="bookmark" title="线程与并发" itemprop="url">线程与并发</a>
    </h1>
  
</header>

<div class="entry-content">
  <pre><code>public class Thread  extends Object  implements Runnable

线程 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。

每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。每个线程都可以或不可以标记为一个守护程序。当某个线程中运行的代码创建一个新 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，新线程才是守护程序。

当 Java 虚拟机启动时，通常都会有单个非守护线程（它通常会调用某个指定类的 main 方法）。Java 虚拟机会继续执行线程，直到下列任一情况出现时为止：
    - 调用了 Runtime 类的 exit 方法，并且安全管理器允许退出操作发生。
    - 非守护线程的所有线程都已停止运行，无论是通过从对 run 方法的调用中返回，还是通过抛出一个传播到 run 方法之外的异常。

创建新执行线程有两种方法。一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。这种方法不再推荐。
创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动
</code></pre>

<ul>
<li>在一个单独线程中执行一个任务的步骤如下：

<ul>
<li>将任务代码移到实现了Runnable接口类的run()方法中。</li>
<li>由Runnable对象创建一个Thread对象。Thread thread=new Thread(new Runnable());</li>
<li>启动线程。thread.start().<br/><br/></li>
</ul>
</li>
</ul>



  
  
    <footer>
      <a class="btn" rel="full-article" href="/blog/2017/03/22/thread/">Read on &rarr;</a>
    </footer>
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2017-03-21T16:21:24+08:00">
        <a href="/blog/2017/03/21/spring_mybatis/">March 21, 2017</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About Z K">Z K</a>
      </span>
    </span>
    
      &nbsp; &bull; &nbsp;<span class="entry-comments">
        <a href="/blog/2017/03/21/spring_mybatis/#disqus_thread">Comment</a>
      </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2017/03/21/spring_mybatis/" rel="bookmark" title="Spring整合MyBatis框架" itemprop="url">Spring整合MyBatis框架</a>
    </h1>
  
</header>

<div class="entry-content">
  <ul>
<li><p>使用MyBatis，面对的是纯粹的Java对象，类似于Hbernate。但是对于具体的数据库操作，Hibernate会自动生成SQL语句，MyBatis 则要求自己自己编写SQL语句。</p></li>
<li><p>每一个MyBatis应用都是以一个SQLSessionFactory对象的实例为核心MyBatis可以拥有多个SQL映射文件，并通过一个配置文件对这些SQL映射文件进行装配，同时在该文件中定义一些控制属性信息。
如下：</p></li>
</ul>



  
  
    <footer>
      <a class="btn" rel="full-article" href="/blog/2017/03/21/spring_mybatis/">Read on &rarr;</a>
    </footer>
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2017-03-19T10:38:05+08:00">
        <a href="/blog/2017/03/19/generic/">March 19, 2017</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About Z K">Z K</a>
      </span>
    </span>
    
      &nbsp; &bull; &nbsp;<span class="entry-comments">
        <a href="/blog/2017/03/19/generic/#disqus_thread">Comment</a>
      </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2017/03/19/generic/" rel="bookmark" title="泛型程序设计" itemprop="url">泛型程序设计</a>
    </h1>
  
</header>

<div class="entry-content">
  <ul>
<li>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。</li>
<li><p>在增加泛型之前，泛型程序是利用继承实现的。</p>

<pre><code>  public class ArrayList{
  private Object[] data;
   ...
  public Object get(int i){}
  public void add(Object o){}
  }
</code></pre></li>
<li>这种方法有两个问题：</li>
<li>1.当获取一个值时必须进行强制类型转换。</li>
<li><p>2.没有错误检查，可以向数组列表中添加任何类的对象。</br></br></p></li>
<li><p>泛型提供了一个更好的解决方法：类型参数，用来指示存储元素的类型。如：ArrayList<String> arl=new ArrayList&lt;>();   (jdk1.7之后，构造函数中可以省略泛型类型)。</p>

<ul>
<li>对此编译器可以进行检查，避免插入错误的类型，同时在获取对象时不需要进行强制类型转换。</li>
<li><p>一个泛型类(generic class)就是具有一个或多个类型变量的类。
      public class Pair<T> {
      private T first;
      private T second;</p>

<pre><code>  public Pair(){
       this.first=null;
       this.second=null;
  }
  public Pair(T first,T second){
       this.first=first;
       this.second=second;
  }

  public T getFirst(){
       return first;
  }
  public T getSecond(){
       return second;
  }
  public void setFirst(T first){
       this.first=first;
  }
  public void setSecond(T second){
       this.second=second;
      }
  }
</code></pre></li>
<li>如上所示，Pair类引入了一个类型变量T,用&lt;>括起来，并放在类名之后。泛型类可以有多个类型变量。例如可以定义Pair类，两个域分别使用不同的类型变量：public class Pair&lt;T,V>{&hellip;}.</li>
<li>类中定义的泛型变量指定方法的返回类型，以及域和局部变量的类型。（一般来说，K,V分别表示关键字与值的类型，T表示任意类型）。</li>
<li>用具体的类型替换类型变量就可以实例化泛型类型，如Pair<String>。换句话来说，泛型类可以看做普通类的工厂。
</br></br></li>
</ul>
</li>
</ul>



  
  
    <footer>
      <a class="btn" rel="full-article" href="/blog/2017/03/19/generic/">Read on &rarr;</a>
    </footer>
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->

<article class="hentry">
  



<header>
  <div class="entry-meta">
    <span class="entry-date date published updated">
      <time datetime="2017-02-21T17:03:16+08:00">
        <a href="/blog/2017/02/21/bean_config/">February 21, 2017</a>
      </time>
    </span>
    <span class="author vcard">
      <span class="fn">
        <a href="" title="About Z K">Z K</a>
      </span>
    </span>
    
      &nbsp; &bull; &nbsp;<span class="entry-comments">
        <a href="/blog/2017/02/21/bean_config/#disqus_thread">Comment</a>
      </span>
    
  </div><!-- /.entry-meta -->
  
    <h1 class="entry-title">
      <a href="/blog/2017/02/21/bean_config/" rel="bookmark" title="Bean的配置及注入" itemprop="url">Bean的配置及注入</a>
    </h1>
  
</header>

<div class="entry-content">
  <h4>Bean的配置方式有三种：xml配置，基于注解配置，基于java类配置</h4>

<ul>
<li>Bean的配置信息包含了bean的实现及各个bean之间的依赖关系，Spring容器将各种形式的Bean的配置信息进行读取，并在Spring容器内部建立Bean定义注册表，然后根据注册表对Bean进行加载，实例化，并建立Bean之间的依赖关系，最后将准备就绪的Bean放入Bean缓冲池中，等待外部程序调用。</li>
</ul>


<h3>Bean配置方式详解：</h3>


  
  
    <footer>
      <a class="btn" rel="full-article" href="/blog/2017/02/21/bean_config/">Read on &rarr;</a>
    </footer>
  
</div><!-- /.entry-content -->





</article><!-- /.hentry -->


<div class="pagination">
  
  <a href="/archives">Blog Archives</a>
  
    <a href="/posts/2" class="btn">Next</a>
  
</div><!-- /.pagination -->

  </div><!-- /#main -->

  <div class="footer-wrapper">
    <footer role="contentinfo">
      <span>&copy; 2017 Z K.</span>

    </footer>
  </div><!-- /.footer-wrapper -->

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/javascripts/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/javascripts/octopress.js" type="text/javascript"></script>
<script src="/javascripts/scripts.min.js"></script>




          
  

</body>
</html>
