<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[ZK]]></title>
  <link href="http://ttazk.github.io/atom.xml" rel="self"/>
  <link href="http://ttazk.github.io/"/>
  <updated>2017-06-04T18:13:31+08:00</updated>
  <id>http://ttazk.github.io/</id>
  <author>
    <name><![CDATA[Z K]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[java代理]]></title>
    <link href="http://ttazk.github.io/blog/2017/06/04/proxy/"/>
    <updated>2017-06-04T15:51:47+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/06/04/proxy</id>
    <content type="html"><![CDATA[<ul>
<li>代理（Proxy）:利用代理可以在运行时创建一个实现了一组给定接口的新类。</li>
<li>代理类可以在运行时创建全新的类，这样的代理类能够实现指定的接口，代理类具有的方法如下：

<ul>
<li>指定接口所需要的全部方法。</li>
<li>Object类中的全部方法，（所有的代理类都覆盖了Object类中的方法toString,equals,hashCode,其他方法如，clone,getClass没有重新定义）</li>
<li><p>然而，不能在运行时定义这些方法的代码，而是要提供一个调用处理器(invocation Handler)。调用处理器是实现了InvocationHandler接口的类对象，在这个接口中只有一个方法：</p>

<pre><code>  Object invoke(Object proxy,Method method,Object[] args)
</code></pre></li>
</ul>
</li>
<li>无论何时调用代理对象的任何方法，调用处理器的invoke（）方法都会被调用，并向其传递Method对象和原始的调用参数。调用处理器必须给出处理调用的方式。</li>
</ul>


<!--  more -->


<h3>创建代理对象</h3>

<ul>
<li><p>需要使用Proxy类的newProxyInstance方法，该方法有三个参数</p>

<ul>
<li>一个类加载器(class loader)。对于预定义类使用null作为默认的类加载器，对于自定义的接口，使用：myInterface.class.getClassLoader()(其中myInterface为要实现的接口)</li>
<li>一个class对象数组，每个元素都是要实现的接口。</li>
<li>一个调用处理器。</li>
</ul>
</li>
<li><p>简单示例如下：</p>

<pre><code>  interface  Proxy1{
      public void print();
  }
  class ImpHandler implements InvocationHandler{

      @Override
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          // TODO Auto-generated method stub
           System.out.println("Invoke invoke() method");
           String string="return String";
          return string;
      }

  }
  public class ProxyTest {

      public static void main(String[] args) {
           // TODO Auto-generated method stub
           InvocationHandler invocationHandler=new ImpHandler();
           Object proxy=Proxy.newProxyInstance(Proxy1.class.getClassLoader(), new Class[]{Proxy1.class}, invocationHandler);
           proxy.toString();
      }
  }
  输出结果为：
  Invoke invoke() method
</code></pre></li>
<li><p>代理对象属于在运行时定义的类。没有定义代理类的名字（所以在创建代理对象时，将返回的引用传递给Object变量），sun虚拟机中的Proxy类将生成一个以字符串$Proxy开头的类名，如$proxy0.</p>

<h3>代理类的特性</h3></li>
<li>代理类是在程序运行时创建的，然而一旦创建，就变成了常规类，与其他类没有区别。</li>
<li>所有的代理类都扩展于Proxy类。一个代理类只有一个实例域&mdash;调用处理器，它定义在Proxy的父类中。为了履行代理对象的职责，所需要的任何附加数据都必须存储在调用处理器中。</li>
<li>所有的代理类中的方法仅仅调用了调用处理器的invoke()方法。</li>
<li>对于特定的类加载器与预设的一组接口来说，只能有一个代理类。也就是说，如果使用同一个类加载器和接口数组调用两次newProxyInstance()方法的话，那么只能得到同一个类的两个对象。</li>
<li><p>可以调用Proxy类的getProxyClass方法获取实现指定接口的代理类：</p>

<pre><code>  static Class&lt;?&gt; getProxyClass(classLoader,interfaces)
</code></pre></li>
<li>代理类一定是public final。如果代理类实现的所有接口都是public,代理类就不属于某个特定的包；否则所有的非公有接口都必须属于同一个包，同时代理类也属于这个包。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[B树，B+树，B*树简介]]></title>
    <link href="http://ttazk.github.io/blog/2017/04/22/btree/"/>
    <updated>2017-04-22T11:30:13+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/04/22/btree</id>
    <content type="html"><![CDATA[<ul>
<li><h3>B树又叫平衡多路查找树（Balance-Tree)，一棵m阶B树满足以下条件：</h3>

<ul>
<li>每个节点至多有m棵子树</li>
<li>除根节点外，其他节点至少有|m/2|棵子树</li>
<li>根节点至少有两棵子树（除非B树只有一个节点）</li>
<li>所有的叶子节点位于同一层上。B树的叶子节点可以看做一种外部节点，不包含任何信息。</li>
<li>有j个孩子的非叶子节点恰好有（j-1）个关键字，关键字按照递增的次序排列。</li>
<li>对于一棵包含N个关键字，高度为h，最小度数t>=2的B树，有h&lt;=logt（(N+1)/2）
</br></br></li>
</ul>
</li>
</ul>


<!-- more -->


<ul>
<li><h3>B+树：</h3>

<ul>
<li>B+树是应文件系统所需而产生的B树的变形。</li>
<li><p>m阶B+树与m阶B树的异同点：</p>

<ul>
<li>有n棵子树的节点中包含n-1个关键字。（同）</li>
<li>所有的叶子节点中包含了全部的关键字信息，以及指向这些关键字记录的指针，且叶子节点本身依关键字大小顺序连接。（B树的叶子节点并没有包含全部需要查找的信息）</li>
<li>所有的非终端节点可以看做是索引部分，节点中仅含有其子树根节点中最大（或最小）关键字。（而B树的非终端节点中页也包含需要查找的信息）</li>
</ul>
</li>
<li><p>总的来说B+树与B树的区别是：B树所有节点都包含查找的信息（类似于二叉查找树），对于要查找的关键字key，最终查找的节点可能是叶子节点，也可能是非叶子节点；B+树中只有叶子节点包含要查找的信息，非叶子节点只是作为一种索引帮助找到叶子节点的位置，对于要查找的关键字key，最终只能在叶子节点中查找到。</p></li>
<li>为什么说B+树比B树更适合实际应用中操作系统的文件索引与数据库索引？

<ul>
<li><p>B+树磁盘读写代价更低</p>

<ul>
<li>B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了</li>
<li>举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。</li>
</ul>
</li>
<li><p>B+树的查询效率更稳定</p>

<ul>
<li>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<p></br></br></p>

<ul>
<li><h3>B*树：</h3>

<ul>
<li>B<em>-tree是B+ Tree的变体，在B+树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B</em>树中非根和非叶子结点再增加指向兄弟的指针。
</br></br></li>
</ul>
</li>
<li><h3>总结：</h3>

<ul>
<li>B树：有序数组+平衡多叉树。</li>
<li>B+树：有序数组链表+平衡多叉树。</li>
<li>B*数：一棵丰满的B+树。</li>
<li>B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。</li>
<li> B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li>
<li><p>B+树的优点：</p>

<ul>
<li><ol>
<li>非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li>
</ol>
</li>
<li><ol>
<li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</li>
</ol>
</li>
</ul>
</li>
<li><p>B树的优点：</p>

<ul>
<li>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</li>
</ul>
</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySql索引]]></title>
    <link href="http://ttazk.github.io/blog/2017/04/22/index/"/>
    <updated>2017-04-22T00:47:49+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/04/22/index</id>
    <content type="html"><![CDATA[<ul>
<li>根据存储介质的不同，数据库分为<strong>基于磁盘的数据库</strong>（最为常见的关系型数据库，如MySQL，SQLserver，Oracle等），<strong>基于内存的数据库</strong>。而混合型数据库将这两种类型的数据库进行整合。</li>
<li>基于内存的数据库系统是最快的，因为数据库不需要对磁盘进行操作。因此，基于磁盘的数据库系统一般都有缓冲池，即一块内存区域，其作用是将从磁盘上读取的指定大小的数据&mdash;称为页或块，放入缓冲池。当再次读取时，首先判断该页是否在缓冲池中，如果在则直接读取缓冲池中的页，如果不在则读取磁盘上的页。 对于写操作，数据库将页读入缓冲池，然后在缓冲池中对页进行修改，最后将修改完成的页异步（一般为异步）写入磁盘上。<!--  more --></li>
<li>由此可见，缓冲池的大小决定了数据库的性能，如果数据可以完全放入缓冲池中，那么认为此时的性能是最优的。除了异步/同步将数据写入到磁盘上外，其他操作都可以在内存中完成。</li>
<li>MySql的不同的存储引擎有着不同的缓冲池。</li>
<li>顺序读取：顺序地读取磁盘上的页（是指逻辑上的顺序，不是物理上的）。随机读取：访问的页不是连续的，需要磁盘的磁头不断移动。为了保证顺序，存储引擎一般都是根据区来管理页，如InnoDB一个区是连续的64个页。因此在顺序读取时，可以保证这64个页是连续的，但是区与区之间的页不一定连续。</li>
<li>MySQL的索引是以B+树为基础的。但是B+树只能找到某条记录所在的页，需要根据二分查找在页中找到该记录的具体位置。</li>
<li>二叉查找树&ndash;》平衡二叉树&ndash;》B树&ndash;》B+树。B+树是由B树和索引顺序访问的方法演化而来的（但是现实生活中几乎没有使用B数的情况了）。</li>
<li>B+树是为磁盘或者其他 直接存取辅助设备设计的一种平衡查找树，在B+树中，所有的记录节点都是按照键值的大小顺序存放在同一层的叶子节点中，各叶子节点通过指针进行连接。</li>
<li>B+树的插入情况：</li>
</ul>


<table>
<tr>
<td>LeafPage是否已满</td>
<td>IndexPage是否已满</td>
<td>操作</td>
</tr>
<tr>
<td>否</td>
<td>否</td>
<td>直接将记录插入到叶子节点</td>
</tr>
<tr>
<td>是</td>
<td>否</td>
<td>1.拆分LeafPage</br>
2.将中间节点放到IndexPage中</br>
3.小于中间节点的记录放到左边
4.大于等于中间节点的记录放到右边</td>
</tr>
<tr>
<td>是</td>
<td>是</td>
<td>1.拆分LeafPage></br>
2.将中间节点放到IndexPage中</br>
3.小于中间节点的记录放到左边</br>
4.大于等于中间节点的记录放到 右边</br>

5.拆分IndexPage</br>
6.小于中间节点的记录放到左边</br>
7.大于等于中间节点的记录放到 右边</br>
8.中间节点放入上一层的IndexPage中</td>
</tr>


</table>


<ul>
<li><p>MySQL的B+树索引</p>

<ul>
<li>B+树索引的本质就是B+树在数据库中的实现，而B+树索引在数据库中的一个特点是高扇出性。</li>
<li>MySQL中，索引的实现是在存储引擎中实现的，每个存储引擎中的索引实现可能不同。</li>
<li><p>B+树索引分为聚集索引与辅助索引（非聚集索引），两者的数据结构相同，不同的是存储的内容不同。</p></li>
<li><p>InnoDB的B+树索引</p>

<ul>
<li>InnoDB存储引擎是索引组织表，也就是说，数据文件本身就是按照B+树方式存放数据的。其中，B+树的键为主键，如果在建立时没有指明主键，则存储引擎会主动创建一个6个字节的列作为主键。</li>
<li>在InnoDB中的B+树索引分为聚集索引与辅助索引，不管何种索引，每个页的大小都为16KB，不能改变。</li>
<li>聚集索引是根据主键创建的一棵B+树，聚集索引的叶子节点存放了表中的所有数据。</li>
<li>辅助索引就是根据索引建创建的一棵B+树，与聚集索引不同的是，其叶子节点仅存放索引键值，以及该索引键值指向的主键。也就是说，如果通过辅助索引来查找数据，当找到辅助索引的叶子节点后，很可能还要根据主键值查找聚集索引来得到数据，这种查找方式称为书签查找。因为辅助索引不包含行记录的所有数据，意味着每个页可以存放更多的键值，因此其高度一般要小于聚集索引。</li>
</ul>
</li>
<li><p>MyISAM的B+树索引</p>

<ul>
<li>在MyISAM存储引擎中，所有的行数据都存放在MYD文件中，其中B+树索引都是辅助索引，存放于MYI文件中。PrimaryKey索引与其他索引不同的是，其必须是唯一的，且不能为null。索引页的大小默认为1KB。</li>
<li>与InnoDB存储引擎不同的是，由于没有聚集索引，其索引叶子节点存放的键值不是主键值，而是在MYD文件中的物理位置。</li>
</ul>
</li>
</ul>
</li>
<li><p>并不是出现在查询条件的所有列都需要添加索引，一般在访问表中很少一部分行时才有意义。如果某个字段的取值返回很广，几乎没有重复，称为高选择性，那么此时使用B+树索引是最合适的。</p></li>
<li><p>联合索引：</p>

<ul>
<li>联合索引是指对表上的多个列进行索引。</li>
<li>联合索引还是一棵B+树，不同的是联合索引的键值数量大于等于2，如(a,b)/(a,b,c)。</li>
<li>对于联合索引（a,b），如果查询为select * from table where a=xxx and b=xxx;此时可以使用联合索引查询；对于单个列的查询select * from table where a=xxx ，此时可以使用联合索引(a,b)；但是对于b列的查询select * from table where b=xxx，不可以使用这棵B+树的索引，因此对于b列的查询不能使用联合索引。</li>
<li>联合索引的第二个好处就是可以对第二个键值进行排序。</li>
</ul>
</li>
<li><p>覆盖索引：</p>

<ul>
<li>InnoDB存储引擎支持索引覆盖，即从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。</li>
<li>对于InnoDB存储引擎中的辅助索引而言，其中包含了主键的信息（索引键值，以及该索引键值指向的主键 ），如（primaryKey1,indexKey1，primaryKey2,indexKey2 ，primaryKey3,indexKey3 ）</li>
<li>所以查询语句：select primaryKey1 from table where indexKey1=xxx;可以直接从辅助索引中查询到结果。</li>
</ul>
</li>
<li><p>优化器选择不使用索引的情况：</p>

<ul>
<li>在某些情况下，优化器并没有选择索引去查询数据，而是通过扫描聚集索引，也就是进行全表扫描来得到数据，这种情况多发生于范围查找，JOIN操作等。</li>
</ul>
</li>
<li><p>哈希索引：</p>

<ul>
<li>MySQL数据库中，Memory存储引擎支持哈希索引，InnoDB存储引擎支持自适应的哈希索引。</li>
<li>散列算法不只应用于索引中，每个数据库应用都存在该数据结构，其查找时间复杂度为O(1)。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Object详解]]></title>
    <link href="http://ttazk.github.io/blog/2017/04/19/object/"/>
    <updated>2017-04-19T20:07:37+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/04/19/object</id>
    <content type="html"><![CDATA[<ul>
<li>Object类是所有类的父类，每个类都是由Object类扩展而来。如果没有明确指出父类，则默认为Object类为该类的父类。</li>
<li>可以使用Object类型的变量引用任何类型的对象。</li>
<li><p>在Java中，只有基本数据类型（数字，字符，布尔）不是对象。所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。</p>

<pre><code>  int[] i=new int[5];
  Object obj=i;
</code></pre>

<h3>equals()方法</h3></li>
<li>在Object类中，该方法用于判断两个对象是否具有相同的引用。</li>
<li><p>然而，经常需要检测两个对象的状态的相等性，所以一般需要覆写equals()方法。</p>

<pre><code>  public class Test{
             public boolean equals(Object otherObject){
                  }
         }
</code></pre></li>
<li>在子类中定义equals方法时，首先调用父类的equals方法。如果检测失败，则对象不可能相等。如果父类中的域都相等，就需要比较子类中的实例域。</li>
</ul>


<!--  more -->


<pre><code>         public class Test{
                   public boolean equals(Object otherObject){
                   if(!super.equals(otherObject)) return false;
                    //接着比较子类中扩展的实例域    
                   }
               }        
</code></pre>

<ul>
<li><p>Java规范要求equals方法具有下面的特性：</p>

<ul>
<li>自反性：对于非空引用 x,x.equals(x)应该返回true.</li>
<li>对称性：如果x.equals(y)返回true,则y.equals(x)也应该返回true</li>
<li>传递性：x.equals(y)返回true,y.equals(z)返回true，则x.equals(z)返回true</li>
<li>一致性：如果x,y引用的对象没有发生改变，反复调用x.equals(y)返回相同的结果</li>
<li>对于非空引用x，x.equals(null)应该返回false.<br/><br/></li>
</ul>
</li>
<li><p>编写equals方法的步骤：</p>

<ul>
<li>显式参数命名为otherObject，稍后需将它转换成叫做other的变量</li>
<li><p>检测this与otherObject是否引用同一个对象</p>

<pre><code>  if(this==otherObject)
  return true;
</code></pre></li>
<li><p>检测otherObject是否为null，如果为null，则返回false</p>

<pre><code>   if(otherObject==null)  
   return false;
</code></pre></li>
<li><p>比较this与otherObject是否属于同一个类</p>

<pre><code>  if(this.getClass!==otherObject.getClass)  
  return false;
</code></pre></li>
<li><p>将otherObject转换为相应的类类型变量</p>

<pre><code>   ClassName other=(ClassName)otherObject
</code></pre></li>
<li><p>对所有需要比较的域进行比较。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配则返回true,否则返回false.</p>

<pre><code>  return field1==other.field&amp;&amp;Objects.equals(field,other.field)
</code></pre>

<br/><br/>

<h3>hashCode()方法</h3></li>
</ul>
</li>
<li>散列码(hash code)是由对象导出的一个整型值（可以是负数）。散列码没有规律，两个不同对象的散列码基本不同。</li>
<li>在Object类中，hashCode()方法的返回值默认为对象的存储地址。</li>
<li><p>String类型重写了hashCode()方法，字符串的散列码是由内容导出的。计算过程如下：</p>

<pre><code>        int hash=0;
        for(int i=0;i&lt;length();i++){
             hash=31*hash+charAt(i);
        }
        //String str1="string";  String str2=new String("string");
        //str1,str2的散列码值相同，因为其内容相同。
</code></pre></li>
<li>如果重新定义equals()方法，就必须重新定义hashCode()方法，以便用户可以将对象插入到散列表中。equals()方法与hashCode()方法的定义必须一致：如果x.equals(y)返回true,那么x.hashCode()的值必须与y.hashCode()值相等。</li>
<li><p>如果存在数组类型的域，可以使用静态的Arrays.hashCode()方法计算一个散列码，这个散列码由数组元素的散列码组成。</p>

<pre><code>  static int hashCode(type[] a)//数组类型可以是任意类型
</code></pre>

<br/><br/>

<h3>toString()方法</h3></li>
<li>该方法用于返回表示对象值的字符串。</li>
<li>Object类中的toString()方法返回对象所属的类名及散列码。</li>
<li>只要将对象与一个字符串通过"+&ldquo;相连，Java编译器就会自动调用toString()方法，以便获得这个对象的字符串表示。</li>
<li>大部分类覆写了toString()方法，返回值为：类的名字，随后是一对方括号括起来的域值。</li>
<li><p>数组类型继承了Object类的toString方法，如果直接输出数组，如：int[] arr={1,2,3};，会生成字符串：类型+hashCode。如果想要输出[1,2,3]，则需调用Arrays.toString()方法。</p>

<pre><code>      static String toString(type[] a)            
</code></pre>

<br/><br/>

<h3>getClass()方法</h3></li>
<li>返回此 Object 的运行时类。返回的 Class 对象是由所表示类的 static synchronized 方法锁定的对象
<br/><br/>

<h3>protected Object clone()</h3></li>
<li>创建并返回此对象的一个副本。“副本”的准确含义可能依赖于对象的类。这样做的目的是，对于任何对象 x表达式： x.clone() != x 为 true，表达式： x.clone().getClass() == x.getClass()也为 true，但这些并非必须要满足的要求。</li>
<li>一般情况下： x.clone().equals(x)为 true，但这并非必须要满足的要求。</li>
<li>按照惯例，返回的对象应该通过调用 super.clone 获得。如果一个类及其所有的超类（Object 除外）都遵守此约定，则 x.clone().getClass() == x.getClass()。</li>
<li>按照惯例，此方法返回的对象应该独立于该对象（正被复制的对象）。要获得此独立性，在 super.clone 返回对象之前，有必要对该对象的一个或多个字段进行修改。这通常意味着要复制包含正在被复制对象的内部“深层结构”的所有可变对象，并使用对副本的引用替换对这些对象的引用。如果一个类只包含基本字段或对不变对象的引用，那么通常不需要修改 super.clone 返回的对象中的字段。</li>
<li>Object 类的 clone 方法执行特定的复制操作。首先，如果此对象的类不能实现接口 Cloneable，则会抛出 CloneNotSupportedException。注意，所有的数组都被视为实现接口 Cloneable。否则，此方法会创建此对象的类的一个新实例，并像通过分配那样，严格使用此对象相应字段的内容初始化该对象的所有字段；这些字段的内容没有被自我复制。所以，此方法执行的是该对象的“浅表复制”，而不“深层复制”操作。</li>
<li>Object 类本身不实现接口 Cloneable，所以在类为 Object 的对象上调用 clone 方法将会导致在运行时抛出异常。
<br/><br/>

<h3>public final void notify()</h3></li>
<li>唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。</li>
<li>直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。</li>
<li>此方法只应由作为此对象监视器的所有者的线程来调用。通过以下三种方法之一，线程可以成为此对象监视器的所有者：

<ul>
<li>通过执行此对象的同步实例方法。</li>
<li>通过执行在此对象上进行同步的 synchronized 语句的正文。</li>
<li>对于 Class 类型的对象，可以通过执行该类的同步静态方法。</li>
</ul>
</li>
<li>一次只能有一个线程拥有对象的监视器。
<br/><br/>

<h3>public final void wait(long timeout)</h3></li>
<li>此方法导致当前线程（称之为 T）将其自身放置在对象的等待集中，然后放弃此对象上的所有同步要求。出于线程调度目的，在发生以下四种情况之一前，线程 T 被禁用，且处于休眠状态：

<ul>
<li>其他某个线程调用此对象的 notify 方法，并且线程 T 碰巧被任选为被唤醒的线程。</li>
<li>其他某个线程调用此对象的 notifyAll 方法。</li>
<li>其他某个线程中断线程 T。</li>
<li>大约已经到达指定的实际时间。但是，如果 timeout 为零，则不考虑实际时间，在获得通知前该线程将一直等待。</li>
</ul>
</li>
<li>然后，从对象的等待集中删除线程 T，并重新进行线程调度。然后，该线程以常规方式与其他线程竞争，以获得在该对象上同步的权利；一旦获得对该对象的控制权，该对象上的所有其同步声明都将被恢复到以前的状态，这就是调用 wait 方法时的情况。然后，线程 T 从 wait 方法的调用中返回。所以，从 wait 方法返回时，该对象和线程 T 的同步状态与调用 wait 方法时的情况完全相同
<br/><br/>

<h3>protected void finalize()</h3></li>
<li>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 finalize 方法，以配置系统资源或执行其他清除。</li>
</ul>


<h3>protected void finalize() throws Throwable</h3>

<ul>
<li>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 finalize 方法，以配置系统资源或执行其他清除。</li>
<li>finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象或类的终结操作执行了某个操作。finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，以便在永久丢弃对象之前中断连接。</li>
<li>Object 类的 finalize 方法执行非特殊性操作；它仅执行一些常规返回。Object 的子类可以重写此定义。</li>
<li>Java 编程语言不保证哪个线程将调用某个给定对象的 finalize 方法。但可以保证在调用 finalize 时，调用 finalize 的线程将不会持有任何用户可见的同步锁定。如果 finalize 方法抛出未捕获的异常，那么该异常将被忽略，并且该对象的终结操作将终止。</li>
<li>在启用某个对象的 finalize 方法后，将不会执行进一步操作，直到 Java 虚拟机再次确定尚未终止的任何线程无法再通过任何方法访问此对象，其中包括由准备终止的其他对象或类执行的可能操作，在执行该操作时，对象可能被丢弃。</li>
<li>对于任何给定对象，Java 虚拟机最多只调用一次 finalize 方法。</li>
<li>finalize 方法抛出的任何异常都会导致此对象的终结操作停止，但可以通过其他方法忽略它。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java内存模型]]></title>
    <link href="http://ttazk.github.io/blog/2017/04/12/jmm/"/>
    <updated>2017-04-12T11:05:15+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/04/12/jmm</id>
    <content type="html"><![CDATA[<ul>
<li><p><strong>Java 内存模型中的可见性、原子性和有序性。</strong></p></li>
<li><p><strong>可见性：</strong></p>

<ul>
<li>可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</li>
<li>可见性，是<strong>指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到</strong>。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</li>
<li><strong>在 Java 中 volatile、synchronized 和 final 实现可见性。</strong><br/><br/></li>
</ul>
</li>
</ul>


<!--  more -->


<ul>
<li><strong>原子性：</strong>

<ul>
<li>原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</li>
<li><strong>在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性</strong>。<br/><br/></li>
</ul>
</li>
<li><p><strong>有序性：</strong></p>

<ul>
<li><p>Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p>

<pre><code>  public class NoVisibility {
      private static boolean ready;
      private static int number;
      private static class ReaderThread extends Thread {
          @Override
          public void run() {
              while(!ready) {
                  Thread.yield();
              }
              System.out.println(number);
          }
      }
      public static void main(String[] args) {
          new ReaderThread().start();
          number = 42;
          ready = true;
      }
  }
</code></pre></li>
<li>NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。</li>
<li><strong>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行春旭进行判断，无法得到正确的结论。
　　这个看上去像是一个失败的设计，但却能使JVM充分地利用现代多核处理器的强大性能。例如，在缺少同步的情况下，Java内存模型允许编译器对操作顺序进行重排序，并将数值缓存在寄存器中。此外，它还允许CPU对操作顺序进行重排序，并将数值缓存在处理器特定的缓存中</strong>。<br/><br/></li>
</ul>
</li>
<li><p><strong>Volatile关键字原理：</strong></p>

<ul>
<li>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</li>
<li>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</li>
<li><em>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。
　　而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步</em>。<br/><br/></li>
</ul>
</li>
<li><p>当一个变量定义为 volatile 之后，将具备两种特性：</p>

<ul>
<li>1.<strong>保证此变量对所有的线程的可见性</strong>，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值 能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。</li>
<li>2.<strong>禁止指令重排序优化</strong>。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。<br/><br/></li>
</ul>
</li>
<li><p>volatile 性能：</p>

<ul>
<li>volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线程池详解]]></title>
    <link href="http://ttazk.github.io/blog/2017/04/11/threadpool/"/>
    <updated>2017-04-11T21:00:36+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/04/11/threadpool</id>
    <content type="html"><![CDATA[<ul>
<li>线程池是管理一组同构线程的资源池。线程池与工作队列密切相关，其中在工作队列中保存了所有等待执行的任务。<strong>工作者线程的任务是：从工作队列中取出一个任务，执行任务，然后返回线程等待下一个任务。线程池通过重用线程，而不是新建线程，减小线程创建与销毁的开销</strong>。</li>
<li>Excutor是顶级线程池接口</li>
<li>ExecutorService是真正的线程池接口。</li>
<li>Executors类提供了一些静态工厂用于生成一些常用的线程池，当将一个任务添加到线程池时，线程池会为每个任务创建一个线程，该线程会在某个时刻执行。</li>
</ul>


<!--  more -->


<p> <strong>public class Executors extends Object</strong></p>

<pre><code>public static ExecutorService newCachedThreadPool()
空闲线程会被保留60秒。对于每个任务，如果有空闲线程可用，立即让它执行任务；如果没有空闲的线程，则创建一个新的线程。

public static ExecutorService newFixedThreadPool(int nThreads)
构建一个具有固定大小的线程池。如果提交的任务大于空闲的线程数，则把任务放置到队列中。

public static ExecutorService newSingleThreadExecutor()
 线程数目为1的线程池，由一个线程执行提交的任务，一个接一个。
</code></pre>

<ul>
<li>为了解决执行服务的生命周期问题，ExecutorService扩展了Executor接口，添加了一些用于生命周期管理的方法。</li>
<li><strong>ExecutorService的生命周期有三种：运行，关闭，已终止。ExecutorService在初始创建时处于运行状态。shutdowm方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务的完成&mdash;包括那写还没有开始执行的任务。shutdownNow方法将执行粗暴的关闭过程：它将取消所有运行中的任务，并且不再启动队列中尚未开始的任务。在ExecutorService关闭后提交的任务将由“拒绝处理执行器 ”来处理，它会抛弃任务，或者使得execute()方法抛出一个未检查异常。等到所有的任务完成后，ExecutorService进入终止状态。</strong></li>
</ul>


<p><strong>public interface ExecutorService extends Executor</strong></p>

<p>Executor 提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 Future 的方法。
可以关闭 ExecutorService，这将导致其拒绝新任务。提供两个方法来关闭 ExecutorService。shutdown() 方法在终止前允许执行以前提交的任务，而 shutdownNow() 方法阻止等待任务启动并试图停止当前正在执行的任务。在终止时，执行程序没有任务在执行，也没有任务在等待执行，并且无法提交新任务。应该关闭未使用的 ExecutorService 以允许回收其资源。</p>

<p>通过创建并返回一个可用于取消执行和/或等待完成的 Future，方法 submit 扩展了基本方法 Executor.execute(java.lang.Runnable)。方法 invokeAny 和 invokeAll 是批量执行的最常用形式，它们执行任务 collection，然后等待至少一个，或全部任务完成（可使用 ExecutorCompletionService 类来编写这些方法的自定义变体）。</p>

<pre><code>    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)
    提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。

    &lt;T&gt; Future&lt;T&gt; submit(Runnable task,
                         T result)
    提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功完成时将会返回给定的结果。

    Future&lt;?&gt; submit(Runnable task)
    提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功 完成时将会返回 null。

    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
                              throws InterruptedException
    执行给定的任务，当所有任务完成时，返回保持任务状态和结果的 Future 列表。返回列表的所有元素的 Future.isDone() 为 true。注意，可以正常地或通过抛出异常来终止已完成 任务。如果正在进行此操作时修改了给定的 collection，则此方法的结果是不确定的。

    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)
               throws InterruptedException,
                       ExecutionException
    执行给定的任务，如果某个任务已成功完成（也就是未抛出异常），则返回其结果。一旦正常或异常返回后，则取消尚未完成的任务。如果此操作正在进行时修改了给定的 collection，则此方法的结果是不确定的。

    void shutdown()
    启动一次顺序关闭，执行以前提交的任务，但不接受新任务。如果已经关闭，则调用没有其他作用。

    List&lt;Runnable&gt;  shutdownNow()
    试图停止所有正在执行的活动任务，暂停处理正在等待的任务，并返回等待执行的任务列表。 无法保证能够停止正在处理的活动执行任务，但是会尽力尝试。例如，通过 Thread.interrupt() 来取消典型的实现，所以任何任务无法响应中断都可能永远无法终止。

    boolean isShutdown()
    如果此执行程序已关闭，则返回 true。

    boolean isTerminated()
    如果关闭后所有任务都已完成，则返回 true。注意，除非首先调用 shutdown 或 shutdownNow，否则 isTerminated 永不为 true。
</code></pre>

<ul>
<li><p>Runnable封装了一个异步运行的任务，可以把它想象为一个没有参数和返回值的方法。Callable与Runnable类似，但是有返回值。</p>

<pre><code>    public interface Callable&lt;V&gt;{
         v call() throws Exception;  
    }
</code></pre></li>
</ul>


<p><strong>public interface Future<V></strong></p>

<p>Future 表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如有必要，计算完成前可以阻塞此方法。取消则由 cancel 方法来执行。还提供了其他方法，以确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?> 形式类型、并返回 null 作为底层任务的结果。</p>

<p>用法示例（注意，下列各类都是构造好的。）</p>

<pre><code>    interface ArchiveSearcher { String search(String target); }
    class App {
      ExecutorService executor = ...
      ArchiveSearcher searcher = ...
      void showSearch(final String target)
          throws InterruptedException {
        Future&lt;String&gt; future
          = executor.submit(new Callable&lt;String&gt;() {
            public String call() {
                return searcher.search(target);
            }});
        displayOtherThings(); // do other things while searching
        try {
          displayText(future.get()); // use future
        } catch (ExecutionException ex) { cleanup(); return; }
      }
    }
</code></pre>

<ul>
<li><p>FutureTask 类是 Future 的一个实现，Future 可实现 Runnable，所以可通过 Executor 来执行。例如，可用下列内容替换上面带有 submit 的构造：</p>

<pre><code>  FutureTask&lt;String&gt; future =
    new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() {
      public String call() {
        return searcher.search(target);
    }});
  executor.execute(future);
</code></pre>

<p>Future的方法：</p>

<pre><code>  boolean cancel(boolean mayInterruptIfRunning)
  试图取消对此任务的执行。如果任务已完成、或已取消，或者由于某些其他原因而无法取消，则此尝试将失败。当调用 cancel 时，如果调用成功，而此任务尚未启动，则此任务将永不运行。如果任务已经启动，则 mayInterruptIfRunning 参数确定是否应该以试图停止任务的方式来中断执行此任务的线程。
  此方法返回后，对 isDone() 的后续调用将始终返回 true。如果此方法返回 true，则对 isCancelled() 的后续调用将始终返回 true。

  boolean isCancelled()
  如果在任务正常完成前将其取消，则返回 true。

  boolean isDone()
  如果任务已完成，则返回 true。 可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true。

  V get()    throws InterruptedException,
              ExecutionException
  如有必要，等待计算完成，然后获取其结果。
  get方法调用被阻塞，直到计算完成。

  V get(long timeout,
        TimeUnit unit)
        throws InterruptedException,
              ExecutionException,
              TimeoutException
  如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。
  get方法调用被阻塞，直到计算完成，如果在计算完成之前超时，将抛出TimeoutExecption异常。
</code></pre></li>
</ul>


<p><strong>public class FutureTask<V> extends Object implements</strong> <strong>RunnableFuture<V> ,Runnable,Future<V></strong></p>

<ul>
<li>可取消的异步计算。利用开始和取消计算的方法、查询计算是否完成的方法和获取计算结果的方法，此类提供了对 Future 的基本实现。仅在计算完成时才能获取结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。</li>
<li><p>可使用 FutureTask 包装 Callable 或 Runnable 对象。因为 FutureTask 实现了 Runnable，所以可将 FutureTask 提交给 Executor 执行。</p>

<pre><code>  public FutureTask(Callable&lt;V&gt; callable)
  创建一个 FutureTask，一旦运行就执行给定的 Callable。

  public FutureTask(Runnable runnable,
                    V result)
  创建一个 FutureTask，一旦运行就执行给定的 Runnable，并安排成功完成时 get 返回给定的结果 。
</code></pre></li>
<li><p>使用连接池应该做的事：</p>

<ul>
<li>调用Executors类中的静态方法newCachedThreadPool或newFixedThreadPool。</li>
<li>调用submit()提交Runnable/Callable对象，会得到一个Future对象，可以用来查询该任务的状态。</li>
<li><p>当不想提交任务时，调用shutDowm。</p>

<pre><code>  class ThreadTest implements Runnable {
      public synchronized void run() {
           for (int i = 0; i &lt; 5; i++) {
               System.out.print(i+" ");
           }
           System.out.println();
      }
  }

  public class ThreadPoolTest {

      public static void main(String[] args) {
           // TODO Auto-generated method stub
           ExecutorService executorService=Executors.newCachedThreadPool();
           ThreadTest thread=new ThreadTest();
           for(int i=0;i&lt;10;i++){
               executorService.execute(thread);
           }
           executorService.shutdown();
      }
  }
</code></pre></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[泛型程序设计]]></title>
    <link href="http://ttazk.github.io/blog/2017/03/22/generic/"/>
    <updated>2017-03-22T14:06:10+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/03/22/generic</id>
    <content type="html"><![CDATA[<ul>
<li>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。</li>
<li><p>在增加泛型之前，泛型程序是利用继承实现的。</p>

<pre><code>  public class ArrayList{
  private Object[] data;
   ...
  public Object get(int i){}
  public void add(Object o){}
  }
</code></pre></li>
<li>这种方法有两个问题：</li>
<li>1.当获取一个值时必须进行强制类型转换。</li>
<li><p>2.没有错误检查，可以向数组列表中添加任何类的对象。</br></br></p></li>
<li><p>泛型提供了一个更好的解决方法：类型参数，用来指示存储元素的类型。如：ArrayList<String> arl=new ArrayList&lt;>();   (jdk1.7之后，构造函数中可以省略泛型类型)。</p>

<ul>
<li>对此编译器可以进行检查，避免插入错误的类型，同时在获取对象时不需要进行强制类型转换。</li>
<li><p>一个泛型类(generic class)就是具有一个或多个类型变量的类。
      public class Pair<T> {
      private T first;
      private T second;</p>

<pre><code>  public Pair(){
       this.first=null;
       this.second=null;
  }
  public Pair(T first,T second){
       this.first=first;
       this.second=second;
  }

  public T getFirst(){
       return first;
  }
  public T getSecond(){
       return second;
  }
  public void setFirst(T first){
       this.first=first;
  }
  public void setSecond(T second){
       this.second=second;
      }
  }
</code></pre></li>
<li>如上所示，Pair类引入了一个类型变量T,用&lt;>括起来，并放在类名之后。泛型类可以有多个类型变量。例如可以定义Pair类，两个域分别使用不同的类型变量：public class Pair&lt;T,V>{&hellip;}.</li>
<li>类中定义的泛型变量指定方法的返回类型，以及域和局部变量的类型。（一般来说，K,V分别表示关键字与值的类型，T表示任意类型）。</li>
<li>用具体的类型替换类型变量就可以实例化泛型类型，如Pair<String>。换句话来说，泛型类可以看做普通类的工厂。
</br></br></li>
</ul>
</li>
</ul>


<!--more-->


<h3>* 泛型方法</h3>

<ul>
<li><p>可以在一个普通类中定义一个带有类型参数的简单方法。</p>

<pre><code>public class Generic {
public static &lt;T&gt; void print(T t){
System.out.println(t);
    }
}
</code></pre></li>
<li><p>注意：类型变量放在修饰符的后面，返回类型的前面。</p></li>
<li>泛型方法可以定义在普通类中，也可以定义在泛型类中。</li>
<li><p>当调用一个泛型方法时，可以在方法名前的&lt;>中放入具体的类型，也可以省略&lt;>类型参数。</p>

<pre><code>Generic.print("no");
Generic.&lt;String&gt;print("nothing");
</code></pre></li>
</ul>


<h3>* 类型变量的限定</h3>

<ul>
<li><p>有时，需要对类或泛型方法中的类型变量加以限定。</p>

<pre><code>      public static &lt;T extends Comparable&gt; void sys(T t){
       System.out.println(t);
      }
</code></pre></li>
<li>可以对泛型变量T进行限定，将其限定为实现了Comparable接口的类。</li>
<li><T extends BoundingType> 表示：T应该是绑定类型的子类型。T和绑定类型可以是类，也可以是接口。</li>
<li>一个类型变量或通配符可以有多个限定，如：T extends Comaprable &amp; Serializable</li>
<li>在Java的继承中，可以根据需要有多个接口的父类型，但是限定中至多只能有一个类，且必须是限定列表中的第一个。</li>
</ul>


<h3>* 类型擦除</h3>

<ul>
<li>在虚拟机中，没有泛型类型对象&mdash;-所有的对象都属于普通类。</li>
<li>无论何时定义一个泛型类型，都会自动提供一个相应的原始类型(raw type)。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型（没有限定类型就用Object）。</li>
<li><p>例如，Pair<T>的原始类型为：
      public class Pair{
      private Object first;
      private Object second;</p>

<pre><code>  public Pair(){
       this.first=null;
       this.second=null;
  }
  public Pair(Object first,Object second){
       this.first=first;
       this.second=second;
  }

  public Object getFirst(){
       return first;
  }
  public Object getSecond(){
       return second;
  }
  public void setFirst(Object first){
       this.first=first;
  }
  public void setSecond(Object second){
       this.second=second;
  }
  }
</code></pre></li>
<li><p>在程序中可以包含不同类型的Pair，如Pair<String>,Pair<LocalDate>，但是类型擦除后就变成了原始的Pair类型了。</p></li>
<li>原始类型用第一个限定类型来替换参数变量，如果没有给定限定类型，就用Object替换。</li>
<li>为了提高效率，应该将标签接口(没有方法的接口)放在列表的末尾。</li>
</ul>


<h3>* 翻译泛型表达式</h3>

<ul>
<li><p>当程序调用泛型方法时，如果擦除返回类型，编译器则插入强制类型转换。</p>

<pre><code>  Pair&lt;Employee&gt; p=new Pair&lt;&gt;();
  Employee e=p.getFirst();//先对原始方法调用Pair.getFirst();再将返回的Object类型强制转换成Employee类型。
</code></pre></li>
<li>关于java泛型转换的事实：

<ul>
<li>虚拟机中没有泛型，只有普通的类与方法。</li>
<li>所有的参数类型都用它们的限定类型进行替换。</li>
<li>为了保持类型安全，必要时插入强制类型转换。</li>
<li>桥方法被合成来保持多态。</li>
</ul>
</li>
</ul>


<h3>* 约束与局限性(大多数限制都是由类型擦除引起的)</h3>

<h5>* 不能用基本类型实例化类型参数</h5>

<ul>
<li>因此没有Pair<double>，只有Pair<Double>。原因是类型擦除，擦除之后，Pair类含有Object域，而Object域不能存储基本类型。

<h5>* 运行时类型查询只适用于原始类型</h5></li>
<li><p>虚拟机中的对象总有一个特定的非泛型类型，因此，所有的类型查询只产生原始类型。</p>

<pre><code>  Pair&lt;String&gt; pair=new Pair&lt;String&gt;();
  if (pair instanceof Pair&lt;String&gt;) {    //error
     System.out.println(true);
  } 
  if (pair instanceof Pair) {         //true
  System.out.println(true);
  }
</code></pre></li>
<li><p>同样，getClass()方法返回的是原始类型。</p>

<pre><code>  Pair&lt;String&gt; pair=new Pair&lt;String&gt;();
  Pair&lt;Double&gt; pair2=new Pair&lt;Double&gt;();
  if (pair.getClass()==pair2.getClass()) {
  System.out.println(true);
  }         //输出为true
</code></pre></li>
</ul>


<h5>* 不能创建泛型数组</h5>

<pre><code>Pair&lt;String&gt;[] pairs=new Pair&lt;String&gt;[10];  //error
</code></pre>

<ul>
<li>只是不能创建这些数组，但是声明类型Pair<String>[] 的变量仍是合法的，只能不过不能初始化。</li>
<li>原因也是类型擦除。</li>
</ul>


<h5>* 不能实例化类型变量</h5>

<ul>
<li>即不能使用new T(&hellip;),new T[&hellip;],或T.class这样的表达式中的类型变量。

<h5>* 不能创建类型变量数组</h5>

  private T[] ts=new T[2];   //error

<h5>* 不能在静态域或静态方法中引用类型变量</h5>

  private static T t;   //error
  public static T print(){}   //error
</br>

<h3>* 泛型类型的继承规则</h3></li>
<li>考虑一个类与一个子类，如Object,String，那么Pair<String>是Pair<Object>的子类吗？不是</li>
<li>无论T和V有什么关系，通常Pair<V>,Pair<T>是没有任何关系的。
Pair<Object>[] pair3=new Pair<String>[10];  //error</li>
<li>注意泛型与Java数组之间的区别：可以将子类数组的变量赋给父类数组变量。
Object[] objects=new String[10];</li>
<li>永远可以将参数化类型转换为一个原始类型。
Pair pair3=new Pair<String>();</li>
<li>泛型类可以扩展或者实现其他泛型类，这点而言与普通类没有区别</li>
<li>ArrayList<T>类实现了List<T>接口。</li>
<li>意味着ArrayList<String>可以转换为List<String></li>
</ul>


<h3>* 通配符类型</h3>

<ul>
<li>通配符类型中，允许类型参数变化。如  Pair&lt;? extends Comparable></li>
<li><p>类型Pair<String>是Pair&lt;? extends Object>的子类型。                                                                                        &lt;&mdash;Pair<Object>
Pair(原始类型)&lt;&mdash;Pair&lt;? extends Object><---
                  <---Pair<String></p></li>
<li><p>通配符的超类型限定</p></li>
<li>可以指定一个父类型：  ? super Manager</li>
<li>带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。(P332)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线程与并发]]></title>
    <link href="http://ttazk.github.io/blog/2017/03/22/thread/"/>
    <updated>2017-03-22T13:33:24+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/03/22/thread</id>
    <content type="html"><![CDATA[<pre><code>public class Thread  extends Object  implements Runnable

线程 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。

每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。每个线程都可以或不可以标记为一个守护程序。当某个线程中运行的代码创建一个新 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，新线程才是守护程序。

当 Java 虚拟机启动时，通常都会有单个非守护线程（它通常会调用某个指定类的 main 方法）。Java 虚拟机会继续执行线程，直到下列任一情况出现时为止：
    - 调用了 Runtime 类的 exit 方法，并且安全管理器允许退出操作发生。
    - 非守护线程的所有线程都已停止运行，无论是通过从对 run 方法的调用中返回，还是通过抛出一个传播到 run 方法之外的异常。

创建新执行线程有两种方法。一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。这种方法不再推荐。
创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动
</code></pre>

<ul>
<li>在一个单独线程中执行一个任务的步骤如下：

<ul>
<li>将任务代码移到实现了Runnable接口类的run()方法中。</li>
<li>由Runnable对象创建一个Thread对象。Thread thread=new Thread(new Runnable());</li>
<li>启动线程。thread.start().<br/><br/></li>
</ul>
</li>
</ul>


<!--  more -->


<ul>
<li><p>Runnable接口有唯一的方法run(),用于定义将要执行的任务。</p>

<ul>
<li>Thread类实现了Runnable接口，有run(),start()方法，具体如下：

<pre><code>  - Thread(Runnable target)
    构造一个新的线程，用于调用给定目标的run()方法。

  - public void start()
  启动这个线程，将引发调用run()方法。这个方法立即返回，并且新线程将并发运行。
  使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
  结果是两个线程并发地运行；当前线程（从调用返回给 start 方法）和另一个线程（执行其 run 方法）。
  多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。

  - public void run()
  调用关联的Runnable的run()方法。
  如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回

      * 即当调用Thread.start()方法时，会启动一个新的线程，并执行Runnable对象的run()方法。
      * start()方法会立即返回，但是run()方法会继续执行。所以会出现多个线程同时在运行，当run方法运行结束时，线程终止。      ps:main()线程是主线程
      * 不要调用Thread类或Runable对象的run()方法。直接调用run()方法，只会执行同一个线程中的任务，而不会启动新的线程。应该调用Thread.start方法。这个方法将创建一个执行run方法的新线程。


  public void interrupt()
  向线程发送中断请求。线程的中断状态被设置为true。如果目前线程被一个sleep调用阻塞，那么会抛出InterruptedException。

  public static boolean interrupted()
  测试当前线程是否已经中断。线程的中断状态 由该方法清除，会将当前线程的中断状态重置为false。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。

  public boolean isInterrupted()
  测试线程是否已经中断。线程的中断状态 不受该方法的影响。
</code></pre></li>
</ul>
</li>
<li><p>没有可以强制线程终止的方法，interrupt方法用来请求终止线程。当调用interrupt方法时，线程的中断状态被置位。没有要求一个被中断的线程应该终止。中断一个线程只不过是引起它的注意，被中断的线程可以决定如何响应。可以不理会中断，但是大部分线程是将中断作为一个终止的请求，被中断的线程会在安全的时候终止。实际上，运行中的线程被中断，目的是为了让其他线程获得运行的机会。</p></li>
</ul>


<h3>线程状态：</h3>

<ul>
<li>New(新创建)：使用new操作符创建新的线程</li>
<li>Runnable(可运行)：一旦调用start方法，线程便处于可运行状态。一个可运行的线程可能在运行，也可能没有运行。</li>
<li><p>Bolcked(被阻塞)，Waiting(等待)：此时线程暂时不活动。</p>

<ul>
<li>当线程试图获取一个内部的对象锁时，而该锁被其他线程所持有，则该线程进入阻塞状态。</li>
<li>当一个线程等待另个线程通知调度器一个条件时，它自己进入等待状态。</li>
<li>有几个方法有一个超时参数。调用它们导致进入计时等待。thread.sleep、thread.join、thread.wait，condition.await。</li>
</ul>
</li>
<li><p>Terminated(被终止)：因为run方法正常退出而终止/因为一个没有捕获异常而终止。</p>

<pre><code>  public final void join()             
  等待该线程终止。
  public final void join(long millis)               
  等待该线程终止的时间最长为 millis 毫秒。超时为 0 意味着要一直等下去
  public static void sleep(long millis)                
  在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。该线程不丢失任何监视器的所属权。
  public static void yield()
  暂停当前正在执行的线程对象，并执行其他线程。
</code></pre></li>
</ul>


<h3>线程同步</h3>

<ul>
<li>有两种方法可以防止代码受并发访问的干扰：1.使用synchronized关键字；2.jdk1.5引入了ReentrantLock类，实现了锁机制。</li>
<li><p>ReentrantLock类保护代码的基本结构如下：</p>

<pre><code>  ReentrantLock myLock=new ReentrantLock():
  myLock.lock()://获得锁
  try{
       临界区资源，存放着共同访问的资源
  }
  fianlly{
       myLock.unlock();//释放锁
  }
</code></pre>

<ul>
<li>这一结构确保了任何时刻只有一个线程进入临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。注意，要把解锁操作放在fianlly子句中。如果两个线程试图访问同一个锁对象，那么锁以串行的方式提供服务；如果两个线程访问的是不同的锁对象，那么两个线程都不会阻塞。所以，如果想要使线程同步，必须是同一个锁对象。</li>
<li><p>锁是可重入的，因为线程可以重复获得已经持有的锁。锁保持一个持有计数来跟踪lock方法的嵌套调用。线程每次调用一次lock,都要调用一次unlock释放锁。被一个锁保护的代码可以调用另一个使用相同锁的方法。<br/>
Lock:</p>

<pre><code>    public interface Lock
    Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作。

    void lock()
    获取锁。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态

    void unlock()
    释放锁

    Condition newCondition()
    返回绑定到此 Lock 实例的新 Condition 实例。
    在等待条件前，锁必须由当前线程保持。调用 Condition.await() 将在等待前以原子方式释放锁，并在等待返回前重新获取锁。

    boolean tryLock()
    仅在调用时锁为空闲状态才获取该锁。尝试获取锁而不会发生阻塞。
    如果锁可用，则获取锁，并立即返回值 true。如果锁不可用，则此方法将立即返回值 false。
    此方法的典型使用语句如下：
          Lock lock = ...;
          if (lock.tryLock()) {
              try {
                  // manipulate protected state
              } finally {
                  lock.unlock();
              }
          } else {
              // perform alternative actions
          }

    此用法可确保如果获取了锁，则会释放锁，如果未获取锁，则不会试图将其释放。
</code></pre>

<p>ReentrantLock:</p>

<pre><code>    public class ReentrantLock extends Object implements Lock, Serializable

    一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。

    除了ReentrantLock，还有一种锁，ReentrantReadWriteLock(读/写锁)，使用该锁的步骤：

        1. 
            1. 
                1. 构造 一个ReentrantReadWriteLock对象：private ReentrantReadWriteLock rwl=new ReentrantReadWriteLock();
                2. 抽取读锁与写锁：Lock read=rwl.readLock();  Lock write=rwl.writeLock();
                3. 对所有的获取方法加读锁，对所有的修改方法加写锁。




    Lock readLock();得到一个可以被多个读操作共用的读锁，但会排斥所有的写锁
    Lock writeLock();得到一个写锁，排斥其他的读操作与写操作。



        * 条件对象
        * 如果一个线程获得锁，进入临界区，但是该线程因为自身条件不足无法继续执行。可以使用条件对象使自己阻塞，并放弃锁，从而将机会让给别的线程。
        * 一个锁对象可以有多个条件对象。可以使用newCondition()方法获得一个条件对象。
</code></pre>

<p>Condition:</p>

<pre><code>    public interface Condition
    Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得 Condition 实例，请使用其 newCondition() 方法。
    void await()
    将该线程放到条件的等待集中。
    void signalAll()
    解除该条件的等待集中所有线程的阻塞状态。
    void signal()
    从该条件的等待集中随机地选择一个线程，解除其阻塞状态。

        * 当条件对象调用await()时，线程被阻塞，并放弃锁。
        * 等待获得锁的线程与调用await()方法的线程本质上不同。一旦一个线程调用await()方法，它进入该条件的等待集中。当锁可用时，该线程不能马上解除阻塞，相反，它处于阻塞状态，直到另一个线程调用同一个条件上的siagnalAll方法时为止。当线程从等待集中移出时，它们再次成为可运行的。一旦锁成为可用的，它们中的某个将从await()调用返回，获得该锁，并从被阻塞的地方继续执行。
        * 当一个线程调用await()方法时，它是没法自己激活自己，只能等待其他线程激活。如果没有线程来激活，就会出现死锁。
        * 当一个线程拥有某个条件的锁时，它仅仅可以在该条件上调用await().signalAll()。
</code></pre></li>
</ul>
</li>
</ul>


<h3>synchronized关键字</h3>

<ul>
<li>Java中的每个对象都有一个内部锁。如果一个方法使用synchonized关键字声明，那么对象的锁将保护整个方法。也就是说，调用该方法，线程必须获得内部的对象锁。调用synchonized方法时获取锁，方法返回时释放锁。</li>
<li>内部对象只有一个相关条件。wait方法添加一个线程到等待集中，notifyAll/notify方法解除等待线程的阻塞状态。wait(),notifyAll(),notify()方法是Object类的final方法，await(),signalAll(),signal()方法是Condition类的方法。两者等价。</li>
<li>每个对象有一个内部锁，该锁有一个内部条件。</li>
<li><p>将静态方法声明为synchonized也是可以的。</p>

<pre><code>  class Print implements Runnable{

      @Override
      public synchronized void run() {
           // TODO Auto-generated method stub
           for (int i = 0; i &lt;30; i++) {
               System.out.print(i+" ");
           }
           System.out.println();
      }

  }
  public class SynchonizedTest {
      public static void main(String[] args) {
           Print print=new Print();
           for (int i = 0; i &lt; 5; i++) {
               Thread thread=new Thread(print);
               thread.start();
           }
      }
  }
</code></pre></li>
<li><p>同步阻塞：</p>

<ul>
<li><p>如上所述，每个Java对象都有一个内部锁。线程可以通过调用synchonized声明的同步方法来获取这个锁。还有一个机制可以获得内部锁，通过进入一个同步阻塞。当线程进入如下形式的阻塞：</p>

<pre><code>  Object obj=new Object();
  synchonized(obj){
       临界区
  }
</code></pre>

<ul>
<li>该线程就获得obj的内部锁。在此，obj对象被创建仅仅是用来使用使用每个Java对象持有的锁。</li>
<li>这种通过使用一个对象的锁来实现额外的原子操作，实际上被称为客户端锁定。</li>
</ul>
</li>
</ul>
</li>
<li><p>Volatile关键字</p>

<ul>
<li> 原子性可以应用于除double,long之外的基本类型上的简单操作（读取，写入）。</li>
<li><p>volatile关键字为实例域的同步访问提供了一种免锁机制。可以使得多线程安全地读取一个域。但是Volatile关键字不能提供原子性。</p>

<pre><code>  private volatile int i;
  pbulic void change(){ i=i++};//i++分为两个步骤，不一定能保证原子性
</code></pre></li>
<li><p>如果将一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的读操作都可以看到这个修改。因为volatile域会立即被写入到主存中，读操作就发生在主存中。</p></li>
</ul>
</li>
<li><p>原子性：</p>

<ul>
<li>如果对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变量声明为volatile.</li>
<li><p>java.util.concurrent.atomic包中有很多类来保证其他操作的原子性。AtomicInterge,AtomicLong等类。</p>

<pre><code>  public final long incrementAndGet()
  以原子方式将当前值加 1。

  public final long decrementAndGet()
  以原子方式将当前值减 1。

  public final long getAndAdd(long delta)
  以原子方式将给定值添加到当前值。

  public final long getAndSet(long newValue)
  以原子方式设置为给定值，并返回旧值。

  public final boolean compareAndSet(long expect,
                                    long update)
  如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。
</code></pre></li>
</ul>
</li>
</ul>


<h3>ThreadLocal：</h3>

<ul>
<li>防止共享资源产生冲突的另种方法是根除对变量的共享。线程本地存储可以为使用相同变量的每个不同线程创建不同的存储，即ThreadLocal辅助类为各个线程提供各自的实例。因此，如果你有5个线程都要使用变量x，那么本地线程存储就会生成5个用于x的不同的存储块。主要是，它们可以使你将线程与状态关联起来。</li>
<li>ThreadLocal对象通常当做静态域存储，在创建ThreadLocal时，你只能通过get(),set()方法来访问对象的内容，其中，set()会将参数插入到为其线程存储的对象中，并返回存储中原有的对象。get()方法将返回其与线程相关的对象的副本。</li>
<li>ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。</li>
<li><p>ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>

<pre><code>      public class ThreadLocal&lt;T&gt; extends Object
      该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。     

      例如，以下类生成对每个线程唯一的局部标识符。线程 ID 是在第一次调用 UniqueThreadIdGenerator.getCurrentThreadId() 时分配的，在后续调用中不会更改。

      import java.util.concurrent.atomic.AtomicInteger;
      public class UniqueThreadIdGenerator {
          private static final AtomicInteger uniqueId = new AtomicInteger(0);
          private static final ThreadLocal &lt; Integer &gt; uniqueNum =
              new ThreadLocal &lt; Integer &gt; () {
                  @Override protected Integer initialValue() {
                      return uniqueId.getAndIncrement();
              }
          };
          public static int getCurrentThreadId() {
              return uniqueId.get();
          }
      } // UniqueThreadIdGenerator
      每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用

      public ThreadLocal()
      创建一个线程本地变量。

      protected T initialValue()
      返回此线程局部变量的当前线程的“初始值”。线程第一次使用 get() 方法访问变量时将调用此方法，但如果线程之前调用了 set(T) 方法，则不会对该线程再调用 initialValue 方法。通常，此方法对每个线程最多调用一次，但如果在调用 get() 后又调用了 remove()，则可能再次调用此方法。

      public T get()
      返回此线程局部变量的当前线程副本中的值。如果变量没有用于当前线程的值，则先将其初始化为调用 initialValue() 方法返回的值。

      public void set(T value)将此线程局部变量的当前线程副本中的值设置为指定值。大部分子类不需要重写此方法，它们只依靠 initialValue() 方法来设置线程局部变量的值。

      public void remove()
      移除此线程局部变量当前线程的值。如果此线程局部变量随后被当前线程读取，且这期间当前线程没有设置其值，则将调用其 initialValue() 方法重新初始化其值。这将导致在当前线程多次调用 initialValue 方法。
</code></pre></li>
</ul>


<h3>阻塞队列：</h3>

<ul>
<li>阻塞队里与普通的队列的区别在于，普通队列不会对当前线程产生阻塞，在面对类似消费者-生产者模型时，就必须额外的实现同步策略以及线程间唤醒策略。使用阻塞队列，就会对当前线程产生阻塞，当队列是空时，从队列中获取元素的操作将会被阻塞，当队列是满时，往队列里添加元素的操作也会被阻塞。</li>
<li>在协调多个线程之间的合作时，阻塞队列是一种有用的工具。工作者线程可以周期性地将中间结果存储在阻塞队列中，其他的工作者线程移出中间结果并进一步修改。队列会自动地负载均衡。</li>
<li>使用阻塞队列不需要显式地声明线程的同步。</li>
<li><p>当试图向队列添加元素而队列已满，或者想从队列移除元素而队列为空时，阻塞队列会导致线程阻塞。如果第一个线程集运行的比第二个慢，第二个线程集会在等待结果时阻塞；如果第一个线程集运行的快，它会等待第二个线程集赶上来。</p>

<pre><code>  public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt;
  BlockingQueue 实现主要用于生产者-使用者队列，但它另外还支持 Collection 接口。因此，举例来说，使用 remove(x) 从队列中移除任意一个元素是有可能的。然而，这种操作通常不 会有效执行，只能有计划地偶尔使用，比如在取消排队信息时。
  BlockingQueue 实现是线程安全的。所有排队方法都可以使用内部锁或其他形式的并发控制来自动达到它们的目的。然而，大量的 Collection 操作（addAll、containsAll、retainAll 和 removeAll）没有 必要自动执行，除非在实现中特别说明。因此，举例来说，在只添加了 c 中的一些元素后，addAll(c) 有可能失败（抛出一个异常）。
  以下是基于典型的生产者-使用者场景的一个用例。注意，BlockingQueue 可以安全地与多个生产者和多个使用者一起使用。

  class Producer implements Runnable {
    private final BlockingQueue queue;
    Producer(BlockingQueue q) { queue = q; }
    public void run() {
      try {
        while(true) { queue.put(produce()); }
      } catch (InterruptedException ex) { ... handle ...}
    }
    Object produce() { ... }
  }

  class Consumer implements Runnable {
    private final BlockingQueue queue;
    Consumer(BlockingQueue q) { queue = q; }
    public void run() {
      try {
        while(true) { consume(queue.take()); }
      } catch (InterruptedException ex) { ... handle ...}
    }
    void consume(Object x) { ... }
  }

  class Setup {
    void main() {
      BlockingQueue q = new SomeQueueImplementation();
      Producer p = new Producer(q);
      Consumer c1 = new Consumer(q);
      Consumer c2 = new Consumer(q);
      new Thread(p).start();
      new Thread(c1).start();
      new Thread(c2).start();
    }
  }
</code></pre></li>
<li><p>常用阻塞队列的方法：</p></li>
</ul>


<p>抛出异常 特殊值 阻塞 超时 插入
add(E e)
offer(E e)
put(E e)
offer(e,time,unit)
移除
remove()
poll()
take()
poll(time,unit)
检查
element()
peek()</p>

<ul>
<li><p>阻塞队列的实现类：</p>

<ul>
<li>ArrayBlockingQueue<E>(int capacity):带指定容量的阻塞队列，用循环数组实现</li>
<li>LinkedBlockingQueue<E>():无上限的阻塞队列，用链表实现</li>
<li>LinkedBlockingDeque<E>():无上限的双向队列，用链表实现</li>
<li>PriorityBlockingQueue<E>():无边界的阻塞队列，用堆实现。</li>
</ul>
</li>
<li><p>线程安全的集合：</p>

<ul>
<li>public class ConcurrentSkipListSet<E> extends AbstractSet<E></li>
<li>public class ConcurrentLinkedQueue<E> extends AbstractQueue<E></li>
<li>public class ConcurrentSkipListMap&lt;K,V> extends AbstractMap&lt;K,V></li>
<li><p>public class ConcurrentHashMap&lt;K,V> extends AbstractMap&lt;K,V></p>

<pre><code>  public class CopyOnWriteArrayList&lt;E&gt;  extends Object
  implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable
  ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。
  public class CopyOnWriteArraySet&lt;E&gt;  extends AbstractSet&lt;E&gt;
  implements Serializable
  对其所有操作使用内部 CopyOnWriteArrayList 的 Set。
</code></pre></li>
</ul>
</li>
<li><p>在Java的初始版本中，Vector与HashTable类就提供了线程安全的动态数组与散列表的实现。现在这些类都弃用了，取而代之的是ArrayList与HashMap，而这些类不是线程安全的。不过任何集合类都可以使用同步包装器变成线程安全的。</p></li>
<li><p>Collections:</p>

<pre><code>  public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)
  返回指定 collection 支持的同步（线程安全的）collection。为了保证按顺序访问，必须通过返回的 collection 完成所有对底层实现 collection 的访问

  public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)
  返回指定 set 支持的同步（线程安全的）set。为了保证按顺序访问，必须通过返回的 set 完成对所有底层实现 set 的访问。

  public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)
  返回指定列表支持的同步（线程安全的）列表。为了保证按顺序访问，必须通过返回的列表完成所有对底层实现列表的访问。

  public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)
  返回由指定映射支持的同步（线程安全的）映射。为了保证按顺序访问，必须通过返回的映射完成所有对底层实现映射的访问。
</code></pre></li>
<li><p>返回集合的方法都使用锁加以保护，提供了线程安全访问。</p></li>
<li>不过最好使用java.util.concurrent包中定义的集合，而不是同步包装器中的。</li>
<li>如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait、1.5中的condition.await、以及可中断的通道上的 I/O 操作方法后可进入阻塞状态），则在线程在检查中断标识时如果发现中断标示为true（即线程在此时调用interrupt()方法），则会在这些阻塞方法（sleep、join、wait、1.5中的condition.await及可中断的通道上的 I/O 操作方法）调用处抛出InterruptedException异常，并且在抛出异常后立即将线程的中断标别位清除，即重新设置为false。抛出异常是为了线程从阻塞状态醒过来，并在结束线程前让程序员有足够的时间来处理中断请求。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring整合MyBatis框架]]></title>
    <link href="http://ttazk.github.io/blog/2017/03/21/spring_mybatis/"/>
    <updated>2017-03-21T16:21:24+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/03/21/spring_mybatis</id>
    <content type="html"><![CDATA[<ul>
<li><p>使用MyBatis，面对的是纯粹的Java对象，类似于Hbernate。但是对于具体的数据库操作，Hibernate会自动生成SQL语句，MyBatis 则要求自己自己编写SQL语句。</p></li>
<li><p>每一个MyBatis应用都是以一个SQLSessionFactory对象的实例为核心MyBatis可以拥有多个SQL映射文件，并通过一个配置文件对这些SQL映射文件进行装配，同时在该文件中定义一些控制属性信息。
如下：</p></li>
</ul>


<!--more-->


<p><strong>myBatisConfig.xml</strong></br></p>

<pre><code>    &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
    &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
    &lt;configuration&gt;
         &lt;!--提供框架运行的属性信息  --&gt;
        &lt;settings&gt;
            &lt;setting name="lazyLoadingEnabled" value="false"/&gt;
        &lt;/settings&gt;

        &lt;!--指定类的别名,可以在映射文件中使用类的别名  --&gt;
        &lt;typeAliases&gt;
            &lt;typeAlias alias="Information" type="spring_mybatis.Information"/&gt;
        &lt;/typeAliases&gt;

        &lt;!--指定映射文件  --&gt;
        &lt;mappers&gt;
            &lt;mapper resource="spring_mybatis/InformationMapper.xml"/&gt;
        &lt;/mappers&gt;
    &lt;/configuration&gt;
</code></pre>

<ul>
<li><p>其中<mappers>属性指定了映射文件的位置。映射文件的配置如下：</br>
<strong>InformationMapper.xml</strong></p>

<pre><code>  &lt;?xml version="1.0" encoding="UTF-8" ?&gt; 
  &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
  &lt;!--命名空间要与调用接口的名称相同  --&gt;
  &lt;mapper namespace="spring_mybatis.InformationDAO"&gt;
  &lt;!--下面定义映射语句项，映射语句中的id要与映射接口方法的名称相同  --&gt;
      &lt;select id="getInformation" resultType="Information" parameterType="String"&gt;
          select * from information where name=#{name}
          &lt;!-- #{name}为对应接口方法的入参 --&gt;
      &lt;/select&gt;

      &lt;insert id="addInformation" parameterType="Information"&gt;
          insert into information values(#{name},#{sex},#{address},#{phone})
          &lt;!--#{name},#{sex},#{address},#{phone}对应接口方法参数Information的属性  --&gt;
      &lt;/insert&gt;

      &lt;update id="updateInformation" parameterType="Information"&gt;
          update information set
          name=#{name},sex=#{sex},address=#{address}，phone=#{phone}
          &lt;!--#{name},#{sex},#{address},#{phone}对应接口方法参数Information的属性  --&gt;
      &lt;/update&gt;
  &lt;/mapper&gt;
</code></pre></li>
<li><p>在映射文件中定义了对实体类Information进行数据操作时所用的SQL语句。
在该文件中定义了 select insert及update映射项语句，映射项语句的id唯一，resultType代表了语句的返回值类型，parameterType代表传入参数的类型，可以是全限定类名，也可以是在MyBatis中指定的类的别名；如果参数为String/基础数据类型，可以直接用int,String指定。映射项通过#{xxx}绑定传入参数对象的属性。</p></li>
<li><p>MyBatis提供了一种可以将SQL映射文件中的映射项，通过名称匹配接口进行调用：定义一个映射接口，接口的全限定名称与映射文件中的命名空间相同，接口方法名称与映射项的id相同。调用接口的方法即可以访问对应的映射项。
如：</br>
<strong>InformationDAO接口</strong></br></p>

<pre><code>  package spring_mybatis;
  //定义映射接口
  //接口的名称与映射命名空间相同
  //方法名称与映射项的id相同
  //可以通过接口名称及方法名称调用映射文件的映射项
  public interface InformationDAO {
      public Information getInformation(String name );
      public void addInformation(Information information);
      public void updateInformation(Information information);

  }
</code></pre>

<h3>定义好了接口，如何使用其中的方法呢？</h3>

<p>两种方式：</br>
<strong>1：通过SqlSessionTemplate获取接口的实例。</strong></p></li>
</ul>


<p>DAO类，用于调用映射项，进行数据操作：</p>

<pre><code>    package spring_mybatis;
    import org.mybatis.spring.SqlSessionTemplate;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Repository;

    @Repository("DAO")
    public class DAO {
        @Autowired//注入SqlSessionTemplate
        SqlSessionTemplate sessionTemplate;

        public SqlSessionTemplate getSessionTemplate() {
            return sessionTemplate;
        }

        public void setSessionTemplate(SqlSessionTemplate sessionTemplate) {
            this.sessionTemplate = sessionTemplate;
        }

        public Information getInformation_1(String name ){
            //调用sessionTemplate.getMapper方法返回接口实例，从而可以执行映射项
            InformationDAO informationDAO=sessionTemplate.getMapper(InformationDAO.class);
            return informationDAO.getInformation(name);
        }

        public void addInformation_1(Information information){
            //调用sessionTemplate.getMapper方法返回接口实例，从而可以执行映射项
            InformationDAO informationDAO=sessionTemplate.getMapper(InformationDAO.class);
            informationDAO.addInformation(information);
        }

        public void updateInformation(Information information){
            //调用sessionTemplate.getMapper方法返回接口实例，从而可以执行映射项
            InformationDAO informationDAO=sessionTemplate.getMapper(InformationDAO.class);
            informationDAO.updateInformation(information);
        }
    }
</code></pre>

<ul>
<li><p><strong>2：使用类型转换器MapperScannerConfigurer，可以将映射接口直接转换成对应的Bean，</strong></br>
PS：使用这种方法时，便不需要使用sqlSessionTemplate进行操作。</p>

<pre><code>  &lt; !--配置转换器，将映射接口转换成实例，从而进行数据库访问  --&gt; 
  &lt;bean class="org.spring.mapper.MapperScannerConfigure"
  p:sqlSessionFactory-ref="sqlSessionFactory"
  p:basePackage="spring_mybatis"/&gt;
</code></pre></li>
</ul>


<p>然后可以直接在类中注入对应的接口对象，并调用方法使用映射文件中的映射项。
如：</br><strong>DAO_1类</strong></p>

<pre><code>    package spring_mybatis;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Repository;

    @Repository("dao_1")
    public class DAO_1 {
        @Autowired
        InformationDAO informationDAO;

        public void getInformation(String name ){
            informationDAO.getInformation(name);
        }
        public void addInformation(Information information){
            informationDAO.addInformation(information);

        }
        public void updateInformation(Information information){
            informationDAO.updateInformation(information);
        }
    }
</code></pre>

<ul>
<li><p>以上是使用MyBatis访问数据库操作的配置，现在将Spring与MyBatis进行整合。
整合过程在Spring的配置文件中完成。
如下：</br>
<strong>Spring-MyBatis.xml</strong></p>

<pre><code>  &lt; context:component-scan base-package="spring_mybatis"/&gt;
  &lt;!--引用属性文件  --&gt;
  &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"
  p:location="classpath:jdbc.properties"
  p:fileEncoding="utf-8"/&gt;
  &lt;!--配置数据源,DBCP数据源  --&gt;
  &lt;bean id="datasource_1" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"
  p:driverClassName="${driverClassName}"
  p:url="${url}"
  p:username="${username}"
  p:password="${password}"/&gt;
  &lt;!--配置数据源，Spring自身提供  --&gt;
  &lt;bean id="datasource_2" class="org.springframework.jdbc.datasource.DriverManagerDataSource"
  p:driverClassName="com.mysql.jdbc.Driver"
  p:url="jdbc:mysql://localhost:3306/my_student?useSSL=false"
  p:username="root"
  p:password="000000"/&gt;

  &lt;!--声明sqlsessionfactory  --&gt;
  &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;
  &lt;property name="dataSource" ref="datasource_2"&gt;&lt;/property&gt;
  &lt;property name="configLocation" value="myBatisConfig.xml"&gt;&lt;/property&gt;
  &lt;/bean&gt;
  &lt;!--引用mybatis的配置文件  --&gt;

   &lt;!--定义SqlSessionTemplate,可以用来直接访问数据库  --&gt;
  &lt;bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate"&gt;
     &lt; constructor-arg ref="sqlSessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;!-- &lt;bean id="DAO" class="spring_mybatis.DAO"
  p:sessionTemplate-ref="sqlSessionTemplate"/&gt;  --&gt; 

  &lt;!--配置转换器，将映射接口转换成实例，从而进行数据库访问  --&gt;
  &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"
  p:sqlSessionFactory-ref="sqlSessionFactory"
  p:basePackage="spring_mybatis"/&gt;

  &lt;bean id="information" class="spring_mybatis.Information"
  p:name="zt"
  p:sex="woman"
  p:address="huan"
  p:phone="521155"/&gt;
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[泛型程序设计]]></title>
    <link href="http://ttazk.github.io/blog/2017/03/19/generic/"/>
    <updated>2017-03-19T10:38:05+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/03/19/generic</id>
    <content type="html"><![CDATA[<ul>
<li>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。</li>
<li><p>在增加泛型之前，泛型程序是利用继承实现的。</p>

<pre><code>  public class ArrayList{
  private Object[] data;
   ...
  public Object get(int i){}
  public void add(Object o){}
  }
</code></pre></li>
<li>这种方法有两个问题：</li>
<li>1.当获取一个值时必须进行强制类型转换。</li>
<li><p>2.没有错误检查，可以向数组列表中添加任何类的对象。</br></br></p></li>
<li><p>泛型提供了一个更好的解决方法：类型参数，用来指示存储元素的类型。如：ArrayList<String> arl=new ArrayList&lt;>();   (jdk1.7之后，构造函数中可以省略泛型类型)。</p>

<ul>
<li>对此编译器可以进行检查，避免插入错误的类型，同时在获取对象时不需要进行强制类型转换。</li>
<li><p>一个泛型类(generic class)就是具有一个或多个类型变量的类。
      public class Pair<T> {
      private T first;
      private T second;</p>

<pre><code>  public Pair(){
       this.first=null;
       this.second=null;
  }
  public Pair(T first,T second){
       this.first=first;
       this.second=second;
  }

  public T getFirst(){
       return first;
  }
  public T getSecond(){
       return second;
  }
  public void setFirst(T first){
       this.first=first;
  }
  public void setSecond(T second){
       this.second=second;
      }
  }
</code></pre></li>
<li>如上所示，Pair类引入了一个类型变量T,用&lt;>括起来，并放在类名之后。泛型类可以有多个类型变量。例如可以定义Pair类，两个域分别使用不同的类型变量：public class Pair&lt;T,V>{&hellip;}.</li>
<li>类中定义的泛型变量指定方法的返回类型，以及域和局部变量的类型。（一般来说，K,V分别表示关键字与值的类型，T表示任意类型）。</li>
<li>用具体的类型替换类型变量就可以实例化泛型类型，如Pair<String>。换句话来说，泛型类可以看做普通类的工厂。
</br></br></li>
</ul>
</li>
</ul>


<!--more-->


<h3>* 泛型方法</h3>

<ul>
<li><p>可以在一个普通类中定义一个带有类型参数的简单方法。</p>

<pre><code>public class Generic {
public static &lt;T&gt; void print(T t){
System.out.println(t);
    }
}
</code></pre></li>
<li><p>注意：类型变量放在修饰符的后面，返回类型的前面。</p></li>
<li>泛型方法可以定义在普通类中，也可以定义在泛型类中。</li>
<li><p>当调用一个泛型方法时，可以在方法名前的&lt;>中放入具体的类型，也可以省略&lt;>类型参数。</p>

<pre><code>Generic.print("no");
Generic.&lt;String&gt;print("nothing");
</code></pre></li>
</ul>


<h3>* 类型变量的限定</h3>

<ul>
<li><p>有时，需要对类或泛型方法中的类型变量加以限定。</p>

<pre><code>      public static &lt;T extends Comparable&gt; void sys(T t){
       System.out.println(t);
      }
</code></pre></li>
<li>可以对泛型变量T进行限定，将其限定为实现了Comparable接口的类。</li>
<li><T extends BoundingType> 表示：T应该是绑定类型的子类型。T和绑定类型可以是类，也可以是接口。</li>
<li>一个类型变量或通配符可以有多个限定，如：T extends Comaprable &amp; Serializable</li>
<li>在Java的继承中，可以根据需要有多个接口的父类型，但是限定中至多只能有一个类，且必须是限定列表中的第一个。</li>
</ul>


<h3>* 类型擦除</h3>

<ul>
<li>在虚拟机中，没有泛型类型对象&mdash;-所有的对象都属于普通类。</li>
<li>无论何时定义一个泛型类型，都会自动提供一个相应的原始类型(raw type)。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型（没有限定类型就用Object）。</li>
<li><p>例如，Pair<T>的原始类型为：
      public class Pair{
      private Object first;
      private Object second;</p>

<pre><code>  public Pair(){
       this.first=null;
       this.second=null;
  }
  public Pair(Object first,Object second){
       this.first=first;
       this.second=second;
  }

  public Object getFirst(){
       return first;
  }
  public Object getSecond(){
       return second;
  }
  public void setFirst(Object first){
       this.first=first;
  }
  public void setSecond(Object second){
       this.second=second;
  }
  }
</code></pre></li>
<li><p>在程序中可以包含不同类型的Pair，如Pair<String>,Pair<LocalDate>，但是类型擦除后就变成了原始的Pair类型了。</p></li>
<li>原始类型用第一个限定类型来替换参数变量，如果没有给定限定类型，就用Object替换。</li>
<li>为了提高效率，应该将标签接口(没有方法的接口)放在列表的末尾。</li>
</ul>


<h3>* 翻译泛型表达式</h3>

<ul>
<li><p>当程序调用泛型方法时，如果擦除返回类型，编译器则插入强制类型转换。</p>

<pre><code>  Pair&lt;Employee&gt; p=new Pair&lt;&gt;();
  Employee e=p.getFirst();//先对原始方法调用Pair.getFirst();再将返回的Object类型强制转换成Employee类型。
</code></pre></li>
<li>关于java泛型转换的事实：

<ul>
<li>虚拟机中没有泛型，只有普通的类与方法。</li>
<li>所有的参数类型都用它们的限定类型进行替换。</li>
<li>为了保持类型安全，必要时插入强制类型转换。</li>
<li>桥方法被合成来保持多态。</li>
</ul>
</li>
</ul>


<h3>* 约束与局限性(大多数限制都是由类型擦除引起的)</h3>

<h5>* 不能用基本类型实例化类型参数</h5>

<ul>
<li>因此没有Pair<double>，只有Pair<Double>。原因是类型擦除，擦除之后，Pair类含有Object域，而Object域不能存储基本类型。

<h5>* 运行时类型查询只适用于原始类型</h5></li>
<li><p>虚拟机中的对象总有一个特定的非泛型类型，因此，所有的类型查询只产生原始类型。</p>

<pre><code>  Pair&lt;String&gt; pair=new Pair&lt;String&gt;();
  if (pair instanceof Pair&lt;String&gt;) {    //error
     System.out.println(true);
  } 
  if (pair instanceof Pair) {         //true
  System.out.println(true);
  }
</code></pre></li>
<li><p>同样，getClass()方法返回的是原始类型。</p>

<pre><code>  Pair&lt;String&gt; pair=new Pair&lt;String&gt;();
  Pair&lt;Double&gt; pair2=new Pair&lt;Double&gt;();
  if (pair.getClass()==pair2.getClass()) {
  System.out.println(true);
  }         //输出为true
</code></pre></li>
</ul>


<h5>* 不能创建泛型数组</h5>

<pre><code>Pair&lt;String&gt;[] pairs=new Pair&lt;String&gt;[10];  //error
</code></pre>

<ul>
<li>只是不能创建这些数组，但是声明类型Pair<String>[] 的变量仍是合法的，只能不过不能初始化。</li>
<li>原因也是类型擦除。</li>
</ul>


<h5>* 不能实例化类型变量</h5>

<ul>
<li>即不能使用new T(&hellip;),new T[&hellip;],或T.class这样的表达式中的类型变量。

<h5>* 不能创建类型变量数组</h5>

  private T[] ts=new T[2];   //error

<h5>* 不能在静态域或静态方法中引用类型变量</h5>

  private static T t;   //error
  public static T print(){}   //error
</br>

<h3>* 泛型类型的继承规则</h3></li>
<li>考虑一个类与一个子类，如Object,String，那么Pair<String>是Pair<Object>的子类吗？不是</li>
<li>无论T和V有什么关系，通常Pair<V>,Pair<T>是没有任何关系的。
Pair<Object>[] pair3=new Pair<String>[10];  //error</li>
<li>注意泛型与Java数组之间的区别：可以将子类数组的变量赋给父类数组变量。
Object[] objects=new String[10];</li>
<li>永远可以将参数化类型转换为一个原始类型。
Pair pair3=new Pair<String>();</li>
<li>泛型类可以扩展或者实现其他泛型类，这点而言与普通类没有区别</li>
<li>ArrayList<T>类实现了List<T>接口。</li>
<li>意味着ArrayList<String>可以转换为List<String></li>
</ul>


<h3>* 通配符类型</h3>

<ul>
<li>通配符类型中，允许类型参数变化。如  Pair&lt;? extends Comparable></li>
<li><p>类型Pair<String>是Pair&lt;? extends Object>的子类型。                                                                                        &lt;&mdash;Pair<Object>
Pair(原始类型)&lt;&mdash;Pair&lt;? extends Object><---
                  <---Pair<String></p></li>
<li><p>通配符的超类型限定</p></li>
<li>可以指定一个父类型：  ? super Manager</li>
<li>带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。(P332)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bean的配置及注入]]></title>
    <link href="http://ttazk.github.io/blog/2017/02/21/bean_config/"/>
    <updated>2017-02-21T17:03:16+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/02/21/bean_config</id>
    <content type="html"><![CDATA[<h4>Bean的配置方式有三种：xml配置，基于注解配置，基于java类配置</h4>

<ul>
<li>Bean的配置信息包含了bean的实现及各个bean之间的依赖关系，Spring容器将各种形式的Bean的配置信息进行读取，并在Spring容器内部建立Bean定义注册表，然后根据注册表对Bean进行加载，实例化，并建立Bean之间的依赖关系，最后将准备就绪的Bean放入Bean缓冲池中，等待外部程序调用。</li>
</ul>


<h3>Bean配置方式详解：</h3>

<!--more-->


<h3>1，基于XML文档配置</h3>

<h5>XML文档介绍</h5>

<p>Spring2.0之后，XML文档采取Schema形式进行配置，使得各种类型拥有自己的命名空间，如beans，mvc,aop</p>

<ul>
<li>命名空间的作用：

<ul>
<li>a.默认命名空间：没有空间名，用于bean的定义，文档中无命名空间前缀的标签都属于默认命名空间，如<beans/>,<bean/></li>
<li>b.自定义命名空间：如aop命名空间，</li>
<li>c.xsi命名空间：用于为文档中的命名空间指定对应的Schema文件</li>
</ul>
</li>
<li>指定命名空间Schema文件地址有两个作用：

<ul>
<li>1，XML解析器可以获得Schema文件并对文档进行验证</li>
<li>2，IDE可以用其对文档编辑提供诱导作用

<h6>Bean的基本配置</h6></li>
</ul>
</li>
<li>&lt; bean id=&ldquo; &rdquo; class=&ldquo;  &rdquo;>
</br> class属性制定了Bean对应的实现类.</br>
Spring容器中的一个Bean即对应配置文件中的一个<bean/>
Spring容器的getBean(String id)方法用于从Spring容器中获取对应的Bean，是外部程序与Spring容器进行交流的桥梁</li>
<li>Bean的命名</br>
id在Spring容器中唯一，作为Bean的名称
name属性也可以用来指定Bean的名字，可以为多个
Spring配置文件中不允许出现两个相同id的Bean，但是可以有相同name,根据name属性对bean进行引用时，如果name相同，则返回后声明的bean对象，因为后面把前面的覆盖了</br>
如果id，name属性均未指定，如<bean class="zk.Controller"/>则自动将全限定名称作为Bean的名称，同样的方法进行引用</li>
</ul>


<p></br>
<strong>2 ,基于注解的配置</strong></br></p>

<ul>
<li><p>在基于xml文档配置bean时，Bean的定义与实现是分开的
而采用注解配置时，Bean的定义通过在Bean的实现类上标注注解实现。</p>

<h6>使用注解定义Bean</h6>

<p>  @ Component 用于任何层次
  @ Service 用于对Service实现类进行标注
  @ Controller  用于对Controller实现类标注
  @ Repository 用于对Dao实现类进行标注</p></li>
<li><p>使用这四个注解标注POJO 可以使类被Spring识别，并将其转换成Bean。
作用等同于<bean id="" class=""/>,还可以通过注解的value属性指定Bean的名称。</p></li>
<li>使用&lt;context:compoment-scan base-package=&ldquo;&rdquo;/>Spring会扫描指定的包，并识别其中的注解信息。
</br></br></li>
<li><strong>装配Bean</strong>

<ul>
<li>对Bean 属性或者方法参数的自动装配，仅限于该属性或参数的类型是对象，Spring会在容器中查找匹配的Ban进行注入，对于基本数据类型，不能实现自动装配，仍需要通过xml文档进行依赖注入</li>
<li>@Autowired 实现bean的依赖注入，默认为按类型匹配</li>
<li>@Autowired（required=false）;如果找不到符合要求的Bean不会抛出异常</li>
<li>@Qulifier（““）用于指定注入的名称</li>
<li>@Autowired既可以标注属性，也可以对方法及方法的参数进行标注。</li>
<li>如果对类中集合类型（List，Set，Map）的属性或方法的参数进行@Autowired标注，Spring会将容器中所有类型匹配的Bean注入进来。</li>
<li>对于@Autowired声明的数组、集合类型，spring并不是根据beanName去找容器中对应的bean，而是把容器中所有类型与集合（数组）中元素类型相同的bean构造出一个对应集合，注入到目标bean中。</li>
<li>注入集合类型不要使用@Autowired，而使用@Resource注解。同时Spring官方也是不推荐使用@Autowired的。

<h3>依赖注入</h3></li>
</ul>
</li>
<li>Spring提供两种依赖注入的方式：属性注入和构造函数注入
还支持工厂方法注入的方式（不常使用）

<ol>
<li>属性注入

<ul>
<li>通过setXXX（）函数注入Bean的属性及依赖对象
属性注入要求Bean提供一个默认的构造函数及要注入属性的SetXXX（）方法</li>
</ul>
</li>
</ol>


<p>  Ps: Spring 只要求是否有setXXX（）方法，对于是否有相应的属性不做要求
  如：
  Public test{
      Int a;//对于属性a无要求，但是一般会添加
      //但是必须有setA()方法
      Public void setA(int a){
          This .a=a;
      }
  }</p>

<p>  Spring会先调用Bean的默认的构造函数实例化Bean对象，然后通过反射的方式调用Bean的setter方法注入属性值。</p>

<ol>
<li>构造函数注入
保证Bean的一些重要的属性在实例化之后就能使用
使用构造函数注入的前提是Bean必须提供带参数的构造函数</li>
</ol>


<p>  Spring的配置文件采用元素标签与顺序无关的原则，即在一个上下文配置文件中，两个标签的位置不同不会影响使用。
  但是在web.xml文档中，标签的顺序是有影响的。</p>

<p>  构造函数注入有以下几种方式：</p>

<ol type="a">
<li> 按照类型匹配参数</li>
<li> 按照索引匹配参数</li>
<li> 类型及索引联合使用匹配参数</li>
<li><p> 通过自身类型反射匹配参数</p></li>
<li><p>工厂方法注入
<bean id="" class="工厂方法类" factory-method="工厂类方法"/></p></li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运输层]]></title>
    <link href="http://ttazk.github.io/blog/2017/02/14/transmission/"/>
    <updated>2017-02-14T10:39:03+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/02/14/transmission</id>
    <content type="html"><![CDATA[<ul>
<li>运输层用于向它上面的应用层提供服务，它属于面向通信的最高层，同时也是用户功能的最低层。当网络的边缘部分的两个主机进行通信时，只有主机的协议栈中才有运输层，而网络核心部分在转发分组时都只用到下三层的功能。</li>
<li>两个主机进行通信，也就是两个主机中的应用进程进行通信，通信的真正端点是主机中的进程。</li>
<li>运输层能够“复用”与“分用”：复用是指发送方不同的应用进程都可以使用同一个运输层协议传输数据，分用是指接收方的运输层能够把接收的数据正确地交付到目的应用进程中。</li>
<li>网络层为主机之间提供逻辑通信，运输层为应用进程间提供逻辑通信。运输层向高层用户屏蔽了下面网络的核心细节。</li>
<li><p>运输层包括两个主要的协议：TCP（传输控制协议），UDP（用户数据报协议）。传输的数据单元分别为：TCP报文段与UDP用户数据报。</p></li>
<li><p>UDP在传输数据之前不需要建立连接。接收方在收到报文后也不需要给出任何确认。</p></li>
<li>TCP采用面向连接的服务，在传输数据之前先建立连接，且TCP不支持广播或者多播服务。</li>
</ul>


<!--more-->


<h5>* 在运输层中使用端口号来将数据交付给应用层的目的进程。16位的端口号只具有本地意义，用来标识计算机应用层中的各个进程与运输层交互时的层间接口。不同的计算机中，相同的端口号是没有关联的。</h5>

<ul>
<li>由此可见，两个计算机中的进程进行通信时，不仅要知道对方的IP地址（为了找到对方的计算机），还要知道对方的端口号（找到计算机中的应用进程）。</li>
<li>端口号分为两大类：

<ul>
<li>服务器端使用的端口号：分为系统端口号（0&ndash;1023）与登记端口号（1024&ndash;49151）。</li>
<li>客户端使用的端口号：又称为短暂端口号，这类端口号仅在客户进程运行时才动态选择，通信结束后，刚才使用的客户端号就不复存在，这个端口号就可以供其他客户进程以后使用。</br>  <br/>
<br><br><br><br>

<h2>* UDP主要特点是：</h2></li>
</ul>
</li>
<li>无连接的，发送数据之前不需要建立连接，减少了开销。</li>
<li>使用进最大努力交付，即不保证可靠交付。</li>
<li>UDP是面向报文的。发送方的UDP对应用程序交下来的报文，既不合并，也不拆分，而是在添加首部之后，直接交付给下层的IP层。也就是说，UDP一次交付一个完整地报文。接收方的UDP对IP层上传的报文在去除首部之后就直接上交给应用程序。</li>
<li>UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。</li>
<li>UDP支持一对多，多对多的交互通信。</li>
<li><p>UDP的首部开销小，只有8个字节。<br><br></p></li>
<li><p>UDP用户数据报有两个字段：首部与数据段。首部8个字节，由4个字段组成，每个字段的长度都是两个字节，分为：源端口，目的端口，长度，校验和。</p></li>
<li>如果接收方UDP发现收到的报文中的目的端口不正确，就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方。<br><br><br><br></li>
</ul>


<h2>* TCP的主要特点：</h2>

<ul>
<li>面向连接：在传输数据之前先建立连接，传输结束之后释放连接。</li>
<li>每个TCP连接只能有两个端点，所以TCP只能是一对一的。</li>
<li>提供可靠的交付服务：通过TCP连接传输的数据，无差错，不丢失，不重复，且按顺序到达。</li>
<li>提供全双工通信。</li>
<li>TCP面向字节流：“流”是指流入到应用进程或者从应用进程中流出的字节序列。</li>
<li><p>TCP和UDP在发送报文时采取的方式完全不同。TCP根据对方的窗口值和当前网络的拥塞程度来决定一个报文段应该包含多少个字节，UDP发送的报文长度是应用进程给的。</p></li>
<li><p>TCP连接的端点叫做套接字：即Socket=IP地址+端口号。</p>

<ul>
<li>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。同一个IP地址可以对应多个TCP连接，同一个端口号可以出现在不同的TCP连接中。</li>
<li>TCP虽然是面向字节流的，但是TCP传输的数据单元确是报文段。报文段分为首部和数据段两部分。</li>
<li>TCP报文段的首部（20个字节）格式：

<ul>
<li>源端口与目的端口：各占两个字节。</li>
<li>序号：4个字节，范围为[0,2的32次方-1]，TCP是面向字节流的。TCP连接传送的字节流中的每个字节都按照顺序编号。首部中的序号字指的是本报文段所发送的数据的第一个字节的序号。</li>
<li>确认号：4个字节，是期望收到对方的下一个报文段的第一个数据字节的序号。若确认号为n，则表明到n-1为止所有的数据都已正确收到。</li>
<li>数据偏移：4位，单位为4个字节，指的是TCP报文段的首部长度，最大为60个字节。</li>
<li>保留：6位</li>
<li><p>6个控制位：</p>

<ul>
<li>紧急（URG）：当URG=1时，表明紧急指针字段有效。</li>
<li>确认（ACK）：仅当ACK=1时，确认号字段才有效，若为0，则无效；规定，当TCP连接建立后，所有的传送报文段都必须把ACK置为1.</li>
<li>推送（PSH）</li>
<li>复位（RST）：当RST等于1时，表明TCP连接出现差错，必须释放连接，然后再重新建立连接。</li>
<li>同部位（SYN）：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是个连接请求报文段。若对方同意建立连接，则应在响应的报文中使SYN=1，ACK=1。因此，SYN=1表明这是个连接请求报文或者连接接受报文。</li>
<li>终止（FIN）：用来释放一个连接。当FIN=1时，表明报文段发送方已经将数据发送完毕，并要求释放连接。</li>
</ul>
</li>
<li><p>窗口：2个字节，指的是发送此报文段的一方的接收窗口，而不是自己的发送窗口。窗口字段表明现在允许对方发送的数据量。窗口值是经常动态变化的。</p></li>
<li>检验和：2个字节</li>
<li>紧急指针：2个字节，在URG=1时才有效，指明紧急数据的字节数。
<br><br></li>
</ul>
</li>
</ul>
</li>
<li>TCP可靠传输的实现：

<ul>
<li>TCP滑动窗口是以字节为单位的。设A为发送方，B为接收方。</li>
<li>发送窗口表示：在没有收到B的确认情况下，A可以连续把窗口内的数据都发送出去。凡是已经发送出去的数据，在未收到确认之前都必须暂时保留，以便在超时重传中使用。窗口的大小是动态变换的。</li>
<li>发送窗口中的字节分为两类：已经发送，但是尚未收到确认的字节；允许发送，但是尚未发送的字节。发送窗口的位置由前沿与后沿的位置共同确认。发送后沿有两种情况：不动（没有收到新的确认）和前移（收到了新的确认，每收到一个确认向前动一个位置），发送前沿通常是不断向前移动，但也有可能不动，对应于两种情况：没有收到新的确认，对方通知的窗口大小也不变；收到了新的确认，但是对方通知的新的窗口缩小了。</li>
<li>接收窗口B只能对按顺序收到的数据中的最高序号给出确认。对于接收到的但是未按顺序到达的字节，暂存在接收窗口中。</li>
<li>A只要超过了一段时间仍没收到确认，就认为刚才的分组丢失了，因而重传前面发送过的分组，叫做超时重传。要实现超时重传，就要在每次发送结束后设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</li>
<li>对于有种情况，A发送的数据B都按顺序接受了，并且发送了确认，但是这个确认在网络中滞留了，此时A还是会重传这些数据。
<br><br></li>
</ul>
</li>
<li>TCP的流量控制：

<ul>
<li>还是通过滑动窗口协议实现。</li>
<li>发送方的发送窗口不能超过接收方给出的接收窗口的数值。</li>
<li>TCP窗口的单位是字节，不是报文段。
<br><br></li>
</ul>
</li>
<li>TCP连接的建立：

<ul>
<li>TCP连接的建立采用客户服务器模式。主动发起连接叫做客户（A），等待连接的叫做服务器（B）。</li>
<li>B的TCP服务器进程创建传输控制块（TCB），等待客户进程的连接。服务器处于LISTEN（收听）状态。</li>
<li>A的TCP客户进程也创建传输控制块（TCB），然后向B发送请求报文段。报文段首部中的同部位SYN=1，序列号seq=x。此报文段不能携带数据，但是要消耗一个序列号。客户端处于SYN-SENT（同步已发送）状态。</li>
<li>B收到请求报文段后，如果同意连接，则向A发送确认报文段。在该报文段中，首部的SYN=1，ACK=1，确认号ack=x+1，序列号seq=y。这个报文段也不能携带数据，但是要消耗一个序列号。此时，服务器处于SYN-RCVD（同步收到）状态。</li>
<li>A收到B的确认之后，仍要发给B一个确认。确认报文段的ACK=1，确认号ack=y+1，序列号seq=x+1。此时，该报文段可以携带数据，如果不携带数据则不消耗序列号（下个报文段的序列号仍是x+1）。至此，TCP连接建立，A处于ESTABLISHED（连接建立）状态。</li>
<li>B收到确认后，也处于ESTABLISHED（连接建立）状态。</li>
<li>为什么A还要发送一次确认呢？为了防止已经失效的请求突然又传送到了B，因而产生错误。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[虚拟机类加载机制]]></title>
    <link href="http://ttazk.github.io/blog/2017/02/09/jvm2/"/>
    <updated>2017-02-09T22:55:40+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/02/09/jvm2</id>
    <content type="html"><![CDATA[<ul>
<li>类的生命周期包括：加载&ndash;>连接&ndash;>初始化&ndash;>使用&ndash;>卸载，其中连接包括，验证&ndash;>准备&ndash;>解析。</li>
<li>虚拟机把描述类的数据从Class文件中加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可被虚拟机直接使用的Java类型。</li>
<li>在Java中，类的加载，连接，初始化都是在运行期间完成的，这种策略与C++等不同，但是这也实现了Java语言的运行期动态加载与动态连接的特点。</li>
</ul>


<!--more-->


<h2>类加载的过程：</h2>

<ol>
<li>加载</li>
<li>加载是类加载的一个阶段。在加载时需要 完成以下几件事情：

<ol>
<li>通过类的全限定名称获取此类的二进制字节流</li>
<li>将这个字节流所带表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
</li>
<li>二进制字节流可以从Class文件中获取，也可以从网络中或者其他文件中获取。</li>
<li>在加载阶段完成后，虚拟机外部的二进制字节流就转换为方法区中的数据结构，然后再在内存中实例化一个java.lang.Class对象，作为程序访问方法区中这些数据类型的接口。</li>
<li>验证

<ul>
<li>为了确保Class文件中的字节流所包含的信息是符合当前虚拟机的要求。</li>
</ul>
</li>
<li>准备</li>
<li>准备阶段是正式为类变量设置初始值的阶段。这些变量所用的内存都将在方法区中分配。</li>
<li>此时仅分配类变量，不包括实例变量。实例变量会随着对象实例化一起在Java堆中分配。</li>
<li>这里说的初始值是数据的零值，null/false/0等。</li>
<li>解析</li>
<li>将常量池中的符号引用替换为直接引用。</li>
<li>初始化</li>
<li>在这个阶段，才是对类变量进行赋值操作。按照程序的主观计划去初始化类变量及其他资源。</li>
<li>初始化是执行类构造器<clinit>()方法的过程，<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作与静态语句块（static{}）中的语句合并。</li>
<li>类构造器<clinit>()方法与类的构造函数（实例构造器<init>()方法）不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。</li>
<li>由于父类的<clinit>()方法先执行，因此父类中定义的静态语句块要优先于子类的静态语句块。</li>
<li>对于类来说并不是必须的，如果类中没有类变量，也没有静态语句块，那么便不需要<clinit>()方法。</li>
<li>如果多个线程同时初始化一个类，那么只有一个线程会执行<clinit>()方法，其他线程阻塞等待。</li>
</ol>


<h2>虚拟机规范中严格定义了有且只有5中情况必须立即对类进行初始化（加载，验证，准备需要在此之前完成）</h2>

<ol>
<li>遇到new,getstatic,putstatic或者invokestatic这4条字节码指令时，如果类没有进行初始化，则需要对它进行初始化。生成这4条字节码指令的Java代码是：使用new关键字实例化对象，读取或者设置一个类的静态字段（被final修饰，已经在编译期就把结果放到常量池的静态字段除外），以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包中的方法对类进行反射调用的时候，如果类没有进行初始化，则需初始化。</li>
<li>当初始化一个类的时候（注意是类，不是对象），如果发现父类没有被初始化，则先初始化其父类。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法），虚拟机会先初始化这个主类。</li>
<li>当使用jdk1.7的动态语言支持时，如果一个方法解析后句柄对应的类没有初始化，则先初始化。</li>
</ol>


<p>//当调用类中普通的静态变量时（没有被final修饰的），会对类进行初始化</p>

<pre><code>public class InvokeStatic {
public static int a=1;
static{
     System.out.println("the class has been init !");
}
public static void main(String[] args) {
     // TODO Auto-generated method stub
     int i=InvokeStatic.a;
}
}

输出结果为：
the class has been init !
</code></pre>

<p>//当初始化一个类的时候，如果发现父类还没有初始化，便先将其父类进行初始化</p>

<pre><code>class Super{
static{
     System.out.println("The super has been init !");
}
}
public class InvokeChildStatic extends Super {
static int a=10;
static{
     System.out.println("The child has been init !");
}
public static void main(String[] args) {
     // TODO Auto-generated method stub
     System.out.println(InvokeChildStatic.a);
}
}
输出结果为：
The super has been init !
The child has been init !
10
</code></pre>

<h2>上面介绍的是对类进行加载及初始化，下面要介绍的是对象的创建：</h2>

<ul>
<li>当虚拟机遇到一个new指令时，首先检查这个指令的参数能否在常量池中定位一个符号引用，并且检查这个符号引用代表的类是否被加载，如果没有，便先加载这个类。</li>
<li>类加载完成之后，虚拟机为新生对象在Java堆中分配内存（对象所需的内存大小在类加载完成后便确定）。</li>
<li>接下来，虚拟机将分配的内存空间都初始化为零值（保证了实例字段在Java代码中可以不赋初值就能使用）。</li>
<li>执行实例构造器<init>()方法，把对象按照程序员的意愿初始化。这样一个对象便创建完成。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[虚拟机内存分配]]></title>
    <link href="http://ttazk.github.io/blog/2017/02/08/jvm1/"/>
    <updated>2017-02-08T15:51:45+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/02/08/jvm1</id>
    <content type="html"><![CDATA[<p>Java运行时数据区分为：方法区，堆，虚拟机栈，本地方法栈，程序计数器。其中，方法区与堆为所有线程共享；虚拟机栈，本地方法栈与程序计数器为线程私有。</p>

<h2>程序计数器：</h2>

<ol>
<li>所占内存空间比较小，可以看做当前线程所执行字节码的行号指数器。字节码解释器在工作时就是通过这个计数器的值来选取下一条需要执行的字节码指令。</li>
<li>每个线程都有一个独立的程序计数器，各个线程的程序计数器互不影响，独立存储，为“线程私有”。</li>
<li>如果线程正在执行的是Java方法，那么程序计数器的值就是虚拟机字节码指令的地址；如果执行的是Native方法，那么程序计数器的值为空。</li>
<li>此内存区域是Java虚拟机运行规范中没有规定任何OutOfMemoryError情况的区域。</li>
</ol>


<!--more-->


<h2>Java虚拟机栈：</h2>

<ol>
<li>与程序计数器一样，也是线程私有，它的生命周期与线程一样。</li>
<li>Java虚拟机栈描述的是Java方法执行时的内存模型：每一个方法在执行时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</li>
<li>局部变量表存放了在编译期可知的各种基本数据类型（int,short,long,double,float,boolean），对象引用类型（reference类型，可能指向对象起始地址的指针）和returnAddress类型（指向一条字节码指令的地址）。</li>
<li>局部变量表的内存大小在编译期确定并完成分配，当进入一个方法时，这个方法需要在帧中分配的局部变量表的大小确定，并且在运行期不改变。</li>
<li>Java虚拟机栈的内存大小是可以动态扩展的，在这个区域可能会发生两种异常：OutOfMemoryError与StackOverflowError。</li>
</ol>


<h2>本地方法栈：</h2>

<ol>
<li>与虚拟机栈的作用类似，只不过虚拟机栈是为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈是为虚拟机使用到的Native方法服务。有的虚拟机（如HotSpot）直接把这两个合二为一。</li>
<li>在这个区域可能会发生两种异常：OutOfMemoryError与StackOverflowError，与虚拟机栈相同。</li>
</ol>


<h2>Java堆：</h2>

<ol>
<li>Java堆是Java虚拟机所管理的内存最大的一块区域。</li>
<li>Java堆是所有线程共享的一块区域，随着虚拟机的启动而创建。此区域的唯一目的就是存放对象的实例，几乎所有的对象实例都在这里分配内存。Java虚拟机规范描述的是：所有的对象实例及数组都在堆上分配。</li>
<li>Java堆是垃圾收集器管理的主要区域。</li>
<li>Java堆可以处在物理上连续的内存空间中，也可以处于不连续的内存空间中（只要是逻辑上连续即可）。在实现时，可以是固定大小的，也可以是可扩展的。</li>
<li>当堆中没有内存完成实例分配时，且堆也无法扩展时，可能会发生的异常为：OutOfMemoryError。</li>
</ol>


<h2>方法区：</h2>

<ol>
<li>方法区与Java堆一样也是线程共享的，它用于存储已被虚拟机加载的类信息，常量，静态变量，即编译器编译后的代码（如被final static修饰，会在编译结束后放在常量池中）等数据。</li>
<li>除了与Java堆一样可以不需要连续的内存，可以选择固定的大小或可扩展的外，还可以选择不实现垃圾收集。相对而言，垃圾收集在这里的行为很少（这一区域的回收主要是对常量池的回收和对类型的卸载）。</li>
<li>当内存无法满足要求时，会抛出：OutOfMemoryError。</li>
</ol>


<h2>运行时常量池：</h2>

<ol>
<li>运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还包括一项信息是常量池。</li>
<li>常量池用于存放编译期生成的各种字面量和符号引用。</li>
<li><p>字面量和符号引用量：字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p>

<pre><code>    * 类和接口的全限定名
    * 字段名称和描述符
    * 方法名称和描述符
</code></pre></li>
<li><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p></li>
<li>java中基本类型的包装类的大部分都实现了常量池技术，即（Byte,Short,Integer,Long,Character,Boolean）。类比于Integer类型在自动装箱时，如果值[-128,127]之间，那么就存储在常量池中。两种浮点数类型的包装类Float,Double并没有实现常量池技术。</li>
<li>只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。</li>
<li>对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</li>
</ol>


<p>*</p>

<pre><code>     String string1="te";
     String string2="st";
     String string3="test";
     String string4=string1+string2;
     String string5="te"+"st";
     String string6=new StringBuilder("test").toString();
 　　String string7=new String("test").intern();


    System.out.println(string3==string4);//false
    System.out.println(string3==string5);//true
    System.out.println(string4==string5);//false
    System.out.println(string3==string6);//false
    System.out.println(string3==string7);//true
</code></pre>

<p>　　 <br/>
*</p>
]]></content>
  </entry>
  
</feed>
