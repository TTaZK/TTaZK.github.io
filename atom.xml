<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Blog Of ZK]]></title>
  <link href="http://ttazk.github.io/atom.xml" rel="self"/>
  <link href="http://ttazk.github.io/"/>
  <updated>2017-03-19T12:38:05+08:00</updated>
  <id>http://ttazk.github.io/</id>
  <author>
    <name><![CDATA[Z K]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[泛型程序设计]]></title>
    <link href="http://ttazk.github.io/blog/2017/03/19/generic/"/>
    <updated>2017-03-19T10:38:05+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/03/19/generic</id>
    <content type="html"><![CDATA[<ul>
<li>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。</li>
<li><p>在增加泛型之前，泛型程序是利用继承实现的。</br>
      public class ArrayList{
      private Object[] data;
       &hellip;
      public Object get(int i){}
      public void add(Object o){}
      }</p></li>
<li><p>这种方法有两个问题：</p></li>
<li>1.当获取一个值时必须进行强制类型转换。</li>
<li><p>2.没有错误检查，可以向数组列表中添加任何类的对象。</br></br></p></li>
<li><p>泛型提供了一个更好的解决方法：类型参数，用来指示存储元素的类型。如：ArrayList<String> arl=new ArrayList&lt;>();   (jdk1.7之后，构造函数中可以省略泛型类型)。</p>

<ul>
<li>对此编译器可以进行检查，避免插入错误的类型，同时在获取对象时不需要进行强制类型转换。</li>
<li>一个泛型类(generic class)就是具有一个或多个类型变量的类。</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>      public class Pair&lt;T&gt; {
</span><span class='line'>      private T first;
</span><span class='line'>      private T second;
</span><span class='line'>  
</span><span class='line'>      public Pair(){
</span><span class='line'>           this.first=null;
</span><span class='line'>           this.second=null;
</span><span class='line'>      }
</span><span class='line'>      public Pair(T first,T second){
</span><span class='line'>           this.first=first;
</span><span class='line'>           this.second=second;
</span><span class='line'>      }
</span><span class='line'>  
</span><span class='line'>      public T getFirst(){
</span><span class='line'>           return first;
</span><span class='line'>      }
</span><span class='line'>      public T getSecond(){
</span><span class='line'>           return second;
</span><span class='line'>      }
</span><span class='line'>      public void setFirst(T first){
</span><span class='line'>           this.first=first;
</span><span class='line'>      }
</span><span class='line'>      public void setSecond(T second){
</span><span class='line'>           this.second=second;
</span><span class='line'>          }
</span><span class='line'>      }</span></code></pre></td></tr></table></div></figure>


<pre><code>* 如上所示，Pair类引入了一个类型变量T,用&lt;&gt;括起来，并放在类名之后。泛型类可以有多个类型变量。例如可以定义Pair类，两个域分别使用不同的类型变量：public class Pair&lt;T,V&gt;{...}.
* 类中定义的泛型变量指定方法的返回类型，以及域和局部变量的类型。（一般来说，K,V分别表示关键字与值的类型，T表示任意类型）。
* 用具体的类型替换类型变量就可以实例化泛型类型，如Pair&lt;String&gt;。换句话来说，泛型类可以看做普通类的工厂。
</code></pre>

<p></br></br></p>

<!--more-->


<h3>* 泛型方法</h3>

<ul>
<li>可以在一个普通类中定义一个带有类型参数的简单方法。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  public class Generic {
</span><span class='line'>  public static &lt;T&gt; void print(T t){
</span><span class='line'>  System.out.println(t);
</span><span class='line'>      }
</span><span class='line'>  }
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>注意：类型变量放在修饰符的后面，返回类型的前面。</li>
<li>泛型方法可以定义在普通类中，也可以定义在泛型类中。</li>
<li>当调用一个泛型方法时，可以在方法名前的&lt;>中放入具体的类型，也可以省略&lt;>类型参数。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Generic.print("no");
</span><span class='line'>Generic.&lt;String&gt;print("nothing");</span></code></pre></td></tr></table></div></figure>


<h3>* 类型变量的限定</h3>

<ul>
<li>有时，需要对类或泛型方法中的类型变量加以限定。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> public static &lt;T extends Comparable&gt; void sys(T t){
</span><span class='line'>     System.out.println(t);
</span><span class='line'>          }</span></code></pre></td></tr></table></div></figure>


<ul>
<li>可以对泛型变量T进行限定，将其限定为实现了Comparable接口的类。</li>
<li><T extends BoundingType> 表示：T应该是绑定类型的子类型。T和绑定类型可以是类，也可以是接口。</li>
<li>一个类型变量或通配符可以有多个限定，如：T extends Comaprable &amp; Serializable</li>
<li>在Java的继承中，可以根据需要有多个接口的父类型，但是限定中至多只能有一个类，且必须是限定列表中的第一个。</li>
</ul>


<h3>* 类型擦除</h3>

<ul>
<li>在虚拟机中，没有泛型类型对象&mdash;-所有的对象都属于普通类。</li>
<li>无论何时定义一个泛型类型，都会自动提供一个相应的原始类型(raw type)。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型（没有限定类型就用Object）。</li>
<li>例如，Pair<T>的原始类型为：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public class Pair{
</span><span class='line'>private Object first;
</span><span class='line'>private Object second;
</span><span class='line'>
</span><span class='line'>public Pair(){
</span><span class='line'>     this.first=null;
</span><span class='line'>     this.second=null;
</span><span class='line'>}
</span><span class='line'>public Pair(Object first,Object second){
</span><span class='line'>     this.first=first;
</span><span class='line'>     this.second=second;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public Object getFirst(){
</span><span class='line'>     return first;
</span><span class='line'>}
</span><span class='line'>public Object getSecond(){
</span><span class='line'>     return second;
</span><span class='line'>}
</span><span class='line'>public void setFirst(Object first){
</span><span class='line'>     this.first=first;
</span><span class='line'>}
</span><span class='line'>      public void setSecond(Object second){
</span><span class='line'>     this.second=second;
</span><span class='line'>}
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在程序中可以包含不同类型的Pair，如Pair<String>,Pair<LocalDate>，但是类型擦除后就变成了原始的Pair类型了。</li>
<li>原始类型用第一个限定类型来替换参数变量，如果没有给定限定类型，就用Object替换。</li>
<li>为了提高效率，应该将标签接口(没有方法的接口)放在列表的末尾。</li>
</ul>


<h3>* 翻译泛型表达式</h3>

<ul>
<li><p>当程序调用泛型方法时，如果擦除返回类型，编译器则插入强制类型转换。</p>

<pre><code>  * Pair&lt;Employee&gt; p=new Pair&lt;&gt;();
  * Employee e=p.getFirst();//先对原始方法调用Pair.getFirst();再将返回的Object类型强制转换成Employee类型。
</code></pre></li>
<li>关于java泛型转换的事实：

<pre><code>* 虚拟机中没有泛型，只有普通的类与方法。
* 所有的参数类型都用它们的限定类型进行替换。
* 为了保持类型安全，必要时插入强制类型转换。
* 桥方法被合成来保持多态。
</code></pre></li>
</ul>


<h3>* 约束与局限性(大多数限制都是由类型擦除引起的)</h3>

<h5>* 不能用基本类型实例化类型参数</h5>

<ul>
<li>因此没有Pair<double>，只有Pair<Double>。原因是类型擦除，擦除之后，Pair类含有Object域，而Object域不能存储基本类型。

<h5>* 运行时类型查询只适用于原始类型</h5></li>
<li>虚拟机中的对象总有一个特定的非泛型类型，因此，所有的类型查询只产生原始类型。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Pair&lt;String&gt; pair=new Pair&lt;String&gt;();
</span><span class='line'>if (pair instanceof Pair&lt;String&gt;) {    //error
</span><span class='line'>   System.out.println(true);
</span><span class='line'>} 
</span><span class='line'>if (pair instanceof Pair) {         //true
</span><span class='line'>System.out.println(true);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>*
* 同样，getClass()方法返回的是原始类型。</p>

<pre><code>Pair&lt;String&gt; pair=new Pair&lt;String&gt;();
Pair&lt;Double&gt; pair2=new Pair&lt;Double&gt;();
if (pair.getClass()==pair2.getClass()) {
System.out.println(true);
}         //输出为true
</code></pre>

<h5>* 不能创建泛型数组</h5>

<pre><code>Pair&lt;String&gt;[] pairs=new Pair&lt;String&gt;[10];  //error
</code></pre>

<ul>
<li>只是不能创建这些数组，但是声明类型Pair<String>[] 的变量仍是合法的，只能不过不能初始化。</li>
<li>原因也是类型擦除。</li>
</ul>


<h5>* 不能实例化类型变量</h5>

<ul>
<li>即不能使用new T(&hellip;),new T[&hellip;],或T.class这样的表达式中的类型变量。</li>
</ul>


<h5>* 不能创建类型变量数组</h5>

<pre><code>private T[] ts=new T[2];   //error
</code></pre>

<h5>* 不能在静态域或静态方法中引用类型变量</h5>

<pre><code>    * private static T t;   //error
    * public static T print(){}   //error
</code></pre>

<p></br></br></p>

<h3>* 泛型类型的继承规则</h3>

<ul>
<li>考虑一个类与一个子类，如Object,String，那么Pair<String>是Pair<Object>的子类吗？不是</li>
<li>无论T和V有什么关系，通常Pair<V>,Pair<T>是没有任何关系的。
Pair<Object>[] pair3=new Pair<String>[10];  //error</li>
<li>注意泛型与Java数组之间的区别：可以将子类数组的变量赋给父类数组变量。
Object[] objects=new String[10];</li>
<li>永远可以将参数化类型转换为一个原始类型。
Pair pair3=new Pair<String>();</li>
<li>泛型类可以扩展或者实现其他泛型类，这点而言与普通类没有区别</li>
<li>ArrayList<T>类实现了List<T>接口。</li>
<li>意味着ArrayList<String>可以转换为List<String></li>
</ul>


<h3>* 通配符类型</h3>

<ul>
<li>通配符类型中，允许类型参数变化。如  Pair&lt;? extends Comparable></li>
<li><p>类型Pair<String>是Pair&lt;? extends Object>的子类型。</p>

<pre><code>                                                                                                                  &lt;---Pair&lt;Object&gt;
</code></pre>

<p>  Pair(原始类型)&lt;&mdash;Pair&lt;? extends Object><---
                                                                                                                      <---Pair<String></p></li>
<li><p>通配符的超类型限定</p></li>
<li>可以指定一个父类型：  ? super Manager</li>
<li>带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型对象读取。(P332)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运输层]]></title>
    <link href="http://ttazk.github.io/blog/2017/03/14/transmission/"/>
    <updated>2017-03-14T10:39:03+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/03/14/transmission</id>
    <content type="html"><![CDATA[<ul>
<li>运输层用于向它上面的应用层提供服务，它属于面向通信的最高层，同时也是用户功能的最低层。当网络的边缘部分的两个主机进行通信时，只有主机的协议栈中才有运输层，而网络核心部分在转发分组时都只用到下三层的功能。</li>
<li>两个主机进行通信，也就是两个主机中的应用进程进行通信，通信的真正端点是主机中的进程。</li>
<li>运输层能够“复用”与“分用”：复用是指发送方不同的应用进程都可以使用同一个运输层协议传输数据，分用是指接收方的运输层能够把接收的数据正确地交付到目的应用进程中。</li>
<li>网络层为主机之间提供逻辑通信，运输层为应用进程间提供逻辑通信。运输层向高层用户屏蔽了下面网络的核心细节。</li>
<li><p>运输层包括两个主要的协议：TCP（传输控制协议），UDP（用户数据报协议）。传输的数据单元分别为：TCP报文段与UDP用户数据报。</p></li>
<li><p>UDP在传输数据之前不需要建立连接。接收方在收到报文后也不需要给出任何确认。</p></li>
<li>TCP采用面向连接的服务，在传输数据之前先建立连接，且TCP不支持广播或者多播服务。</li>
</ul>


<!--more-->


<h3>* 在运输层中使用端口号来将数据交付给应用层的目的进程。16位的端口号只具有本地意义，用来标识计算机应用层中的各个进程与运输层交互时的层间接口。不同的计算机中，相同的端口号是没有关联的。</h3>

<ul>
<li>由此可见，两个计算机中的进程进行通信时，不仅要知道对方的IP地址（为了找到对方的计算机），还要知道对方的端口号（找到计算机中的应用进程）。</li>
<li>端口号分为两大类：

<ul>
<li>服务器端使用的端口号：分为系统端口号（0&ndash;1023）与登记端口号（1024&ndash;49151）。</li>
<li>客户端使用的端口号：又称为短暂端口号，这类端口号仅在客户进程运行时才动态选择，通信结束后，刚才使用的客户端号就不复存在，这个端口号就可以供其他客户进程以后使用。</br>  <br/>
<br><br><br><br>

<h2>* UDP主要特点是：</h2></li>
</ul>
</li>
<li>无连接的，发送数据之前不需要建立连接，减少了开销。</li>
<li>使用进最大努力交付，即不保证可靠交付。</li>
<li>UDP是面向报文的。发送方的UDP对应用程序交下来的报文，既不合并，也不拆分，而是在添加首部之后，直接交付给下层的IP层。也就是说，UDP一次交付一个完整地报文。接收方的UDP对IP层上传的报文在去除首部之后就直接上交给应用程序。</li>
<li>UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。</li>
<li>UDP支持一对多，多对多的交互通信。</li>
<li><p>UDP的首部开销小，只有8个字节。<br><br></p></li>
<li><p>UDP用户数据报有两个字段：首部与数据段。首部8个字节，由4个字段组成，每个字段的长度都是两个字节，分为：源端口，目的端口，长度，校验和。</p></li>
<li>如果接收方UDP发现收到的报文中的目的端口不正确，就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方。<br><br><br><br></li>
</ul>


<h2>* TCP的主要特点：</h2>

<ul>
<li>面向连接：在传输数据之前先建立连接，传输结束之后释放连接。</li>
<li>每个TCP连接只能有两个端点，所以TCP只能是一对一的。</li>
<li>提供可靠的交付服务：通过TCP连接传输的数据，无差错，不丢失，不重复，且按顺序到达。</li>
<li>提供全双工通信。</li>
<li>TCP面向字节流：“流”是指流入到应用进程或者从应用进程中流出的字节序列。</li>
<li><p>TCP和UDP在发送报文时采取的方式完全不同。TCP根据对方的窗口值和当前网络的拥塞程度来决定一个报文段应该包含多少个字节，UDP发送的报文长度是应用进程给的。</p></li>
<li><p>TCP连接的端点叫做套接字：即Socket=IP地址+端口号。</p>

<ul>
<li>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。同一个IP地址可以对应多个TCP连接，同一个端口号可以出现在不同的TCP连接中。</li>
<li>TCP虽然是面向字节流的，但是TCP传输的数据单元确是报文段。报文段分为首部和数据段两部分。</li>
<li>TCP报文段的首部（20个字节）格式：

<ul>
<li>源端口与目的端口：各占两个字节。</li>
<li>序号：4个字节，范围为[0,2的32次方-1]，TCP是面向字节流的。TCP连接传送的字节流中的每个字节都按照顺序编号。首部中的序号字指的是本报文段所发送的数据的第一个字节的序号。</li>
<li>确认号：4个字节，是期望收到对方的下一个报文段的第一个数据字节的序号。若确认号为n，则表明到n-1为止所有的数据都已正确收到。</li>
<li>数据偏移：4位，单位为4个字节，指的是TCP报文段的首部长度，最大为60个字节。</li>
<li>保留：6位</li>
<li><p>6个控制位：</p>

<ul>
<li>紧急（URG）：当URG=1时，表明紧急指针字段有效。</li>
<li>确认（ACK）：仅当ACK=1时，确认号字段才有效，若为0，则无效；规定，当TCP连接建立后，所有的传送报文段都必须把ACK置为1.</li>
<li>推送（PSH）</li>
<li>复位（RST）：当RST等于1时，表明TCP连接出现差错，必须释放连接，然后再重新建立连接。</li>
<li>同部位（SYN）：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是个连接请求报文段。若对方同意建立连接，则应在响应的报文中使SYN=1，ACK=1。因此，SYN=1表明这是个连接请求报文或者连接接受报文。</li>
<li>终止（FIN）：用来释放一个连接。当FIN=1时，表明报文段发送方已经将数据发送完毕，并要求释放连接。</li>
</ul>
</li>
<li><p>窗口：2个字节，指的是发送此报文段的一方的接收窗口，而不是自己的发送窗口。窗口字段表明现在允许对方发送的数据量。窗口值是经常动态变化的。</p></li>
<li>检验和：2个字节</li>
<li>紧急指针：2个字节，在URG=1时才有效，指明紧急数据的字节数。
<br><br></li>
</ul>
</li>
</ul>
</li>
<li>TCP可靠传输的实现：

<ul>
<li>TCP滑动窗口是以字节为单位的。设A为发送方，B为接收方。</li>
<li>发送窗口表示：在没有收到B的确认情况下，A可以连续把窗口内的数据都发送出去。凡是已经发送出去的数据，在未收到确认之前都必须暂时保留，以便在超时重传中使用。窗口的大小是动态变换的。</li>
<li>发送窗口中的字节分为两类：已经发送，但是尚未收到确认的字节；允许发送，但是尚未发送的字节。发送窗口的位置由前沿与后沿的位置共同确认。发送后沿有两种情况：不动（没有收到新的确认）和前移（收到了新的确认，每收到一个确认向前动一个位置），发送前沿通常是不断向前移动，但也有可能不动，对应于两种情况：没有收到新的确认，对方通知的窗口大小也不变；收到了新的确认，但是对方通知的新的窗口缩小了。</li>
<li>接收窗口B只能对按顺序收到的数据中的最高序号给出确认。对于接收到的但是未按顺序到达的字节，暂存在接收窗口中。</li>
<li>A只要超过了一段时间仍没收到确认，就认为刚才的分组丢失了，因而重传前面发送过的分组，叫做超时重传。要实现超时重传，就要在每次发送结束后设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</li>
<li>对于有种情况，A发送的数据B都按顺序接受了，并且发送了确认，但是这个确认在网络中滞留了，此时A还是会重传这些数据。
<br><br></li>
</ul>
</li>
<li>TCP的流量控制：

<ul>
<li>还是通过滑动窗口协议实现。</li>
<li>发送方的发送窗口不能超过接收方给出的接收窗口的数值。</li>
<li>TCP窗口的单位是字节，不是报文段。
<br><br></li>
</ul>
</li>
<li>TCP连接的建立：

<ul>
<li>TCP连接的建立采用客户服务器模式。主动发起连接叫做客户（A），等待连接的叫做服务器（B）。</li>
<li>B的TCP服务器进程创建传输控制块（TCB），等待客户进程的连接。服务器处于LISTEN（收听）状态。</li>
<li>A的TCP客户进程也创建传输控制块（TCB），然后向B发送请求报文段。报文段首部中的同部位SYN=1，序列号seq=x。此报文段不能携带数据，但是要消耗一个序列号。客户端处于SYN-SENT（同步已发送）状态。</li>
<li>B收到请求报文段后，如果同意连接，则向A发送确认报文段。在该报文段中，首部的SYN=1，ACK=1，确认号ack=x+1，序列号seq=y。这个报文段也不能携带数据，但是要消耗一个序列号。此时，服务器处于SYN-RCVD（同步收到）状态。</li>
<li>A收到B的确认之后，仍要发给B一个确认。确认报文段的ACK=1，确认号ack=y+1，序列号seq=x+1。此时，该报文段可以携带数据，如果不携带数据则不消耗序列号（下个报文段的序列号仍是x+1）。至此，TCP连接建立，A处于ESTABLISHED（连接建立）状态。</li>
<li>B收到确认后，也处于ESTABLISHED（连接建立）状态。</li>
<li>为什么A还要发送一次确认呢？为了防止已经失效的请求突然又传送到了B，因而产生错误。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[虚拟机类加载机制]]></title>
    <link href="http://ttazk.github.io/blog/2017/03/09/jvm2/"/>
    <updated>2017-03-09T22:55:40+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/03/09/jvm2</id>
    <content type="html"><![CDATA[<ul>
<li>类的生命周期包括：加载&ndash;>连接&ndash;>初始化&ndash;>使用&ndash;>卸载，其中连接包括，验证&ndash;>准备&ndash;>解析。</li>
<li>虚拟机把描述类的数据从Class文件中加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可被虚拟机直接使用的Java类型。</li>
<li>在Java中，类的加载，连接，初始化都是在运行期间完成的，这种策略与C++等不同，但是这也实现了Java语言的运行期动态加载与动态连接的特点。</li>
</ul>


<!--more-->


<h2>类加载的过程：</h2>

<ol>
<li>加载</li>
<li><p>加载是类加载的一个阶段。在加载时需要 完成以下几件事情：</p>

<ol>
<li>通过类的全限定名称获取此类的二进制字节流</li>
<li>将这个字节流所带表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
</li>
<li><p>二进制字节流可以从Class文件中获取，也可以从网络中或者其他文件中获取。</p></li>
<li><p>在加载阶段完成后，虚拟机外部的二进制字节流就转换为方法区中的数据结构，然后再在内存中实例化一个java.lang.Class对象，作为程序访问方法区中这些数据类型的接口。</p></li>
<li><p>验证</p></li>
<li><p>为了确保Class文件中的字节流所包含的信息是符合当前虚拟机的要求。</p></li>
<li><p>准备</p></li>
<li><p>准备阶段是正式为类变量设置初始值的阶段。这些变量所用的内存都将在方法区中分配。</p></li>
<li>此时仅分配类变量，不包括实例变量。实例变量会随着对象实例化一起在Java堆中分配。</li>
<li>这里说的初始值是数据的零值，null/false/0等。</li>
<li><p>解析</p></li>
<li><p>将常量池中的符号引用替换为直接引用。</p></li>
<li><p>初始化</p></li>
<li><p>在这个阶段，才是对类变量进行赋值操作。按照程序的主观计划去初始化类变量及其他资源。</p></li>
<li>初始化是执行类构造器<clinit>()方法的过程，<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作与静态语句块（static{}）中的语句合并。</li>
<li>类构造器<clinit>()方法与类的构造函数（实例构造器<init>()方法）不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。</li>
<li>由于父类的<clinit>()方法先执行，因此父类中定义的静态语句块要优先于子类的静态语句块。</li>
<li>对于类来说并不是必须的，如果类中没有类变量，也没有静态语句块，那么便不需要<clinit>()方法。</li>
<li>如果多个线程同时初始化一个类，那么只有一个线程会执行<clinit>()方法，其他线程阻塞等待。</li>
</ol>


<h2>虚拟机规范中严格定义了有且只有5中情况必须立即对类进行初始化（加载，验证，准备需要在此之前完成）</h2>

<ol>
<li>遇到new,getstatic,putstatic或者invokestatic这4条字节码指令时，如果类没有进行初始化，则需要对它进行初始化。生成这4条字节码指令的Java代码是：使用new关键字实例化对象，读取或者设置一个类的静态字段（被final修饰，已经在编译期就把结果放到常量池的静态字段除外），以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包中的方法对类进行反射调用的时候，如果类没有进行初始化，则需初始化。</li>
<li>当初始化一个类的时候（注意是类，不是对象），如果发现父类没有被初始化，则先初始化其父类。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法），虚拟机会先初始化这个主类。</li>
<li>当使用jdk1.7的动态语言支持时，如果一个方法解析后句柄对应的类没有初始化，则先初始化。</li>
</ol>


<p>//当调用类中普通的静态变量时（没有被final修饰的），会对类进行初始化</p>

<pre><code>public class InvokeStatic {
public static int a=1;
static{
     System.out.println("the class has been init !");
}
public static void main(String[] args) {
     // TODO Auto-generated method stub
     int i=InvokeStatic.a;
}
}

输出结果为：
the class has been init !
</code></pre>

<p>//当初始化一个类的时候，如果发现父类还没有初始化，便先将其父类进行初始化</p>

<pre><code>class Super{
static{
     System.out.println("The super has been init !");
}
}
public class InvokeChildStatic extends Super {
static int a=10;
static{
     System.out.println("The child has been init !");
}
public static void main(String[] args) {
     // TODO Auto-generated method stub
     System.out.println(InvokeChildStatic.a);
}
}
输出结果为：
The super has been init !
The child has been init !
10
</code></pre>

<h2>上面介绍的是对类进行加载及初始化，下面要介绍的是对象的创建：</h2>

<ul>
<li>当虚拟机遇到一个new指令时，首先检查这个指令的参数能否在常量池中定位一个符号引用，并且检查这个符号引用代表的类是否被加载，如果没有，便先加载这个类。</li>
<li>类加载完成之后，虚拟机为新生对象在Java堆中分配内存（对象所需的内存大小在类加载完成后便确定）。</li>
<li>接下来，虚拟机将分配的内存空间都初始化为零值（保证了实例字段在Java代码中可以不赋初值就能使用）。</li>
<li>执行实例构造器<init>()方法，把对象按照程序员的意愿初始化。这样一个对象便创建完成。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[虚拟机内存分配]]></title>
    <link href="http://ttazk.github.io/blog/2017/03/08/jvm1/"/>
    <updated>2017-03-08T15:51:45+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/03/08/jvm1</id>
    <content type="html"><![CDATA[<p>Java运行时数据区分为：方法区，堆，虚拟机栈，本地方法栈，程序计数器。其中，方法区与堆为所有线程共享；虚拟机栈，本地方法栈与程序计数器为线程私有。</p>

<h2>程序计数器：</h2>

<ol>
<li>所占内存空间比较小，可以看做当前线程所执行字节码的行号指数器。字节码解释器在工作时就是通过这个计数器的值来选取下一条需要执行的字节码指令。</li>
<li>每个线程都有一个独立的程序计数器，各个线程的程序计数器互不影响，独立存储，为“线程私有”。</li>
<li>如果线程正在执行的是Java方法，那么程序计数器的值就是虚拟机字节码指令的地址；如果执行的是Native方法，那么程序计数器的值为空。</li>
<li>此内存区域是Java虚拟机运行规范中没有规定任何OutOfMemoryError情况的区域。</li>
</ol>


<!--more-->


<h2>Java虚拟机栈：</h2>

<ol>
<li>与程序计数器一样，也是线程私有，它的生命周期与线程一样。</li>
<li>Java虚拟机栈描述的是Java方法执行时的内存模型：每一个方法在执行时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</li>
<li>局部变量表存放了在编译期可知的各种基本数据类型（int,short,long,double,float,boolean），对象引用类型（reference类型，可能指向对象起始地址的指针）和returnAddress类型（指向一条字节码指令的地址）。</li>
<li>局部变量表的内存大小在编译期确定并完成分配，当进入一个方法时，这个方法需要在帧中分配的局部变量表的大小确定，并且在运行期不改变。</li>
<li>Java虚拟机栈的内存大小是可以动态扩展的，在这个区域可能会发生两种异常：OutOfMemoryError与StackOverflowError。</li>
</ol>


<h2>本地方法栈：</h2>

<ol>
<li>与虚拟机栈的作用类似，只不过虚拟机栈是为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈是为虚拟机使用到的Native方法服务。有的虚拟机（如HotSpot）直接把这两个合二为一。</li>
<li>在这个区域可能会发生两种异常：OutOfMemoryError与StackOverflowError，与虚拟机栈相同。</li>
</ol>


<h2>Java堆：</h2>

<ol>
<li>Java堆是Java虚拟机所管理的内存最大的一块区域。</li>
<li>Java堆是所有线程共享的一块区域，随着虚拟机的启动而创建。此区域的唯一目的就是存放对象的实例，几乎所有的对象实例都在这里分配内存。Java虚拟机规范描述的是：所有的对象实例及数组都在堆上分配。</li>
<li>Java堆是垃圾收集器管理的主要区域。</li>
<li>Java堆可以处在物理上连续的内存空间中，也可以处于不连续的内存空间中（只要是逻辑上连续即可）。在实现时，可以是固定大小的，也可以是可扩展的。</li>
<li>当堆中没有内存完成实例分配时，且堆也无法扩展时，可能会发生的异常为：OutOfMemoryError。</li>
</ol>


<h2>方法区：</h2>

<ol>
<li>方法区与Java堆一样也是线程共享的，它用于存储已被虚拟机加载的类信息，常量，静态变量，即编译器编译后的代码（如被final static修饰，会在编译结束后放在常量池中）等数据。</li>
<li>除了与Java堆一样可以不需要连续的内存，可以选择固定的大小或可扩展的外，还可以选择不实现垃圾收集。相对而言，垃圾收集在这里的行为很少（这一区域的回收主要是对常量池的回收和对类型的卸载）。</li>
<li>当内存无法满足要求时，会抛出：OutOfMemoryError。</li>
</ol>


<h2>运行时常量池：</h2>

<ol>
<li>运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还包括一项信息是常量池。</li>
<li>常量池用于存放编译期生成的各种字面量和符号引用。</li>
<li><p>字面量和符号引用量：字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p>

<pre><code>    * 类和接口的全限定名
    * 字段名称和描述符
    * 方法名称和描述符
</code></pre></li>
<li><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p></li>
<li>java中基本类型的包装类的大部分都实现了常量池技术，即（Byte,Short,Integer,Long,Character,Boolean）。类比于Integer类型在自动装箱时，如果值[-128,127]之间，那么就存储在常量池中。两种浮点数类型的包装类Float,Double并没有实现常量池技术。</li>
<li>只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。</li>
<li>对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</li>
</ol>


<p>*</p>

<pre><code>     String string1="te";
     String string2="st";
     String string3="test";
     String string4=string1+string2;
     String string5="te"+"st";
     String string6=new StringBuilder("test").toString();
 　　String string7=new String("test").intern();


    System.out.println(string3==string4);//false
    System.out.println(string3==string5);//true
    System.out.println(string4==string5);//false
    System.out.println(string3==string6);//false
    System.out.println(string3==string7);//true
</code></pre>

<p>　　 <br/>
*</p>
]]></content>
  </entry>
  
</feed>
