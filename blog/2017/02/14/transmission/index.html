
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->

<head>


<meta charset="utf-8">
<meta http-equiv="cleartype" content="on">

<title>运输层 - Blog Of ZK</title>
<meta name="author" content="Z K">




<meta name="description" content="运输层用于向它上面的应用层提供服务，它属于面向通信的最高层，同时也是用户功能的最低层。当网络的边缘部分的两个主机进行通信时，只有主机的协议栈中才有运输层，而网络核心部分在转发分组时都只用到下三层的功能。
两个主机进行通信，也就是两个主机中的应用进程进行通信，通信的真正端点是主机中的进程。 &hellip;">

<meta name="keywords" content="计算机网络 ">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Twitter Cards -->


<!-- Open Graph -->
<meta property="og:local" content="en_US">
<meta property="og:type" content="article">
<meta property="og:url" content="http://ttazk.github.io/blog/2017/02/14/transmission">
<meta property="og:title" content="运输层">
<meta property="og:description" content="运输层用于向它上面的应用层提供服务，它属于面向通信的最高层，同时也是用户功能的最低层。当网络的边缘部分的两个主机进行通信时，只有主机的协议栈中才有运输层，而网络核心部分在转发分组时都只用到下三层的功能。
两个主机进行通信，也就是两个主机中的应用进程进行通信，通信的真正端点是主机中的进程。 &hellip;">

  <meta property="og:image" content="">

<meta property="og:site_name" content="Blog Of ZK">

<link rel="canonical" href="http://ttazk.github.io/blog/2017/02/14/transmission">
<link href="/favicon.png" rel="icon">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
<link href="/atom.xml" rel="alternate" title="Blog Of ZK" type="application/atom+xml">

<script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
<script>Modernizr || document.write('<script src="/javascripts/vendor/modernizr-2.6.2.custom.min.js"><\/script>') </script>



<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">


</head>

<body id="post" >

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="/">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="" alt="Z K photo" class="author-photo">
					<h4>Z K</h4>
					<p></p>
				</li>
				
				
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="/posts/">All Posts</a></li>
				<li><a href="/categories/">All Categories</a></li>
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->




<div id="main" role="main">
  <article class="hentry">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title"><a href="/blog/2017/02/14/transmission/" rel="bookmark" title="运输层">运输层</a></h1>
        
        <h2>February 14, 2017</h2>
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content">
      <ul>
<li>运输层用于向它上面的应用层提供服务，它属于面向通信的最高层，同时也是用户功能的最低层。当网络的边缘部分的两个主机进行通信时，只有主机的协议栈中才有运输层，而网络核心部分在转发分组时都只用到下三层的功能。</li>
<li>两个主机进行通信，也就是两个主机中的应用进程进行通信，通信的真正端点是主机中的进程。</li>
<li>运输层能够“复用”与“分用”：复用是指发送方不同的应用进程都可以使用同一个运输层协议传输数据，分用是指接收方的运输层能够把接收的数据正确地交付到目的应用进程中。</li>
<li>网络层为主机之间提供逻辑通信，运输层为应用进程间提供逻辑通信。运输层向高层用户屏蔽了下面网络的核心细节。</li>
<li><p>运输层包括两个主要的协议：TCP（传输控制协议），UDP（用户数据报协议）。传输的数据单元分别为：TCP报文段与UDP用户数据报。</p></li>
<li><p>UDP在传输数据之前不需要建立连接。接收方在收到报文后也不需要给出任何确认。</p></li>
<li>TCP采用面向连接的服务，在传输数据之前先建立连接，且TCP不支持广播或者多播服务。</li>
</ul>


<!--more-->


<h5>* 在运输层中使用端口号来将数据交付给应用层的目的进程。16位的端口号只具有本地意义，用来标识计算机应用层中的各个进程与运输层交互时的层间接口。不同的计算机中，相同的端口号是没有关联的。</h5>

<ul>
<li>由此可见，两个计算机中的进程进行通信时，不仅要知道对方的IP地址（为了找到对方的计算机），还要知道对方的端口号（找到计算机中的应用进程）。</li>
<li>端口号分为两大类：

<ul>
<li>服务器端使用的端口号：分为系统端口号（0&ndash;1023）与登记端口号（1024&ndash;49151）。</li>
<li>客户端使用的端口号：又称为短暂端口号，这类端口号仅在客户进程运行时才动态选择，通信结束后，刚才使用的客户端号就不复存在，这个端口号就可以供其他客户进程以后使用。</br>  <br/>
<br><br><br><br>

<h2>* UDP主要特点是：</h2></li>
</ul>
</li>
<li>无连接的，发送数据之前不需要建立连接，减少了开销。</li>
<li>使用进最大努力交付，即不保证可靠交付。</li>
<li>UDP是面向报文的。发送方的UDP对应用程序交下来的报文，既不合并，也不拆分，而是在添加首部之后，直接交付给下层的IP层。也就是说，UDP一次交付一个完整地报文。接收方的UDP对IP层上传的报文在去除首部之后就直接上交给应用程序。</li>
<li>UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。</li>
<li>UDP支持一对多，多对多的交互通信。</li>
<li><p>UDP的首部开销小，只有8个字节。<br><br></p></li>
<li><p>UDP用户数据报有两个字段：首部与数据段。首部8个字节，由4个字段组成，每个字段的长度都是两个字节，分为：源端口，目的端口，长度，校验和。</p></li>
<li>如果接收方UDP发现收到的报文中的目的端口不正确，就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方。<br><br><br><br></li>
</ul>


<h2>* TCP的主要特点：</h2>

<ul>
<li>面向连接：在传输数据之前先建立连接，传输结束之后释放连接。</li>
<li>每个TCP连接只能有两个端点，所以TCP只能是一对一的。</li>
<li>提供可靠的交付服务：通过TCP连接传输的数据，无差错，不丢失，不重复，且按顺序到达。</li>
<li>提供全双工通信。</li>
<li>TCP面向字节流：“流”是指流入到应用进程或者从应用进程中流出的字节序列。</li>
<li><p>TCP和UDP在发送报文时采取的方式完全不同。TCP根据对方的窗口值和当前网络的拥塞程度来决定一个报文段应该包含多少个字节，UDP发送的报文长度是应用进程给的。</p></li>
<li><p>TCP连接的端点叫做套接字：即Socket=IP地址+端口号。</p>

<ul>
<li>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。同一个IP地址可以对应多个TCP连接，同一个端口号可以出现在不同的TCP连接中。</li>
<li>TCP虽然是面向字节流的，但是TCP传输的数据单元确是报文段。报文段分为首部和数据段两部分。</li>
<li>TCP报文段的首部（20个字节）格式：

<ul>
<li>源端口与目的端口：各占两个字节。</li>
<li>序号：4个字节，范围为[0,2的32次方-1]，TCP是面向字节流的。TCP连接传送的字节流中的每个字节都按照顺序编号。首部中的序号字指的是本报文段所发送的数据的第一个字节的序号。</li>
<li>确认号：4个字节，是期望收到对方的下一个报文段的第一个数据字节的序号。若确认号为n，则表明到n-1为止所有的数据都已正确收到。</li>
<li>数据偏移：4位，单位为4个字节，指的是TCP报文段的首部长度，最大为60个字节。</li>
<li>保留：6位</li>
<li><p>6个控制位：</p>

<ul>
<li>紧急（URG）：当URG=1时，表明紧急指针字段有效。</li>
<li>确认（ACK）：仅当ACK=1时，确认号字段才有效，若为0，则无效；规定，当TCP连接建立后，所有的传送报文段都必须把ACK置为1.</li>
<li>推送（PSH）</li>
<li>复位（RST）：当RST等于1时，表明TCP连接出现差错，必须释放连接，然后再重新建立连接。</li>
<li>同部位（SYN）：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是个连接请求报文段。若对方同意建立连接，则应在响应的报文中使SYN=1，ACK=1。因此，SYN=1表明这是个连接请求报文或者连接接受报文。</li>
<li>终止（FIN）：用来释放一个连接。当FIN=1时，表明报文段发送方已经将数据发送完毕，并要求释放连接。</li>
</ul>
</li>
<li><p>窗口：2个字节，指的是发送此报文段的一方的接收窗口，而不是自己的发送窗口。窗口字段表明现在允许对方发送的数据量。窗口值是经常动态变化的。</p></li>
<li>检验和：2个字节</li>
<li>紧急指针：2个字节，在URG=1时才有效，指明紧急数据的字节数。
<br><br></li>
</ul>
</li>
</ul>
</li>
<li>TCP可靠传输的实现：

<ul>
<li>TCP滑动窗口是以字节为单位的。设A为发送方，B为接收方。</li>
<li>发送窗口表示：在没有收到B的确认情况下，A可以连续把窗口内的数据都发送出去。凡是已经发送出去的数据，在未收到确认之前都必须暂时保留，以便在超时重传中使用。窗口的大小是动态变换的。</li>
<li>发送窗口中的字节分为两类：已经发送，但是尚未收到确认的字节；允许发送，但是尚未发送的字节。发送窗口的位置由前沿与后沿的位置共同确认。发送后沿有两种情况：不动（没有收到新的确认）和前移（收到了新的确认，每收到一个确认向前动一个位置），发送前沿通常是不断向前移动，但也有可能不动，对应于两种情况：没有收到新的确认，对方通知的窗口大小也不变；收到了新的确认，但是对方通知的新的窗口缩小了。</li>
<li>接收窗口B只能对按顺序收到的数据中的最高序号给出确认。对于接收到的但是未按顺序到达的字节，暂存在接收窗口中。</li>
<li>A只要超过了一段时间仍没收到确认，就认为刚才的分组丢失了，因而重传前面发送过的分组，叫做超时重传。要实现超时重传，就要在每次发送结束后设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。</li>
<li>对于有种情况，A发送的数据B都按顺序接受了，并且发送了确认，但是这个确认在网络中滞留了，此时A还是会重传这些数据。
<br><br></li>
</ul>
</li>
<li>TCP的流量控制：

<ul>
<li>还是通过滑动窗口协议实现。</li>
<li>发送方的发送窗口不能超过接收方给出的接收窗口的数值。</li>
<li>TCP窗口的单位是字节，不是报文段。
<br><br></li>
</ul>
</li>
<li>TCP连接的建立：

<ul>
<li>TCP连接的建立采用客户服务器模式。主动发起连接叫做客户（A），等待连接的叫做服务器（B）。</li>
<li>B的TCP服务器进程创建传输控制块（TCB），等待客户进程的连接。服务器处于LISTEN（收听）状态。</li>
<li>A的TCP客户进程也创建传输控制块（TCB），然后向B发送请求报文段。报文段首部中的同部位SYN=1，序列号seq=x。此报文段不能携带数据，但是要消耗一个序列号。客户端处于SYN-SENT（同步已发送）状态。</li>
<li>B收到请求报文段后，如果同意连接，则向A发送确认报文段。在该报文段中，首部的SYN=1，ACK=1，确认号ack=x+1，序列号seq=y。这个报文段也不能携带数据，但是要消耗一个序列号。此时，服务器处于SYN-RCVD（同步收到）状态。</li>
<li>A收到B的确认之后，仍要发给B一个确认。确认报文段的ACK=1，确认号ack=y+1，序列号seq=x+1。此时，该报文段可以携带数据，如果不携带数据则不消耗序列号（下个报文段的序列号仍是x+1）。至此，TCP连接建立，A处于ESTABLISHED（连接建立）状态。</li>
<li>B收到确认后，也处于ESTABLISHED（连接建立）状态。</li>
<li>为什么A还要发送一次确认呢？为了防止已经失效的请求突然又传送到了B，因而产生错误。</li>
</ul>
</li>
</ul>


      <footer class="entry-meta">
        <span class="entry-tags"><a href="/categories/#计算机网络" title="Pages tagged 计算机网络" class="tag">计算机网络</a></span>
        <span><a href="/blog/2017/02/14/transmission/" rel="bookmark" title="运输层">运输层</a> was published on <span class="entry-date date published updated"><time datetime="2017-02-14T10:39:03+08:00">February 14, 2017</time></span></span>
        
        <span class="author vcard"><span class="fn"><a href="" title="About Z K">Z K</a></span></span>
        
      </footer>
    </div><!-- /.entry-content -->
    
      <div class="read-more">
        
          <div class="read-more-header">
            <a href="/blog/2017/04/22/btree/" class="btn">Read More</a>
          </div><!-- /.read-more-header -->
          <div class="read-more-content">
            <h3><a href="/blog/2017/04/22/btree/" title="B树，B+树，B*树简介">B树，B+树，B*树简介</a></h3>
            <p>* ###B树又叫平衡多路查找树（Balance-Tree)，一棵m阶B树满足以下条件：	* 每个节点至多有m棵子树	* 除根节点外，其他节点至少有|m/2|棵子树	* 根节点至少有两棵子树（除非B树只有一个节点）	* 所有的叶子节点位于同一层上。 &hellip;&hellip; <a href="/blog/2017/04/22/btree/"> Continue reading</a></p>
          </div><!-- /.read-more-content -->
        
        <div class="read-more-list">
          
            <div class="list-item">
              <h4><a href="/blog/2017/04/22/index/" title="MySql索引">MySql索引</a></h4>
              <span>Published on April 22, 2017</span>
            </div><!-- /.list-item -->
          
            <div class="list-item">
              <h4><a href="/blog/2017/04/19/object/" title="Object详解">Object详解</a></h4>
              <span>Published on April 19, 2017</span>
            </div><!-- /.list-item -->
          
        </div><!-- /.read-more-list -->
      </div><!-- /.read-more -->
    
    
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2017 Z K.</span>

  </footer>
</div><!-- /.footer-wrapper -->


	        
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/javascripts/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/javascripts/octopress.js" type="text/javascript"></script>
<script src="/javascripts/scripts.min.js"></script>






	        

</body>
</html>
