<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithm | ZK]]></title>
  <link href="http://ttazk.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://ttazk.github.io/"/>
  <updated>2017-09-07T22:16:46+08:00</updated>
  <id>http://ttazk.github.io/</id>
  <author>
    <name><![CDATA[Z K]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[剑指Offer3]]></title>
    <link href="http://ttazk.github.io/blog/2017/09/07/jianzhioffer3/"/>
    <updated>2017-09-07T22:04:19+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/09/07/jianzhioffer3</id>
    <content type="html"><![CDATA[<h3>31.数组中的逆序对</h3>

<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>

<pre><code>package test;
//在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
//输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
public class InversePairs {
    //该种方法的时间复杂度为O(n^2)，比较复杂
    public static int inversePairs(int [] array) {
        int length=array.length;
        int count=0;
        for(int i=0;i&lt;length;i++){
         int temp=array[i];
         for(int j=i;j&lt;length;j++){
             if (array[i]&gt;array[j]) {
                     count++;
                 }
         }
        }
        return count;
    }
    //下面的方法类似于归并排序，先将数组分开，分别统计子数组的逆序对，再合并统计子数组之间的逆序对
    //时间复杂度为O(nlogn)
    private int[] temp;//临时数组
    public int inversePairs1(int[] array){
         temp=new int[array.length];
         return mergeInverse(array, 0, array.length-1)%1000000007;
    }
    public int mergeInverse(int[] array,int low,int high){

         if (low&gt;=high) {
             return 0;
         }
         int mid=(high+low)/2;
         int a=mergeInverse(array, low, mid)%1000000007;//对左半边进行统计
         int b=mergeInverse(array, mid+1, high)%1000000007;//对右半边进行统计
         int c=merge(array, low, mid, high)%1000000007;//归并统计
         return (a+b+c)%1000000007;
    }
    //原地归并,并统计两个子数组之间的逆序对数
    public int merge(int[] array,int low,int mid,int high){
         for(int i=low;i&lt;=high;i++){
             temp[i]=array[i];//将待排序的元素复制到临时数组中
         }
         int count=0;
         int m=low;int n=mid+1;//标记待归并的两个起始位置,这两个位置是在临时数组中的位置

         for(int i=low;i&lt;=high;i++){
             //将临时数组中的元素按顺序归并到原数组中
             //前两个判断一定要放在后两个判断之前
             if (m&gt;mid){
                 array[i]=temp[n];
                 n++;
             }
             else if(n&gt;high){
                 array[i]=temp[m];
                 m++;
             }
             else if(temp[m]&lt;=temp[n]) {
                 array[i]=temp[m];
                 m++;
             }
             else if(temp[m]&gt;temp[n]){
                 array[i]=temp[n];
                 n++;
                 count=(count+(mid-m+1))%1000000007;//当左半边子数组的其中一个值m大于右半边一个数组值n，则左半边m以后的值都大于n
             }

         }
         return count;
    }
    public static void main(String[] args) {
         System.out.println(inversePairs(new int[]{1,2,3,4,5,6,7,0}));
    }
}
</code></pre>

<!--more-->


<h3>32.两个链表的第一个公共节点</h3>

<p>输入两个链表，找出它们的第一个公共结点。
    package test;</p>

<pre><code>import java.util.HashMap;
import java.util.Map;

//输入两个链表，找出它们的第一个公共结点。
public class FindFirstCommonNode {
    class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }
    //直接先遍历一个链表，记录其中的元素，再遍历第二条链表，找到相同的元素
    public ListNode findFirstCommonNode(ListNode pHead1, ListNode pHead2) {
         Map&lt;ListNode, Integer&gt; map=new HashMap&lt;&gt;();
         int i=0;
         while(pHead1!=null){
             map.put(pHead1,i);
             pHead1=pHead1.next;
             i++;
         }
         while(pHead2!=null){
             if (map.get(pHead2)!=null) {
                return pHead2;
            }
             pHead2=pHead2.next;
         }
         return null;
    }
    //另一种方法：找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走
    //（因为2个链表用公共的尾部）
    //类比于找出链表的倒数第k个节点（使用两个指针），时间复杂度为O(m+n)
    public int getLength(ListNode head){
        int count=0;
        while(head!=null){
            count++;
            head=head.next;
        }
        return count;
    }
    public ListNode findFirstCommonNode1(ListNode pHead1, ListNode pHead2){
        int length1=getLength(pHead1);
        int length2=getLength(pHead2);
        int sub=length1-length2;
        while(sub&gt;0) {
            pHead1=pHead1.next;
            sub--;
        }
        while(sub&lt;0){
            pHead2=pHead2.next;
            sub++;
        }
        while(pHead1!=null){
            if (pHead1.val==pHead2.val) {
                return pHead1;
            }
            pHead1=pHead1.next;
            pHead2=pHead2.next;
        }
        return null;
    }

}
</code></pre>

<h3>33.统计一个数字在排序数组中出现的次数。</h3>

<pre><code>package test;

import java.util.HashMap;
import java.util.Map;

//统计一个数字在排序数组中出现的次数。
public class GetNumberOfK {
    //使用map
    public int getNumberOfK(int [] array , int k) {
        int count=0;
         Map&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;();
         for (int i = 0; i &lt; array.length; i++) {
            if (map.get(array[i])==null) {
                map.put(array[i], 1);
            }
            else {
                map.put(array[i], map.get(array[i])+1);
            }
        }
         if (map.get(k)==null) {
            return 0;
        }
         else {
            count=map.get(k);
        }
         return count;
    }
    //不使用map
    public int getNumberOfK2(int [] array , int k){
        int count=0;
        for (int i = 0; i &lt; array.length; i++) {
            if (array[i]==k) {
                count++;
            }

        }
        return count;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>34.二叉树的深度</h3>

<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
    package test;
    //输入一棵二叉树，求该树的深度。
    //从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
    public class TreeDepth {
        class TreeNode {
            int val = 0;
            TreeNode left = null;
            TreeNode right = null;</p>

<pre><code>        public TreeNode(int val) {
            this.val = val;
        }
    }
     public int treeDepth(TreeNode root) {
          if (root==null) {
             return 0;
         }
          else {
             int depth1=treeDepth(root.left)+1;
             int depth2=treeDepth(root.right)+1;
             return Math.max(depth1, depth2);
         }
     }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>35.判断是否是平衡二叉树</h3>

<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。
    package test;</p>

<pre><code>import test.TreeDepth.TreeNode;

//输入一棵二叉树，判断该二叉树是否是平衡二叉树
public class IsBalancedTree {
    class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        public TreeNode(int val) {
            this.val = val;
        }
    }
    //还可以利用后续遍历的思想，
     public boolean isBalanced(TreeNode root) {
          if (root==null) {
             return true;
         }
          else {
             int left=getDepth(root.left);
             int right=getDepth(root.right);
             int abs=Math.abs(left-right);
             return abs&lt;=1?true:false;
         }
     }
     public int getDepth(TreeNode root){
          if (root==null) {
             return 0;
         }
          else {
             int depth1=getDepth(root.left)+1;
             int depth2=getDepth(root.right)+1;
             return (depth1&gt;depth2)?depth1:depth2;
         }
     }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>36.数组中只出现一次的数字</h3>

<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
    package test;</p>

<pre><code>import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

//一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
public class FindNumsAppearOnce {
    //num1,num2分别为长度为1的数组。传出参数
    //将num1[0],num2[0]设置为返回结果
     public void findNumsAppearOnce(int [] array,int num1[] , int num2[]) {
           Map&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;();
           for (int i = 0; i &lt; array.length; i++) {
               if (map.get(array[i])==null) {
                   map.put(array[i], 1);
            }
               else {
                map.put(array[i], map.get(array[i])+1);
            }
        }
           ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();
           for (int i = 0; i &lt; array.length; i++) {
            if (map.get(array[i])==1) {
                arrayList.add(array[i]);
            }
        }
          num1[0]=arrayList.get(0);
          num2[0]=arrayList.get(1);
     }
}
</code></pre>

<h3>37.和为S的正数序列</h3>

<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
    package test;</p>

<pre><code>import java.util.ArrayList;

//小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。
//但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。
//没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。
//现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!
public class FindContinuousSequence {
    static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists=new ArrayList&lt;&gt;();
     public static ArrayList&lt;ArrayList&lt;Integer&gt; &gt; findContinuousSequence(int sum) {

          int low=1;int high=2;
          while(low&lt;(sum+1)/2){
          //System.out.println("low="+low);
          //System.out.println("high="+high);
          if (getSum(low, high)==sum) {
               //System.out.println(high);
                 ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();
                 for (int i = low; i &lt;=high; i++) {
                     arrayList.add(i);
                 }
                 System.out.println(arrayList.toString());
                 arrayLists.add(arrayList);
                 high++;//将序列添加之后
                 low++;
               }
          //如果和偏小，就需要更多的数字，所以高位右移
          else if (getSum(low, high)&lt;sum) {
               System.out.println("low="+low+"high="+high+"sum="+sum+"getSum="+getSum(low, high));
                 high++;
             }
          //如果和偏大，需要减小数字，所以低位右移
          else if (getSum(low, high)&gt;sum){
               low++;
          }
          }
          return arrayLists;
     }
     public static int getSum(int low,int high){
          int sum=0;
          for(int i=low;i&lt;=high;i++){
              sum=sum+i;
             // System.out.println("sum"+i+"="+sum);
          }
          return sum;
     }
     public static void main(String[] args) {
        //System.out.println(findContinuousSequence(3).toString());
         System.out.println("sum="+getSum(1, 2));
    }
}
</code></pre>

<h3>38.和为S的两个数字</h3>

<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
    package test;</p>

<pre><code>import java.util.ArrayList;

//输入一个递增排序的数组和一个数字S，在数组中查找两个数，
//使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。
public class FindNumbersWithSum {
     public ArrayList&lt;Integer&gt; findNumbersWithSum(int [] array,int sum) {
            ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();
            int low=0;int high=array.length-1;
            while(low&lt;=high){
             if (array[low]+array[high]==sum) {
                     arrayList.add(array[low]);
                     arrayList.add(array[high]);
                     break;
                 }
             else if (array[low]+array[high]&lt;sum) {
                     low++;
                 }
             else if(array[low]+array[high]&gt;sum){
                     high--;
                 }
            }
            return arrayList;
     }
}
</code></pre>

<h3>39.左旋转字符串</h3>

<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！
    package test;
    //汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。
    //对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。
    //例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！
    public class LeftRotateString {
        public String leftRotateString(String str,int n) {
            int length=str.length();
            if (length&lt;n) {
                 return &ldquo;&rdquo;;
             }
            StringBuilder stringBuilder=new StringBuilder();
            for(int i=n;i&lt;length;i++){
             stringBuilder.append(str.charAt(i));
            }
            for(int i=0;i&lt;n;i++){
             stringBuilder.append(str.charAt(i));
            }
            return stringBuilder.toString();
        }</p>

<pre><code>    //另一种巧妙的方法，可以先将str复制在原来字符串的末尾，再截取
    public String leftRotateString2(String str, int n) {
         int len = str.length();
         if(len == 0) return "";
         n = n % len;
         str += str;
         return str.substring(n, len+n-1);
    }
}
</code></pre>

<h3>40.翻转单词序列</h3>

<p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？
    public class ReverseSentence {
         public String reverseSentence(String str) {
                 String[] strings=str.split(&ldquo; &rdquo;);
                 StringBuilder stringBuilder2=new StringBuilder();</p>

<pre><code>             if(str.trim().equals(""))return str;
             for (int i = strings.length-1; i &gt;=0; i--) {
                 if (i&gt;0) {
                     stringBuilder2.append(strings[i]+" ");
                 }else {
                     stringBuilder2.append(strings[i]);
                 }
             }
             //System.out.println(stringBuilder2.toString());
             return stringBuilder2.toString();
        }
    public static void main(String[] args) {

    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[两个相似的DP例子]]></title>
    <link href="http://ttazk.github.io/blog/2017/08/23/2dp/"/>
    <updated>2017-08-23T23:16:03+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/08/23/2dp</id>
    <content type="html"><![CDATA[<ul>
<li><p>如果一个01串任意两个相邻位置的字符都是不一样的,我们就叫这个01串为交错01串。例如: &ldquo;1&rdquo;,&ldquo;10101&rdquo;,&ldquo;0101010"都是交错01串。
小易现在有一个01串s,小易想找出一个最长的连续子串,并且这个子串是一个交错01串。小易需要你帮帮忙            求出最长的这样的子串的长度是多少。</p>

<ul>
<li>使用动态规划求解：<br>
  设f(n)为以第n个位置结尾（包含第n个元素）的最长连续交错01串的长度，则f(n-1)为以第n-1个位置结尾的长度：当                s[n]==s[n-1]时，即第n个位置与第n-1个位置的值相同，那么f(n)应该放弃前面的长度，即f(n)=1;否则f(n)=f(n-1)+1.</li>
</ul>
</li>
</ul>


<!--more--> 


<pre><code>        package test;

        import java.util.Scanner;

        public class MaxLengthOf01 {

            public static void main(String[] args) {
                 // TODO Auto-generated method stub
                 Scanner in = new Scanner(System.in);

                while (in.hasNext()) {
                    String str = in.next();
                    int n=str.length();
                    if (n==0||str==null) {
                         System.out.println(0);
                         break;
                     }
                    int[] f=new int[n];//用于存储对应位置的最长01串的长度
                 f[0]=1;
                 for(int i=1;i&lt;n;i++){
                     if (str.charAt(i)==str.charAt(i-1)) {
                         f[i]=1;
                     }
                     else {
                             f[i]=f[i-1]+1;
                         }
                 }
                 //求出f[]中最大的值，即为最大子数组的和
                 int max=f[0];
                 for(int i=0;i&lt;n;i++){
                     if (max&lt;f[i]) {
                         max=f[i];
                     }
                 }
                 System.out.println(max);
                }
            }

        }
</code></pre>

<ul>
<li><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>

<ul>
<li><p>动态规划求解：<br>
  f(i)表示以第i个数字结尾的子数组的最大和，其中0&lt;=i&lt;n。当以第i-1个数字结尾的子数组的最大和小于0时，如果把这个负数与第i个数字相加，得到的结果比第i个数字要小，所以这种情况下，以第i个数字结尾的子数组最大和就是第i个数字本身；当以第i-1个数字结尾的子数组的最大和大于0时，与第i个数字累加，就得到以第i个数字结尾的子数组的最大和。</p>

<pre><code>  package test;

  public class FindGreatestSumOfSubArray {
    //求连续子数组的最大和
    public static int findGreatestSumOfSubArray(int[] array){
    int n=array.length;
    if (n==0||array==null) {
    return 0;
    }
    int[] f=new int[n];//用于存储对应位置的最大子数组的和
    f[0]=array[0];
    for(int i=1;i&lt;n;i++){
    if (f[i-1]&lt;0) {
    f[i]=array[i];
    }
    if (f[i-1]&gt;=0) {
    f[i]=f[i-1]+array[i];
    }
    }
    //求出f[]中最大的值，即为最大子数组的和
    int max=f[0];
    for(int i=0;i&lt;n;i++){
    if (max&lt;f[i]) {
    max=f[i];
    }
    }
    return max;
    }
    public static void main(String[] args) {
    // TODO Auto-generated method stub
    System.out.println(findGreatestSumOfSubArray(new int[]{1,-2,3,10,-4,7,2,-5}));
    }

  }
</code></pre></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指Offer2]]></title>
    <link href="http://ttazk.github.io/blog/2017/08/02/jianzhioffer2/"/>
    <updated>2017-08-02T22:50:38+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/08/02/jianzhioffer2</id>
    <content type="html"><![CDATA[<h3>16.树的子结构</h3>

<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
    package test;
    //输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
    public class HasSubTree {
        class TreeNode {
            int val = 0;
            TreeNode left = null;
            TreeNode right = null;</p>

<pre><code>        public TreeNode(int val) {
            this.val = val;
        }
    }
    public static boolean hasSubtree(TreeNode root1,TreeNode root2){
         boolean result=false;
         if (root1.val==root2.val) {
             if (root1==null) {
                 return false;
             }
             if (root2==null) {
                 return true;
             }
             result=hasSubtree(root1.left, root2.left)&amp;&amp;hasSubtree(root1.right, root2.right);
         }
         if (!result) {
             result=hasSubtree(root1.left, root2);
         }
         if (!result) {
             result=hasSubtree(root1.right, root2);
         }
         return result;
    }

    public boolean doesTree1hasTree2(TreeNode root1,TreeNode root2){
         if (root1==null&amp;&amp;root2!=null) {
             return false;
         }
         if (root2==null) {
             return true;
         }
         if (root1.val!=root2.val) {
             return false;
         }
         return doesTree1hasTree2(root1.left, root2.left)&amp;&amp;doesTree1hasTree2(root1.right, root2.right);
    }
    public boolean hasSubTree2(TreeNode root1,TreeNode root2){
         boolean result=false;
         if (root1!=null&amp;&amp;root2!=null) {
             if (root1.val==root2.val) {
                 result=doesTree1hasTree2(root1, root2);
             }
             if (!result) {
                 result=hasSubTree2(root1.left, root2);
             }
             if (!result) {
                 result=hasSubTree2(root1.right, root2);
             }
         }
         return result;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<!--more-->


<h3>17.二叉树镜像</h3>

<p>操作给定的二叉树，将其变换为源二叉树的镜像。
    package test;
    //操作给定的二叉树，将其变换为源二叉树的镜像
    public class Mirror {
        class TreeNode {
            int val = 0;
            TreeNode left = null;
            TreeNode right = null;</p>

<pre><code>        public TreeNode(int val) {
            this.val = val;
        }
    }

    public void mirror(TreeNode root) {
         if (root!=null) {
        if (root.left!=null||root.right!=null) {
             TreeNode node1=root.left;
             TreeNode node2=root.right;

             root.left=node2;root.right=node1;

         }
        mirror(root.left);
        mirror(root.right);
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>18.栈的压入弹出序列</h3>

<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
    package test;</p>

<pre><code>import java.util.Stack;

//输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。
//假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，
//序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
//（注意：这两个序列的长度是相等的）
public class IsPopOrder {
    public static boolean isPopOrder(int [] pushA,int [] popA) {
          //boolean result=true;
          int length=pushA.length;
          Stack&lt;Integer&gt; stack=new Stack&lt;&gt;();
          int index=0;
          for (int i = 0; i &lt; length; i++) {
        stack.push(pushA[i]);
        //每次要判断栈顶元素与要出栈的元素是否相同，如果相同，出栈且出栈元素后移；
        //当所有元素都入栈，且与出栈元素比较之后，栈为空，则是弹出序列
            while(!stack.isEmpty()&amp;&amp;stack.peek()==popA[index]) {
                 index++;
                 stack.pop();
             }
          }
          if (stack.isEmpty()) {
             return true;
         }else {
             return false;
         }
    }
    public static void main(String[] args) {
         int[] a={1,2,3,4,5};
         int[] b={4,5,3,2,1};
         System.out.println(isPopOrder(a,b));
    }
}
</code></pre>

<h3>19.从上到下打印二叉树&mdash;广度遍历</h3>

<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。
    package test;</p>

<pre><code>import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Queue;

//从上往下打印出二叉树的每个节点，同层节点从左至右打印。
public class PrintFromToptoBottom {
    class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        public TreeNode(int val) {
            this.val = val;
        }
    }

    public ArrayList&lt;Integer&gt; printFromTopToBottom(TreeNode root) {
        ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();
        Queue&lt;TreeNode&gt; queue=new ArrayDeque&lt;&gt;();
        if (root!=null) {
            queue.offer(root);
            while (!queue.isEmpty()) {
                TreeNode temp=queue.poll();
                if (temp.left!=null) {
                    queue.offer(temp.left);
                }
                if (temp.right!=null) {
                    queue.offer(temp.right);
                }
                arrayList.add(temp.val);
            }
        }
        return arrayList;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>20.二叉搜索树后序遍历序列</h3>

<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
    package test;
    //输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
    //如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同
    public class VerifySquenceOfBST {
        public boolean verifySquenceOfBST(int [] sequence) {
            return verifySquenceOfBST(sequence,0,sequence.length-1);
        }
        public boolean verifySquenceOfBST(int [] sequence,int start,int last){
             if (sequence.length&lt;=0) {
                 return false;
             }
             //该情况是对应于，对于一个根节点来说，只有右子树，没有左子树
             //如果只有左子树，没有右子树，则下面找不到分界点
             if (last&lt;start) {
                 return true;
             }
             int temp=sequence[last];
             int index=start;//记录左右子树的分界点
             for (int i = start; i &lt; last; i++) {
                 if (sequence[i]>temp) {
                     //用该种方法找到的分界点，说明该分界点的左半边都小于根节点
                     //所以，只需要判断右子树是不是全部都大于根节点
                     index=i;
                     for(int j=i;j&lt;last;j++){
                         if (sequence[j]&lt;=temp) {
                              return false;
                         }
                     }
                     return true;
                 }
             }
             return verifySquenceOfBST(sequence, start, index-1)&amp;&amp;verifySquenceOfBST(sequence, index, last-1);
        }
        public static void main(String[] args) {
             // TODO Auto-generated method stub</p>

<pre><code>    }

}
</code></pre>

<h3>21.二叉树中和为某一值的路径&mdash;-深度遍历</h3>

<p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。
    package test;</p>

<pre><code>import java.util.ArrayList;
//输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。
//路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径
public class FindPath {
    class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        public TreeNode(int val) {
            this.val = val;
        }
    }
    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; lists=new ArrayList&lt;&gt;();//用于存储各条路径
    ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();//只是临时存储各条路径
    public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(TreeNode root,int target) {
        if (root==null) {
             return lists;
         }
        list.add(root.val);//经过每个节点就将该节点保存在路径中
        target=target-root.val;
        //当遍历到根节点，且满足目标值时，将list添加到lists中
        if (target==0&amp;&amp;root.left==null&amp;&amp;root.right==null) {
             lists.add(new ArrayList&lt;&gt;(list));//用临时存储路径的列表构造新的列表，防止干扰
         }
        findPath(root.left, target);
        findPath(root.right, target);
        list.remove(list.size()-1);//对遍历到根节点却不满足条件的路径进行回退，返回其根节点
        return lists;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>22.复杂链表的复制</h3>

<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
    package test;
    //输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，
    //另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。
    //（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）
    public class Clone {
        class RandomListNode {
            int label;
            RandomListNode next = null;
            RandomListNode random = null;</p>

<pre><code>        RandomListNode(int label) {
            this.label = label;
        }
    }
    public RandomListNode clone(RandomListNode pHead)
    {
        return pHead;
    }
    //先对链表中的每个节点进行复制，位于原节点的后面
    public void cloneNode(RandomListNode pHead1){
         RandomListNode pHead=pHead1;
         while(pHead!=null){
             RandomListNode clone=new RandomListNode(pHead.label);
             RandomListNode temp=pHead.next;//保存下一个要复制的节点
             clone.next=temp;
             pHead.next=clone;

             pHead=temp;//迭代要复制的节点
         }
    }
    //为复制的节点指明对应的random节点
    public void connectRandomNode(RandomListNode pHead1){
         RandomListNode pHead=pHead1;
         while(pHead!=null){
             if (pHead.random!=null) {
                 RandomListNode clone=pHead.next;
                 RandomListNode random=pHead.random;
                 clone.random=random.next;

             }
             pHead=pHead.next.next;//更新

         }
    }
    //把链表拆分成两个链表
    public RandomListNode reconnect(RandomListNode pHead1){
         RandomListNode pHead=pHead1;
         RandomListNode cloneHead=pHead.next;
         RandomListNode head=cloneHead;
         //同时更新两个链表的节点
         while(pHead!=null){
             pHead.next=pHead.next.next;
             if (cloneHead.next!=null) {
                 RandomListNode temp=cloneHead.next;
                 cloneHead.next=temp.next;
             }
             pHead=pHead.next;
             cloneHead=cloneHead.next;
         }
         return head;
    }
}
</code></pre>

<h3>22.二叉搜索树与双向链表</h3>

<p> 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
    package test;</p>

<pre><code>import java.util.ArrayList;

public class Convert {
    class TreeNode {
        int val = 0;
        TreeNode left = null;
        TreeNode right = null;

        public TreeNode(int val) {
            this.val = val;
        }
    }
    ArrayList&lt;TreeNode&gt; arrayList=new ArrayList&lt;&gt;();
    public TreeNode convert(TreeNode pRootOfTree) {
         if (pRootOfTree==null) {
             return null;
         }
         ArrayList&lt;TreeNode&gt; al=inorder(pRootOfTree);
         int length=al.size();
         TreeNode hNode=al.get(0);
         TreeNode tNode=al.get(al.size()-1);
         TreeNode head=hNode;head.left=null;
         TreeNode tail=tNode;tNode.right=null;

         for (int i = 1; i &lt; length; i++) {
             TreeNode temp=al.get(i);
             head.right=temp;
             head=temp;
         }
         for (int i = length-2; i &gt;=0; i--) {
             TreeNode temp=al.get(i);
             tail.left=temp;
             tail=temp;
         }
         return hNode;
    }
    public ArrayList&lt;TreeNode&gt; inorder(TreeNode pRootOfTree){
         if (pRootOfTree!=null) {
             inorder(pRootOfTree.left);
             arrayList.add(pRootOfTree);
             inorder(pRootOfTree.right);
         }
         return arrayList;
    }
}
</code></pre>

<h3>23.字符串的全排列&mdash;回溯法</h3>

<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba
    package test;</p>

<pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
//输入一个字符串,按字典序打印出该字符串中字符的所有排列。
//例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。
public class Permutation {

    ArrayList&lt;String&gt; arrayList=new ArrayList&lt;&gt;();
    public ArrayList&lt;String&gt; permutation(String str){
        /*ArrayList&lt;String&gt; arrayList2=permutation(str.toCharArray(), 0);
        //去除arrayList2中的重复元素，因为在排序的时候可能由于String中有相同的字符，所以在排序结果中产生重复的字符串
        //如aaa,排序之后只有一个aaa
        Set&lt;String&gt; set=new HashSet&lt;&gt;(arrayList2);
        ArrayList&lt;String&gt; arrayList3=new ArrayList&lt;&gt;(set);
        //Collections.sort(arrayList3);//对结果进行字典排序，因为有的题目可能要求
        return arrayList3;*/
         ArrayList&lt;String&gt; arrayList2=permutation(str.toCharArray(), 0);
         Collections.sort(arrayList2);
         return arrayList2;
    }
    public ArrayList&lt;String&gt; permutation(char[] chars,int index){
        int length=chars.length;
        //index代表将要交换的字符的位置,from 0 to length-1
        if (index==length-1) {
            arrayList.add(new String(chars));
        }
        else {
            for(int i=index;i&lt;length;i++){
                //当第index(index!=i)字符与第i个字符相同时，没必要交换
                if (i!=index&amp;&amp;chars[i]==chars[index]) {
                    continue;
                }
                //将字符串中第index位置的字符，分别与后面的第i个字符交换
                char temp=chars[index];
                chars[index]=chars[i];
                chars[i]=temp;

                //递归对新生成的字符串进行排序，交换的字符位置为index+1
                permutation(chars, index+1);

                //将刚才交换的字符再交换回来，使字符串恢复原样，便于与第i+1个字符交换
                char temp1=chars[index];
                chars[index]=chars[i];
                chars[i]=temp1;
            }
        }
        return arrayList;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>24.数组中出现次数超过一半的数字</h3>

<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
    package test;</p>

<pre><code>import java.util.Arrays;
import java.util.HashMap;

public class MoreThanHalfNum {
    public static int moreThanHalfNum(int[] array){
        Arrays.sort(array);
        int count=1;
        for (int i = 1; i &lt; array.length; i++) {
            int a=array[i];
            if (array[i]==array[i-1]) {
                count++;
            }else {
                count=1;
            }
            if (count&gt;array.length/2) {
                return a;
            }
        }
        return -1;
    }
    public static int moreThanHalfNum2(int[] array){
        Arrays.sort(array);
        int count=0;
        for (int i = 0; i &lt; array.length; i++) {
            if (array[i]==array[array.length/2]) {
                count++;
            }
        }
        if (count&gt;array.length/2) {
            return array[array.length/2];
        }
        return -1;
    }
    //使用HashMap
    public static int moreThanHalfNum3(int[] array){
        HashMap&lt;Integer, Integer&gt; hashMap=new HashMap&lt;&gt;();
        for (int i = 0; i &lt; array.length; i++) {
            Integer count=hashMap.get(array[i]);
            if (count==null) {
                hashMap.put(array[i], 1);
            }
            else {
                hashMap.put(array[i], count+1);
            }
            if (hashMap.get(array[i])&gt;array.length/2) {
                return array[i];
            }
        }
        return 0;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] array={1,2,3,4,3,3,3,0,0,0,0,0,3,3,3,3,33,3,3,3,3};
        System.out.println(moreThanHalfNum3(array));
        System.out.println(moreThanHalfNum(array));
    }

}
</code></pre>

<h3>25.最小的k个数</h3>

<p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
    package test;</p>

<pre><code>import java.util.ArrayList;
import java.util.PriorityQueue;
//输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
public class GetLeastNumbers {

     public ArrayList&lt;Integer&gt; getLeastNumbers(int [] input, int k) {
         if(k&gt;input.length||k&lt;=0){return new ArrayList&lt;Integer&gt;();}
         PriorityQueue&lt;Integer&gt; priorityQueue=new PriorityQueue&lt;&gt;(k);
         for(int i=0;i&lt;k;i++){
             priorityQueue.add(input[i]);
         }
         for (int i = k; i &lt; input.length; i++) {
            if (input[i]&lt;max(priorityQueue)) {
                priorityQueue.remove(max(priorityQueue));
                priorityQueue.add(input[i]);
            }
        }
         ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();
         for(int i=0;i&lt;k;i++){
             arrayList.add(priorityQueue.poll());
         }
         return arrayList;
     }
     public int max(PriorityQueue&lt;Integer&gt; priorityQueue){
         Object[] array=priorityQueue.toArray();
         int max=0;
         for (int i = 0; i &lt; array.length; i++) {
            if ((Integer)array[i]&gt;max) {
                max=(Integer)array[i];
            }
        }
         return max;
     }
}
</code></pre>

<h3>26.连续子数组最大和</h3>

<p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)
    package test;</p>

<pre><code>import java.util.ArrayList;
import java.util.Scanner;

public class FindGreatestSumOfSubArray {
    //求连续子数组的最大和
    public static int findGreatestSumOfSubArray(int[] array){
        int n=array.length;
        if (n==0||array==null) {
            return 0;
        }
        int[] f=new int[n];//用于存储对应位置的最大子数组的和
        f[0]=array[0];
        for(int i=1;i&lt;n;i++){
            if (f[i-1]&lt;0) {
                f[i]=array[i];
            }
            if (f[i-1]&gt;=0) {
                f[i]=f[i-1]+array[i];
            }
        }
        //求出f[]中最大的值，即为最大子数组的和
        int max=f[0];
        for(int i=0;i&lt;n;i++){
            if (max&lt;f[i]) {
                max=f[i];
            }
        }
        return max;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        System.out.println(findGreatestSumOfSubArray(new int[]{1,-2,3,10,-4,7,2,-5}));
        Scanner scanner=new Scanner(System.in);
        ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;&gt;();
        while(scanner.hasNext()){
            int num=scanner.nextInt();
            arrayList.add(num);
        }
        int[] array=new int[arrayList.size()];
        for (int i = 0; i &lt; arrayList.size(); i++) {
            array[i]=arrayList.get(i);
        }
        System.out.println(findGreatestSumOfSubArray(array));
    }

}
</code></pre>

<h3>27.整数中1出现的次数</h3>

<p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>

<pre><code>package test;
//求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
//为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。
//ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。
public class NumberOf1Between1AndN {
    public int numberOf1Between1AndN(int n) {
        int sum=0;
        for(int i=0;i&lt;=n;i++){
        sum=sum+sumOfn(i);
        }
        return sum;
    }
    //先求每个整数中1的个数
    public int sumOfn(int n){
         int sum=0;
         while(n&gt;0){
             //对n的每一位进行判断，统计1的个数
             if (n%10==1) {
                 sum++;
                 n=n/10;
             }
             else {
                 n=n/10;
             }
         }
         return sum;
    }
}
</code></pre>

<h3>28.把数组排成最小的数</h3>

<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
    //定义一种新的排序规则
    package test;</p>

<pre><code>//数组拼接的最小值
public class PrintMinNumber {
    public static boolean compare(int m,int n){
         String m1=String.valueOf(m);
         String n1=String.valueOf(n);
         String str1=m1+n1;
         String str2=n1+m1;
         if (Long.valueOf(str1)&lt;Long.valueOf(str2)) {
             return true;
         }
         return false;
    }
    public static void swap(int[] array,int m,int n){
         int temp=array[m];
         array[m]=array[n];
         array[n]=temp;
    }
    public static String printMinNumber(int[] numbers){
         //int[] temp=new int[numbers.length];
         for (int i = 0; i &lt; numbers.length; i++) {
             int min=i;
             for (int j = i+1; j &lt; numbers.length; j++) {
                 if (compare(numbers[j], numbers[min])) {
                     min=j;
                 }
             }
             swap(numbers, min, i);
             //temp[i]=min;
         }
         StringBuffer stringBuffer=new StringBuffer();
         for (int i = 0; i &lt; numbers.length; i++) {
             stringBuffer.append(numbers[i]);

         }
         return stringBuffer.toString();
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] numbers={3,32,321,1,4,1};
        System.out.println(printMinNumber(numbers));
    }

}
</code></pre>

<h3>29.丑数</h3>

<p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>

<pre><code>package test;
//把只包含素因子2、3和5的数称作丑数（Ugly Number）。
//例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数
public class GetUglyNumber {
    //判断一个整数n是否只能被2整除，则将n连续除以2，如果最后结果为1，则只能被2整除
    //同样，判断一个数是否只能被2,3,5整除，将其连续地除以2,3,5，如果结果为1，则只包含因子2,3,5
    public boolean isUgly(int n){
         while(n&gt;1){
             while(n%2==0){
                 n=n/2;
             }
             while(n%3==0){
                 n=n/3;
             }
             while(n%5==0){
                 n=n/5;
             }
         }
         return n==1?true:false;
    }
    public int getUglyNumber(int index){
         int count=0;
         int i=0;
         while(count&lt;index){
             i++;
             if(isUgly(i)){
                 count++;
                 /*if (count==index) {
                     return i;
                 }*/
             }
             //i++;
         }
         return i;
    }
    //上面的时间复杂度太大，下面使用DP来进行简化
    //每个丑数都是由其他丑数乘以2,3,5得到的，现在将丑数按照顺序保存在数组中，
    //在更新下个丑数时，由前面的丑数乘以2,3,5得到，所以关键是如何从前面的丑数中选取
    public int getUglyNumber1(int index){
         if (index&lt;=0) {
             return 0;
         }
         if (index==1) {
             return 1;
         }
         int[] dp=new int[index];//保存丑数的数组
         dp[0]=1;
         int t2=0,t3=0,t5=0;//t2,t3,t5用来记录当计算下一个丑数时，应该从前面选取的丑数的位置(可以乘2、乘3或乘5的最小丑数)
         for(int i=1;i&lt;index;i++){
             dp[i]=min(dp[t2]*2, min(dp[t3]*3, dp[t5]*5));//计算下一个丑数
             //更新t2,t3,t5的位置
             if (dp[i]==dp[t2]*2) {
                 t2++;
             }
             if (dp[i]==dp[t3]*3) {
                 t3++;
             }
             if (dp[i]==dp[t5]*5) {
                 t5++;
             }
         }
         return dp[index-1];
    }
    public int min(int a,int b){
         return a&lt;b?a:b;
    }
}
</code></pre>

<h3>30.第一个只出现一次的字符</h3>

<p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p>

<pre><code>import java.util.HashMap;
public class Solution {
    public int FirstNotRepeatingChar(String str) {
        HashMap&lt;Character, Integer&gt; hashMap=new HashMap&lt;&gt;();
        for (int i = 0; i &lt; str.length(); i++) {
            hashMap.put(str.charAt(i), null);
        }
        for (int i = 0; i &lt; str.length(); i++) {
            Integer count=hashMap.get(str.charAt(i));
            if (count==null) {
                count=1;
                hashMap.put(str.charAt(i), count);
            }
            else {
                count++;
                hashMap.put(str.charAt(i), count);
            }
        }
        int first = -1;
        for (int i = 0; i &lt; str.length(); i++) {
            int count=hashMap.get(str.charAt(i));
            if (count==1) {
                first=i;
                break;
            }
        }
        return first;
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见排序及两个经典DP]]></title>
    <link href="http://ttazk.github.io/blog/2017/08/02/sortanddp/"/>
    <updated>2017-08-02T21:32:12+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/08/02/sortanddp</id>
    <content type="html"><![CDATA[<h3>1.插入排序</h3>

<pre><code>package Sort;

public class InsertSort {
    //将后面的元素与前面的有序元素进行比较，找到合适的位置进行插入
    public static void insertSort(int[] array){
         for (int i = 0; i &lt; array.length-1; i++) {
             for (int j = i+1; j &gt;0 &amp;&amp; array[j]&lt;array[j-1]; j--) {
                 int temp=array[j];
                 array[j]=array[j-1];
                 array[j-1]=temp;
             }
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] array={2,4,1,667,32,5,90,66,12,9,31};
         insertSort(array);
         for(int a:array){
             System.out.print(a+" ");
         }
    }

}
</code></pre>

<!--more-->


<h3>2.归并排序</h3>

<pre><code>package Sort;

public class MergeSort {
    private static int[] temp;//临时数组，长度与要排序的数组长度相同
    public static void sort(int[] array){
         temp=new int[array.length];
         mergeSort(array, 0, array.length-1);
    }
    public static void mergeSort(int[] array,int low,int high){

         if (low&gt;=high) {
             return;
         }
         int mid=(high+low)/2;
         mergeSort(array, low, mid);//对左半边进行排序
         mergeSort(array, mid+1, high);//对右半边进行排序
         merge(array, low, mid, high);//归并
    }
    //原地归并
    public static  void merge(int[] array,int low,int mid,int high){
         for(int i=low;i&lt;=high;i++){
             temp[i]=array[i];//将待排序的元素复制到临时数组中
         }
         int m=low;int n=mid+1;//标记待归并的两个起始位置,这两个位置是在临时数组中的位置

         for(int i=low;i&lt;=high;i++){
             //将临时数组中的元素按顺序归并到原数组中
             //前两个判断一定要放在后两个判断之前
             if (m&gt;mid){
                 array[i]=temp[n];
                 n++;
             }
             else if(n&gt;high){
                 array[i]=temp[m];
                 m++;
             }
             else if(temp[m]&lt;temp[n]) {
                 array[i]=temp[m];
                 m++;
             }
             else{
                 array[i]=temp[n];
                 n++;
             }

         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] array={23,4,1,67,32,5,90,66,12,9,31};
         sort(array);
         for(int a:array){
             System.out.print(a+" ");
         }
    }

}
</code></pre>

<h3>3.快速排序</h3>

<pre><code>package Sort;

public class QuickSort {

    public static void sort(int[] array,int low,int high){
         if (low&gt;=high) {
             return;
         }
         int j=partition(array, low, high);//找出分界点
         sort(array, low, j-1);//对左半边排序
         sort(array, j+1, high);//对右半边排序
    }
    public static int partition(int[] array,int low,int high){
         int i=low;
         int j=high+1;
         int a=array[low];
         while(true){
             while(array[++i]&lt;=a){
                 if (i&gt;=high) {
                     break;
                 }
             }
             while(array[--j]&gt;=a){
                 if (j&lt;=low) {
                     break;
                 }
             }
             //当两个元素相遇
             if (i&gt;=j) {
                 break;
             }
             swap(array, i, j);
         }
         swap(array, low, j);
         return j;
    }
    public static void swap(int[] array,int i,int j){
         int temp=array[i];
         array[i]=array[j];
         array[j]=temp;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] a={2,3,2,1,4,4,3,2,1,23,0,4,2};
         sort(a, 0, a.length-1);
         for (int i = 0; i &lt; a.length; i++) {
             System.out.print(a[i]+" ");
         }
    }

}
</code></pre>

<h3>4.选择排序</h3>

<pre><code>package Sort;

public class SelectSort {

    public static void selectSort(int[] array){
         int length=array.length;
         for (int i = 0; i &lt; length; i++) {
             int min=i;//用于记录最小值的位置
             for (int j = i+1; j &lt; array.length; j++) {
                 if (array[min]&gt;array[j]) {
                     min=j;
                 }
             }
             //将剩余数组的最小值与左边的元素交换
             {
                 int temp=array[i];
                 array[i]=array[min];
                 array[min]=temp;
             }
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] array={2,4,1,67,32,5,66,12,9,31};
         selectSort(array);
         for(int a:array){
             System.out.print(a+" ");
         }
    }

}
</code></pre>

<h3>5.希尔排序</h3>

<pre><code>package Sort;

public class ShellSort {
    public static void shellsort(int[] array){
         int h=1;
         int n=array.length;
         while(h&lt;n/3) h=3*h+1;//确定间隔
         while(h&gt;=1){
             for(int i=0;i&lt;n-h;i++){
                 for(int j=i+h;j&gt;h-1 &amp;&amp; array[j]&lt;array[j-h];j=j-h){
                     int temp=array[j];
                     array[j]=array[j-h];
                     array[j-h]=temp;
                 }
             }
             h=h/3;//不断缩小间隔
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] array={2,4,1,67,32,5,90,66,12,9,31};
         shellsort(array);
         for(int a:array){
             System.out.print(a+" ");
         }
    }

}
</code></pre>

<h3>6.实现堆</h3>

<pre><code>package algorithm;

import java.util.Arrays;

public class Heap {
    private int[] heap=new int[9];//假定堆长度不超过50
    private int n=0;//用来记录堆的位置,存储数据时不使用heap[0]位置，从heap[1],heap[2]...heap[49]

    public void swap(int[] heap,int a,int b){
         int temp=heap[a];
         heap[a]=heap[b];
         heap[b]=temp;
    }
    public boolean isEmpty(){
         return n==0;
    }
    //元素上浮
    public void swim(int k){
         //k表示元素的索引
         while(k&gt;1){
             if (heap[k]&gt;heap[k/2]) {
                 //将元素与其父节点交换
                 swap(heap, k, k/2);
             }
             k=k/2;
         }
    }
    //元素下沉
    public void sink(int k){
         while(2*k&lt;=n){
             int i=2*k;
             if (heap[i]&lt;=heap[i+1]) {
                 i++;//记录较大子节点的位置
             }
             if (heap[k]&gt;=heap[i]) {
                 break;//要下沉的节点不比子节点小，退出
             }
             swap(heap, k, i);
             k=i;
         }
    }
    //向堆中插入元素
    public void insert(int value){
         n++;//增大堆的位置
         heap[n]=value;//将要插入的值放在最后
         swim(n);//将该元素上浮以维持堆
    }
    //删除最大元素
    public int deleteMax(){
         int max=heap[1];
         swap(heap, 1, n);//将最大值与最后一个位置的值交换，即将最后一个元素放在首位
         heap[n]=0;//删除最后一个元素
         n--;
         sink(1);
         return max;
    }

    //堆排序,每次都将最大元素放到最后面，然后再维护堆
    public void heapSort(int[] array){
         for (int i = 0; i &lt; array.length; i++) {
             insert(array[i]);//构造堆
         }
         while(n&gt;1){
         swap(heap, 1, n);
         n--;
         sink(1);//不能使用这个方法
         }
         for (int i = 0; i &lt; array.length; i++) {
             array[i]=heap[i+1];
         }
    }
    public static void main(String[] args) {
         Heap heap=new Heap();
         heap.insert(3);
        heap.insert(2);heap.insert(20);heap.insert(43);heap.insert(9);heap.insert(16);heap.insert(80);heap.insert(7);
         while(!heap.isEmpty()){
             System.out.print(heap.deleteMax()+" ");
         }
         int[] array={22,1,2,3,56,9,8,20};
         heap.heapSort(array);
        System.out.println(Arrays.toString(array));
    }
}
</code></pre>

<h3>7.最长公共子序列</h3>

<pre><code>package algorithm;

public class LCS {
    public static int[][] lcs(String str1,String str2){
         int i=str1.length();
         int j=str2.length();
         int[][] m=new int[i+1][j+1];//该数组表示最优解的情况下，子序列的长度
         for(int a=0;a&lt;i+1;a++){
             m[a][0]=0;
         }
         for(int b=0;b&lt;j+1;b++){
             m[0][j]=0;
         }
         for(int a=1;a&lt;i+1;a++){
             for(int b=1;b&lt;j+1;b++){
                 if (str1.charAt(a-1)==str2.charAt(b-1)) {
                     m[a][b]=m[a-1][b-1]+1;
                 }
                 else{
                     if (m[a-1][b]&gt;=m[a][b-1]) {
                          m[a][b]=m[a-1][b];
                     }else {
                          m[a][b]=m[a][b-1];
                     }
                 }
             }
         }
         return m;
    }
    public static void print(int[][] m,String str1,String str2,int i,int j){
         if (i==0||j==0) {
             return;
         }
         if (str1.charAt(i-1)==str2.charAt(j-1)) {
             print(m, str1, str2, i-1, j-1);
             System.out.print(str1.charAt(i-1));
         }
         else {
             if (m[i-1][j]&gt;=m[i][j-1]) {
                 print(m, str1, str2, i-1, j);
             }
             else {
                 print(m, str1, str2, i, j-1);
             }
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         String str1="ABCBDAB";
         String str2="BDCABA";
         int[][] m=lcs(str1, str2);
         for (int i = 0; i &lt; m.length; i++) {
             for (int j = 0; j &lt; m[0].length; j++) {
                 System.out.print(m[i][j]+" ");
             }
             System.out.println();
         }
         print(m, str1, str2, 7, 6);
    }

}
</code></pre>

<h3>8.01背包问题</h3>

<pre><code>package algorithm;

import java.util.Arrays;

public class Package_01 {

    public static int[][] package_01(int[] weight,int[] value,int c){
         int n=weight.length;
         int[][] m=new int[n+1][c+1];//作为记录的表格,其中的值表示最优解情况下价值的值
         for (int k = 0; k &lt; n+1; k++) {
             m[k][0]=0;//第一列置于0
         }
         for(int k=0;k&lt;c+1;k++){
             m[0][k]=0;//第一行置于0
         }
         //注意，物品的编号是从0,1,2,,,n
         for(int k=1;k&lt;n+1;k++){
             for(int l=1;l&lt;c+1;l++){
                 m[k][l]=m[k-1][l];//先假设第k件物品(weight[k-1],value[k-1])不放进去
                 if (weight[k-1]&lt;=l) {
                     //如果第k件物品(weight[k-1],value[k-1])能够放进去，考虑放进去与不放进去的比较，选择较大的
                     if (value[k-1]+m[k-1][l-weight[k-1]]&gt;m[k-1][l]) {
                         m[k][l]=value[k-1]+m[k-1][l-weight[k-1]];
                     }
                 }
             }
         }

         return m;
    }
    public static int[] build(int[][] m,int c,int[] weight){
         int[] x=new int[weight.length];
         for(int i=weight.length;i&gt;=1;i--){
             if (m[i][c]==m[i-1][c]) {
                 x[i-1]=0;
             }
             else {
                 x[i-1]=1;
                 c=c-weight[i-1];
             }
         }
         return x;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] w={2,3,4,5};
         int[] v={3,4,5,7};
         int c=9;
         int[][] m=package_01(w, v, c);
         for (int i = 0; i &lt; m.length; i++) {
             for (int j = 0; j &lt; m[0].length; j++) {
                 System.out.print(m[i][j]+" ");
             }
             System.out.println();
         }
         int[] a=build(m, c, w);
         System.out.println(Arrays.toString(a));
    }

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指offer1]]></title>
    <link href="http://ttazk.github.io/blog/2017/08/02/jianzhioffer1/"/>
    <updated>2017-08-02T21:31:37+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/08/02/jianzhioffer1</id>
    <content type="html"><![CDATA[<h3>1.二维数组中的查找</h3>

<p>   在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数,输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>

<pre><code>        * 在一个二维数组中查找一个整数，数组是从左向右，从上向下递增
        * 分析：
        * 对于无序的数组，我们可以一行一行地进行比较，时间复杂度为O(n*n)
        * 由于该数组有序，按照一般的比较思路，我们一般从左上角到又开始比较，如果当前数字比待查找值小，则向右或者
        * 向下继续查找，这样的话便不容易进行选择。因此，我们可以尝试从右上角向左进行排查/从左下角向右进行排查，这样就不会像刚才一样
        * 面临两种选择，从而使问题简化。
        * 从左下角向右进行排查：如果当前数字比待查找值大，则向上进行查找（同时摈弃最下面一行，因为最下面一行的数字都比左下角的大）
        * 如果当前数字比待查找值小，则向右进行查找（同时摈弃该列，因为该列往上的数字都比待查找值小）
        *
        public class Question3 {

            //从左下角向右进行排查
            public static boolean findInArray(int[][] array,int a){
                if (array==null) {
                    return false;
                }
                int row=array.length-1;
                int column=array[0].length-1;


                int i=row,j=0;
                while(i&gt;=0&amp;&amp;j&lt;=column){
                    if (array[i][j]&gt;a) {
                        System.out.print(array[i][j]+" ");
                        i--;//往上走
                    }
                    else if (array[i][j]&lt;a) {
                        System.out.print(array[i][j]+" ");
                        j++;//往右走
                    }else {
                        System.out.print(array[i][j]+" ");
                        return true;
                    }
                }

                return false;
            }
            public static void main(String[] args) {
                int[][] array={.{1,2,3,4},{2,3,4,5},{3,4,5,6,},{4,5,6,7}.};
                System.out.println(findInArray(array, 3));
                //System.out.println(findInArray(array, 9));
            }

        }
        --------------------------------------------------------------------------------------------
        public class Solution {
            public boolean Find(int target, int [][] array) {
                int i=0;
                int j=array[0].length-1;
                while(i&lt;=array.length-1&amp;&amp;j&gt;=0){
                    if (array[i][j]==target) {
                        return true;
                    }
                    else if(target&gt;array[i][j]){
                        i++;
                    }
                    else{
                        j--;
                    }
                }
                return false;
            }
        }
</code></pre>

<!-- more -->


<h3>2.替换空格</h3>

<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>

<pre><code>        public class Solution {
        //从后向前复制
            public static String replaceSpace(StringBuffer stringBuffer){
                 int oldIndex=stringBuffer.length()-1;
                 int count=0;
                 for (int i = 0; i &lt; stringBuffer.length(); i++) {
                     if (stringBuffer.charAt(i)==' ') {
                         count++;
                     }
                 }
                 int newIndex=oldIndex+count*2;
                 stringBuffer.setLength(newIndex+1);
                 for(;oldIndex&gt;=0;oldIndex--){
                     if (stringBuffer.charAt(oldIndex)==' ') {
                         stringBuffer.setCharAt(newIndex--, '0');
                         stringBuffer.setCharAt(newIndex--, '2');
                         stringBuffer.setCharAt(newIndex--, '%');
                     }else{
                         stringBuffer.setCharAt(newIndex--, stringBuffer.charAt(oldIndex));
                     }
                 }
                 return stringBuffer.toString();
            }

        }
</code></pre>

<h3>3.从尾到头打印链表</h3>

<p>   输入一个链表，从尾到头打印链表每个节点的值。</p>

<pre><code>package test;

class Node{
    private Node next;
    private int value;
    public Node getNext() {
         return next;
    }
    public void setNext(Node next) {
         this.next = next;
    }
    public int getValue() {
         return value;
    }
    public void setValue(int value) {
         this.value = value;
    }

}
public class PrintFromTailToHead {
    //可以使用栈来实现，访问一个节点时就入栈，根据栈的特点，输出时已经反向
    //递归本身就相当于栈结构
    //为了实现反向输出，每访问一个节点，先输出它的下一个节点，再输出自身
    public static void printFromTailtoHead(Node node){
         if (node!=null) {
             printFromTailtoHead(node.getNext());
             System.out.print(node.getValue()+" ");
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         for (int i = 0; i &lt; 10; i++) {

         }
         Node node1=new Node();node1.setValue(4);
         Node node2=new Node();node2.setValue(6);
         Node node3=new Node();node3.setValue(12);
         Node node4=new Node();node4.setValue(8);
         Node node5=new Node();node5.setValue(1);
         Node node6=new Node();node6.setValue(3);
        node1.setNext(node2);node2.setNext(node3);node3.setNext(node4);node4.setNext(node5);node5.setNext(node6);node6.setNext(null);
         printFromTailtoHead(node1);
    }

}
</code></pre>

<h3>4.重建二叉树</h3>

<p>   输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
        package test;</p>

<pre><code>    class TreeNode {
         int val;
         TreeNode left;
         TreeNode right;
         TreeNode(int x) { val = x; }
         }
    public class RebuildBinaryTree {
         public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
                return reConstructBinaryTree(pre, 0, pre.length-1, in, 0, in.length-1);
         }
         public TreeNode reConstructBinaryTree(int[] pre,int preStart,int preEnd,int[] in,int inStart,int inEnd) {
                if (preStart&gt;preEnd||inStart&gt;inEnd) {
                     return null;
                 }
                TreeNode root=new TreeNode(pre[preStart]);//以先序遍历的第一个点构造根节点
                //遍历中序数组，找到根节点的位置，根节点的左半部分为左子树，根节点的右半边为右子树
                //再根据左右子树的长度将先序数组划分成两个数组，分别对应左右子树的先序遍历
                for (int i = inStart; i &lt;= inEnd; i++) {
                     if (in[i]==pre[preStart]) {//记录根节点在中序数组的位置
                         root.left=reConstructBinaryTree(pre, preStart+1, preStart+i-inStart, in, inStart, i-1);
                         root.right=reConstructBinaryTree(pre, preStart+i-inStart+1, preEnd, in, i+1, inEnd);
                     }
                 }
                return root;
            }
        public static void main(String[] args) {
             // TODO Auto-generated method stub

        }

    }
</code></pre>

<h3>5.用两个栈实现队列</h3>

<p>   用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>

<pre><code>    package test;

    import java.util.Stack;

    public class StackToQueue {
        //第一个栈用于压入，第二个栈用于弹出
        static Stack&lt;Integer&gt; stack1=new Stack&lt;&gt;();
        static Stack&lt;Integer&gt; stack2=new Stack&lt;&gt;();
        public static void push(int node){
             stack1.push(node);
        }
        public static int pop(){

             if (!stack2.isEmpty()) {
                 int first=stack2.pop();
                 return first;
             }else{
                 while(!stack1.isEmpty()){
                     int temp=stack1.pop();
                     stack2.push(temp);
                 }
                 return pop();
             }
        }
        public static void main(String[] args) {
             // TODO Auto-generated method stub
             push(1);push(2);push(3);
             System.out.print(pop()+" ");
             System.out.print(pop()+" ");
             System.out.print(pop()+" ");
        }

    }
</code></pre>

<h3>6.旋转数组的最小数字</h3>

<p>   把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>

<pre><code>import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
    int low=0;
        int high=array.length-1;
        while(low&lt;=high){
            if (high-low==1) {
                return array[high];
            }
            int mid=(low+high)/2;
            if (array[mid]&lt;=array[high]) {
                high=mid;
            }
            else if (array[mid]&gt;=array[high]) {
                low=mid;
            }
        }
        return -1;
    }
}
</code></pre>

<h3>7.斐波那契数</h3>

<p>   大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p>

<pre><code>package test;

public class Fibonacci {
    //使用递归占用内存太大；计算也会出问题，所以应该选择循环
    public static int fibonacci(int n) {
        if(n==1||n==2){
            return 1;
        }
        else if(n&gt;2){
            return fibonacci(n-2)+fibonacci(n-1);
        }
        else
            return 0;
    }
    public static int fibonacci_2(int n){
        if (n==1||n==2) {
            return 1;
        }
        else if (n&gt;2) {
            int a=1,b=1,c=0;
            for(int i=3;i&lt;=n;i++){
                c=a+b;
                a=b;
                b=c;
            }
            return c;
        }
        else {
            return 0;
        }
    }
    //思考使用递归求解动态规划导致时间复杂度为指数的原因是子问题重叠，需要重复计算子问题
    //那么动态规划自顶向下的思路是在递归的基础上添加备忘机制,所以这题也可以在递归的基础上添加备忘机制
    //但是，也可以采用自底向上的思路，建立数组存储子问题的解，再求解原问题的解
    public static int fibonacci3(int n){
        int[] array=new int[n+1];
        array[0]=0;
        array[1]=1;
        for(int i=2;i&lt;n+1;i++){
            array[i]=array[i-1]+array[i-2];
        }
        return array[n];
    }
    public static void main(String[] args) {
        System.out.println(fibonacci(10));
        System.out.println(fibonacci_2(20));
    }
}
</code></pre>

<h3>8.跳台阶</h3>

<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>

<pre><code>    package test;

    public class JumpFloor {
        //青蛙跳n阶台阶，一次可以跳1,2,3,4...n阶，求有多少种跳法
        //等同于斐波那契数
        //f(n)=f(n-1)+f(n-2)
        public static int jumpFloor(int target){
            int[] array=new int[target+1];
            array[0]=0;
            array[1]=1;
            for(int i=2;i&lt;target+1;i++){
                array[i]=array[i-1]+array[i-2];
            }
            return array[n];

             return array[target];
        }
        public static void main(String[] args) {
             // TODO Auto-generated method stub
             System.out.println(jumpFloor(4));
        }

    }
</code></pre>

<h3>9.变态跳台阶</h3>

<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>

<pre><code>package test;

public class JumpFloor {
    //青蛙跳n阶台阶，一次可以跳1,2,3,4...n阶，求有多少种跳法
    //f(n)=f(n-1)+f(n-2)+...f(1)=2*f(n-1)
    public static int jumpFloor(int target){
         if (target==1) {
             return 1;
         }
         int[] array=new int[target+1];//用来存储n的各个值的情况下的值
         array[0]=1;
         array[1]=1;
         for (int i = 2; i &lt;=target; i++) {
             array[i]=0;
             //当前位置的值等于前面所有元素的和
             for(int j=0;j&lt;i;j++){
                 array[i]=array[i]+array[j];
             }
         }
         return array[target];
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         System.out.println(jumpFloor(4));
    }

}
</code></pre>

<h3>10.矩形覆盖</h3>

<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>

<pre><code>public class Solution {
     //类似于斐波那契数，考虑第一步是竖着覆盖，还是横着覆盖
    public int RectCover(int target) {
        if(target==1){return 1;}
        else if(target==2){return 2;}
        else if(target&gt;=3){
            return RectCover(target-2)+RectCover(target-1);
        }
        else{return 0;}
    }
}
</code></pre>

<h3>11.二进制中1的个数</h3>

<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>

<pre><code>public class Solution {
    public int NumberOf1(int n) {
        int count=0;
        while(n!=0){
            n=n&amp;(n-1);
            count++;
        }
        return count;
    }
}
</code></pre>

<h3>12.调整数组的顺序使奇数位于偶数之前</h3>

<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>

<pre><code>package test;

import java.util.ArrayList;
import java.util.Arrays;

public class ReOrderArray {

    public static void reOrderArray(int[] array){
        int n=array.length;
        //int[] array1=new int[n];
        //int[] array2=new int[n];
        ArrayList&lt;Integer&gt; arrayList1=new ArrayList&lt;&gt;();
        ArrayList&lt;Integer&gt; arrayList2=new ArrayList&lt;&gt;();
        for(int i=0;i&lt;n;i++){
            if (array[i]%2!=0) {
                arrayList1.add(array[i]);
            }
        }
        for(int i=0;i&lt;n;i++){
            if (array[i]%2==0) {
                arrayList2.add(array[i]);
            }
        }
        for (int i = 0; i &lt; arrayList1.size(); i++) {
            array[i]=arrayList1.get(i);
        }
        for (int i = 0; i &lt; arrayList2.size(); i++) {
            array[i+arrayList1.size()]=arrayList2.get(i);
        }
    }
    //这种解法类似于快排,不太稳定
    //这种方法没有保证奇数之间位置相对不变，如1,2,3,4,5,6,7
    public static void reOrderArray2(int[] array){
        int low=0;
        int high=array.length-1;
        while(low&lt;high){
            while(array[low]%2!=0&amp;&amp;low&lt;array.length){
                low++;
            }
            while(array[high]%2==0&amp;&amp;high&gt;=0){
                high--;
            }
            if (low&lt;=high) {
                int temp=array[low];
                array[low]=array[high];
                array[high]=temp;
            }
        }
    }

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] array=new int[]{1,2,3,4,5,6,7};
        reOrderArray2(array);
        System.out.println(Arrays.toString(array));

    }

}
</code></pre>

<h3>13.链表中倒数第k个节点</h3>

<p>输入一个链表，输出该链表中倒数第k个结点。</p>

<pre><code>package test;
//输入一个链表，输出该链表中倒数第k个结点。
class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
public class FindKthToTail {
    public static ListNode findKthTail(ListNode head,int k){
         //用于判断比较极端的情况
         if (head==null||k&lt;=0) {
             return null;
         }
         int count=0;
         ListNode tail=head;
         while(count&lt;k-1){
             if (tail.next!=null) {
                 tail=tail.next;//先找到从表头起，第k个节点
                 count++;
             }
             else {
                 return null;//如果链表的总节点数小于k，则退出
             }
         }
         //两个指针同时往后移动，当后面的指针到末尾时，前面的指针正好位于倒数第k个节点的位置
         while(tail.next!=null){
             tail=tail.next;
             head=head.next;
         }
         return head;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>14.反转链表</h3>

<p>输入一个链表，反转链表后，输出链表的所有元素。</p>

<pre><code>package test;
//输入一个链表，反转链表后，输出链表的头结点
//不是说直接反向输出链表（PrintFromTailtoHead）

//ps:当我们用一个指针遍历链表不能解决问题时，可以尝试使用2,3个指针

public class ReverList {
    class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }
    public static ListNode reverseList(ListNode head){
         if (head==null) {
             return null;
         }
         ListNode h,i,j;//用三个指针遍历链表，其中i代表当前正在遍历的节点，h,j分别代表前后的节点
         h=null;i=head;j=null;
         //前两个指针用来更新链表，后一个指针只是用来保存下个节点，防止链表断开，前两个节点才是用来更新链表
         while(i!=null){
             j=i.next;//先保存当前节点的下个节点，防止链表断开

             i.next=h;//更改当前节点的下个节点，使链表翻转

             //迭代更新当前节点与前一个节点
             h=i;
             i=j;

         }
         return h;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>15.合并两个排序的链表</h3>

<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>

<pre><code>package test;
//输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
public class MergeList {
    class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }
    //出现错误，返回的是合并之后的最后一个节点
    public ListNode merge(ListNode list1,ListNode list2){
         ListNode temp=null;
         while(list1!=null||list2!=null){
             if (list1==null) {
                 temp.next=list2;
                 list2=list2.next;
             }
             else if (list2==null) {
                 temp.next=list1;
                 list1=list1.next;
             }
             else if (list1.val&lt;list2.val) {
                 temp.next=list1;
                 list1=list1.next;
             }
             else {
                 temp.next=list2;
                 list2=list2.next;
             }
             temp=temp.next;
         }
         return temp;
    }

    public ListNode merge2(ListNode list1,ListNode list2){
         ListNode temp=null;
         if (list1==null) {
             return list2;
         }
         if (list2==null) {
             return list1;
         }
         if (list1.val&lt;list2.val) {
             temp=list1;
             temp.next=merge2(list1.next, list2);
         }
         else {
             temp=list2;
             temp.next=merge2(list1, list2.next);
         }
         return temp;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
    }

}
</code></pre>
]]></content>
  </entry>
  
</feed>
