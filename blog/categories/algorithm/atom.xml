<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: algorithm | ZK]]></title>
  <link href="http://ttazk.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://ttazk.github.io/"/>
  <updated>2017-09-07T09:04:44+08:00</updated>
  <id>http://ttazk.github.io/</id>
  <author>
    <name><![CDATA[Z K]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[两个相似的DP例子]]></title>
    <link href="http://ttazk.github.io/blog/2017/08/23/2dp/"/>
    <updated>2017-08-23T23:16:03+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/08/23/2dp</id>
    <content type="html"><![CDATA[<ul>
<li><p>如果一个01串任意两个相邻位置的字符都是不一样的,我们就叫这个01串为交错01串。例如: &ldquo;1&rdquo;,&ldquo;10101&rdquo;,&ldquo;0101010"都是交错01串。
小易现在有一个01串s,小易想找出一个最长的连续子串,并且这个子串是一个交错01串。小易需要你帮帮忙            求出最长的这样的子串的长度是多少。</p>

<ul>
<li>使用动态规划求解：<br>
  设f(n)为以第n个位置结尾（包含第n个元素）的最长连续交错01串的长度，则f(n-1)为以第n-1个位置结尾的长度：当                s[n]==s[n-1]时，即第n个位置与第n-1个位置的值相同，那么f(n)应该放弃前面的长度，即f(n)=1;否则f(n)=f(n-1)+1.</li>
</ul>
</li>
</ul>


<!--more--> 


<pre><code>        package test;

        import java.util.Scanner;

        public class MaxLengthOf01 {

            public static void main(String[] args) {
                 // TODO Auto-generated method stub
                 Scanner in = new Scanner(System.in);

                while (in.hasNext()) {
                    String str = in.next();
                    int n=str.length();
                    if (n==0||str==null) {
                         System.out.println(0);
                         break;
                     }
                    int[] f=new int[n];//用于存储对应位置的最长01串的长度
                 f[0]=1;
                 for(int i=1;i&lt;n;i++){
                     if (str.charAt(i)==str.charAt(i-1)) {
                         f[i]=1;
                     }
                     else {
                             f[i]=f[i-1]+1;
                         }
                 }
                 //求出f[]中最大的值，即为最大子数组的和
                 int max=f[0];
                 for(int i=0;i&lt;n;i++){
                     if (max&lt;f[i]) {
                         max=f[i];
                     }
                 }
                 System.out.println(max);
                }
            }

        }
</code></pre>

<ul>
<li><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>

<ul>
<li><p>动态规划求解：<br>
  f(i)表示以第i个数字结尾的子数组的最大和，其中0&lt;=i&lt;n。当以第i-1个数字结尾的子数组的最大和小于0时，如果把这个负数与第i个数字相加，得到的结果比第i个数字要小，所以这种情况下，以第i个数字结尾的子数组最大和就是第i个数字本身；当以第i-1个数字结尾的子数组的最大和大于0时，与第i个数字累加，就得到以第i个数字结尾的子数组的最大和。</p>

<pre><code>  package test;

  public class FindGreatestSumOfSubArray {
    //求连续子数组的最大和
    public static int findGreatestSumOfSubArray(int[] array){
    int n=array.length;
    if (n==0||array==null) {
    return 0;
    }
    int[] f=new int[n];//用于存储对应位置的最大子数组的和
    f[0]=array[0];
    for(int i=1;i&lt;n;i++){
    if (f[i-1]&lt;0) {
    f[i]=array[i];
    }
    if (f[i-1]&gt;=0) {
    f[i]=f[i-1]+array[i];
    }
    }
    //求出f[]中最大的值，即为最大子数组的和
    int max=f[0];
    for(int i=0;i&lt;n;i++){
    if (max&lt;f[i]) {
    max=f[i];
    }
    }
    return max;
    }
    public static void main(String[] args) {
    // TODO Auto-generated method stub
    System.out.println(findGreatestSumOfSubArray(new int[]{1,-2,3,10,-4,7,2,-5}));
    }

  }
</code></pre></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指Offer_Question5]]></title>
    <link href="http://ttazk.github.io/blog/2017/08/02/question5/"/>
    <updated>2017-08-02T22:50:38+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/08/02/question5</id>
    <content type="html"><![CDATA[<pre><code>    package test;

    /*
     * 从尾到头打印链表
     * 输入一个头结点，从尾到头打印每个节点的值
     * 
     * 可以可以使用栈来实现，访问一个节点时就入栈，根据栈的特点，输出时已经反向
     * 递归本身就相当于栈结构
     */
    class Qnode{
        public int key;
        public Qnode next;
        public Qnode(int key){
            this.key=key;
            next=null;
        }
    }
    public class Question5 {
</code></pre>

<!-- more -->           


<pre><code>        public static void printFromTailToHead(Qnode head){
            /*
             * 如果想要不改变链表结构（将链表翻转），从尾到头地打印链表
             * 可以采取的思路是利用递归
             * 不过要注意，要先递归调用方法，再打印，这样当递归调用至最深处时
             * 即最后一个节点进行递归，找到递归出口，实现了先打印最后一个节点，依次倒着打印节点
             */
            if (head!=null) {
                printFromTailToHead(head.next);
                System.out.print(head.key+" ");//这种顺序使得首先递归调用地最后输出
            }
        }
        public static void main(String[] args) {
            // TODO Auto-generated method stub
            Qnode listnode=new Qnode(3);
            Qnode listnode1=new Qnode(4);
            Qnode listnode2=new Qnode(5);
            Qnode listnode3=new Qnode(6);
            Qnode listnode4=new Qnode(7);
            Qnode listnode5=new Qnode(8);
            Qnode listnode6=new Qnode(9);

            listnode.next=listnode1;listnode1.next=listnode2;
            listnode2.next=listnode3;listnode3.next=listnode4;
            listnode4.next=listnode5;listnode5.next=listnode6;

            printFromTailToHead(listnode);
        }

    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见排序及两个经典DP]]></title>
    <link href="http://ttazk.github.io/blog/2017/08/02/sortanddp/"/>
    <updated>2017-08-02T21:32:12+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/08/02/sortanddp</id>
    <content type="html"><![CDATA[<h3>1.插入排序</h3>

<pre><code>package Sort;

public class InsertSort {
    //将后面的元素与前面的有序元素进行比较，找到合适的位置进行插入
    public static void insertSort(int[] array){
         for (int i = 0; i &lt; array.length-1; i++) {
             for (int j = i+1; j &gt;0 &amp;&amp; array[j]&lt;array[j-1]; j--) {
                 int temp=array[j];
                 array[j]=array[j-1];
                 array[j-1]=temp;
             }
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] array={2,4,1,667,32,5,90,66,12,9,31};
         insertSort(array);
         for(int a:array){
             System.out.print(a+" ");
         }
    }

}
</code></pre>

<!--more-->


<h3>2.归并排序</h3>

<pre><code>package Sort;

public class MergeSort {
    private static int[] temp;//临时数组，长度与要排序的数组长度相同
    public static void sort(int[] array){
         temp=new int[array.length];
         mergeSort(array, 0, array.length-1);
    }
    public static void mergeSort(int[] array,int low,int high){

         if (low&gt;=high) {
             return;
         }
         int mid=(high+low)/2;
         mergeSort(array, low, mid);//对左半边进行排序
         mergeSort(array, mid+1, high);//对右半边进行排序
         merge(array, low, mid, high);//归并
    }
    //原地归并
    public static  void merge(int[] array,int low,int mid,int high){
         for(int i=low;i&lt;=high;i++){
             temp[i]=array[i];//将待排序的元素复制到临时数组中
         }
         int m=low;int n=mid+1;//标记待归并的两个起始位置,这两个位置是在临时数组中的位置

         for(int i=low;i&lt;=high;i++){
             //将临时数组中的元素按顺序归并到原数组中
             //前两个判断一定要放在后两个判断之前
             if (m&gt;mid){
                 array[i]=temp[n];
                 n++;
             }
             else if(n&gt;high){
                 array[i]=temp[m];
                 m++;
             }
             else if(temp[m]&lt;temp[n]) {
                 array[i]=temp[m];
                 m++;
             }
             else{
                 array[i]=temp[n];
                 n++;
             }

         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] array={23,4,1,67,32,5,90,66,12,9,31};
         sort(array);
         for(int a:array){
             System.out.print(a+" ");
         }
    }

}
</code></pre>

<h3>3.快速排序</h3>

<pre><code>package Sort;

public class QuickSort {

    public static void sort(int[] array,int low,int high){
         if (low&gt;=high) {
             return;
         }
         int j=partition(array, low, high);//找出分界点
         sort(array, low, j-1);//对左半边排序
         sort(array, j+1, high);//对右半边排序
    }
    public static int partition(int[] array,int low,int high){
         int i=low;
         int j=high+1;
         int a=array[low];
         while(true){
             while(array[++i]&lt;=a){
                 if (i&gt;=high) {
                     break;
                 }
             }
             while(array[--j]&gt;=a){
                 if (j&lt;=low) {
                     break;
                 }
             }
             //当两个元素相遇
             if (i&gt;=j) {
                 break;
             }
             swap(array, i, j);
         }
         swap(array, low, j);
         return j;
    }
    public static void swap(int[] array,int i,int j){
         int temp=array[i];
         array[i]=array[j];
         array[j]=temp;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] a={2,3,2,1,4,4,3,2,1,23,0,4,2};
         sort(a, 0, a.length-1);
         for (int i = 0; i &lt; a.length; i++) {
             System.out.print(a[i]+" ");
         }
    }

}
</code></pre>

<h3>4.选择排序</h3>

<pre><code>package Sort;

public class SelectSort {

    public static void selectSort(int[] array){
         int length=array.length;
         for (int i = 0; i &lt; length; i++) {
             int min=i;//用于记录最小值的位置
             for (int j = i+1; j &lt; array.length; j++) {
                 if (array[min]&gt;array[j]) {
                     min=j;
                 }
             }
             //将剩余数组的最小值与左边的元素交换
             {
                 int temp=array[i];
                 array[i]=array[min];
                 array[min]=temp;
             }
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] array={2,4,1,67,32,5,66,12,9,31};
         selectSort(array);
         for(int a:array){
             System.out.print(a+" ");
         }
    }

}
</code></pre>

<h3>5.希尔排序</h3>

<pre><code>package Sort;

public class ShellSort {
    public static void shellsort(int[] array){
         int h=1;
         int n=array.length;
         while(h&lt;n/3) h=3*h+1;//确定间隔
         while(h&gt;=1){
             for(int i=0;i&lt;n-h;i++){
                 for(int j=i+h;j&gt;h-1 &amp;&amp; array[j]&lt;array[j-h];j=j-h){
                     int temp=array[j];
                     array[j]=array[j-h];
                     array[j-h]=temp;
                 }
             }
             h=h/3;//不断缩小间隔
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] array={2,4,1,67,32,5,90,66,12,9,31};
         shellsort(array);
         for(int a:array){
             System.out.print(a+" ");
         }
    }

}
</code></pre>

<h3>6.实现堆</h3>

<pre><code>package algorithm;

import java.util.Arrays;

public class Heap {
    private int[] heap=new int[9];//假定堆长度不超过50
    private int n=0;//用来记录堆的位置,存储数据时不使用heap[0]位置，从heap[1],heap[2]...heap[49]

    public void swap(int[] heap,int a,int b){
         int temp=heap[a];
         heap[a]=heap[b];
         heap[b]=temp;
    }
    public boolean isEmpty(){
         return n==0;
    }
    //元素上浮
    public void swim(int k){
         //k表示元素的索引
         while(k&gt;1){
             if (heap[k]&gt;heap[k/2]) {
                 //将元素与其父节点交换
                 swap(heap, k, k/2);
             }
             k=k/2;
         }
    }
    //元素下沉
    public void sink(int k){
         while(2*k&lt;=n){
             int i=2*k;
             if (heap[i]&lt;=heap[i+1]) {
                 i++;//记录较大子节点的位置
             }
             if (heap[k]&gt;=heap[i]) {
                 break;//要下沉的节点不比子节点小，退出
             }
             swap(heap, k, i);
             k=i;
         }
    }
    //向堆中插入元素
    public void insert(int value){
         n++;//增大堆的位置
         heap[n]=value;//将要插入的值放在最后
         swim(n);//将该元素上浮以维持堆
    }
    //删除最大元素
    public int deleteMax(){
         int max=heap[1];
         swap(heap, 1, n);//将最大值与最后一个位置的值交换，即将最后一个元素放在首位
         heap[n]=0;//删除最后一个元素
         n--;
         sink(1);
         return max;
    }

    //堆排序,每次都将最大元素放到最后面，然后再维护堆
    public void heapSort(int[] array){
         for (int i = 0; i &lt; array.length; i++) {
             insert(array[i]);//构造堆
         }
         while(n&gt;1){
         swap(heap, 1, n);
         n--;
         sink(1);//不能使用这个方法
         }
         for (int i = 0; i &lt; array.length; i++) {
             array[i]=heap[i+1];
         }
    }
    public static void main(String[] args) {
         Heap heap=new Heap();
         heap.insert(3);
        heap.insert(2);heap.insert(20);heap.insert(43);heap.insert(9);heap.insert(16);heap.insert(80);heap.insert(7);
         while(!heap.isEmpty()){
             System.out.print(heap.deleteMax()+" ");
         }
         int[] array={22,1,2,3,56,9,8,20};
         heap.heapSort(array);
        System.out.println(Arrays.toString(array));
    }
}
</code></pre>

<h3>7.最长公共子序列</h3>

<pre><code>package algorithm;

public class LCS {
    public static int[][] lcs(String str1,String str2){
         int i=str1.length();
         int j=str2.length();
         int[][] m=new int[i+1][j+1];//该数组表示最优解的情况下，子序列的长度
         for(int a=0;a&lt;i+1;a++){
             m[a][0]=0;
         }
         for(int b=0;b&lt;j+1;b++){
             m[0][j]=0;
         }
         for(int a=1;a&lt;i+1;a++){
             for(int b=1;b&lt;j+1;b++){
                 if (str1.charAt(a-1)==str2.charAt(b-1)) {
                     m[a][b]=m[a-1][b-1]+1;
                 }
                 else{
                     if (m[a-1][b]&gt;=m[a][b-1]) {
                          m[a][b]=m[a-1][b];
                     }else {
                          m[a][b]=m[a][b-1];
                     }
                 }
             }
         }
         return m;
    }
    public static void print(int[][] m,String str1,String str2,int i,int j){
         if (i==0||j==0) {
             return;
         }
         if (str1.charAt(i-1)==str2.charAt(j-1)) {
             print(m, str1, str2, i-1, j-1);
             System.out.print(str1.charAt(i-1));
         }
         else {
             if (m[i-1][j]&gt;=m[i][j-1]) {
                 print(m, str1, str2, i-1, j);
             }
             else {
                 print(m, str1, str2, i, j-1);
             }
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         String str1="ABCBDAB";
         String str2="BDCABA";
         int[][] m=lcs(str1, str2);
         for (int i = 0; i &lt; m.length; i++) {
             for (int j = 0; j &lt; m[0].length; j++) {
                 System.out.print(m[i][j]+" ");
             }
             System.out.println();
         }
         print(m, str1, str2, 7, 6);
    }

}
</code></pre>

<h3>8.01背包问题</h3>

<pre><code>package algorithm;

import java.util.Arrays;

public class Package_01 {

    public static int[][] package_01(int[] weight,int[] value,int c){
         int n=weight.length;
         int[][] m=new int[n+1][c+1];//作为记录的表格,其中的值表示最优解情况下价值的值
         for (int k = 0; k &lt; n+1; k++) {
             m[k][0]=0;//第一列置于0
         }
         for(int k=0;k&lt;c+1;k++){
             m[0][k]=0;//第一行置于0
         }
         //注意，物品的编号是从0,1,2,,,n
         for(int k=1;k&lt;n+1;k++){
             for(int l=1;l&lt;c+1;l++){
                 m[k][l]=m[k-1][l];//先假设第k件物品(weight[k-1],value[k-1])不放进去
                 if (weight[k-1]&lt;=l) {
                     //如果第k件物品(weight[k-1],value[k-1])能够放进去，考虑放进去与不放进去的比较，选择较大的
                     if (value[k-1]+m[k-1][l-weight[k-1]]&gt;m[k-1][l]) {
                         m[k][l]=value[k-1]+m[k-1][l-weight[k-1]];
                     }
                 }
             }
         }

         return m;
    }
    public static int[] build(int[][] m,int c,int[] weight){
         int[] x=new int[weight.length];
         for(int i=weight.length;i&gt;=1;i--){
             if (m[i][c]==m[i-1][c]) {
                 x[i-1]=0;
             }
             else {
                 x[i-1]=1;
                 c=c-weight[i-1];
             }
         }
         return x;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         int[] w={2,3,4,5};
         int[] v={3,4,5,7};
         int c=9;
         int[][] m=package_01(w, v, c);
         for (int i = 0; i &lt; m.length; i++) {
             for (int j = 0; j &lt; m[0].length; j++) {
                 System.out.print(m[i][j]+" ");
             }
             System.out.println();
         }
         int[] a=build(m, c, w);
         System.out.println(Arrays.toString(a));
    }

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[剑指offer——1]]></title>
    <link href="http://ttazk.github.io/blog/2017/08/02/jianzhioffer1/"/>
    <updated>2017-08-02T21:31:37+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/08/02/jianzhioffer1</id>
    <content type="html"><![CDATA[<h3>1.二维数组中的查找</h3>

<p>   在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数,输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>

<pre><code>        * 在一个二维数组中查找一个整数，数组是从左向右，从上向下递增
        * 分析：
        * 对于无序的数组，我们可以一行一行地进行比较，时间复杂度为O(n*n)
        * 由于该数组有序，按照一般的比较思路，我们一般从左上角到又开始比较，如果当前数字比待查找值小，则向右或者
        * 向下继续查找，这样的话便不容易进行选择。因此，我们可以尝试从右上角向左进行排查/从左下角向右进行排查，这样就不会像刚才一样
        * 面临两种选择，从而使问题简化。
        * 从左下角向右进行排查：如果当前数字比待查找值大，则向上进行查找（同时摈弃最下面一行，因为最下面一行的数字都比左下角的大）
        * 如果当前数字比待查找值小，则向右进行查找（同时摈弃该列，因为该列往上的数字都比待查找值小）
        *
        public class Question3 {

            //从左下角向右进行排查
            public static boolean findInArray(int[][] array,int a){
                if (array==null) {
                    return false;
                }
                int row=array.length-1;
                int column=array[0].length-1;


                int i=row,j=0;
                while(i&gt;=0&amp;&amp;j&lt;=column){
                    if (array[i][j]&gt;a) {
                        System.out.print(array[i][j]+" ");
                        i--;//往上走
                    }
                    else if (array[i][j]&lt;a) {
                        System.out.print(array[i][j]+" ");
                        j++;//往右走
                    }else {
                        System.out.print(array[i][j]+" ");
                        return true;
                    }
                }

                return false;
            }
            public static void main(String[] args) {
                int[][] array={.{1,2,3,4},{2,3,4,5},{3,4,5,6,},{4,5,6,7}.};
                System.out.println(findInArray(array, 3));
                //System.out.println(findInArray(array, 9));
            }

        }
        --------------------------------------------------------------------------------------------
        public class Solution {
            public boolean Find(int target, int [][] array) {
                int i=0;
                int j=array[0].length-1;
                while(i&lt;=array.length-1&amp;&amp;j&gt;=0){
                    if (array[i][j]==target) {
                        return true;
                    }
                    else if(target&gt;array[i][j]){
                        i++;
                    }
                    else{
                        j--;
                    }
                }
                return false;
            }
        }
</code></pre>

<!-- more -->


<h3>2.替换空格</h3>

<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>

<pre><code>        public class Solution {
        //从后向前复制
            public static String replaceSpace(StringBuffer stringBuffer){
                 int oldIndex=stringBuffer.length()-1;
                 int count=0;
                 for (int i = 0; i &lt; stringBuffer.length(); i++) {
                     if (stringBuffer.charAt(i)==' ') {
                         count++;
                     }
                 }
                 int newIndex=oldIndex+count*2;
                 stringBuffer.setLength(newIndex+1);
                 for(;oldIndex&gt;=0;oldIndex--){
                     if (stringBuffer.charAt(oldIndex)==' ') {
                         stringBuffer.setCharAt(newIndex--, '0');
                         stringBuffer.setCharAt(newIndex--, '2');
                         stringBuffer.setCharAt(newIndex--, '%');
                     }else{
                         stringBuffer.setCharAt(newIndex--, stringBuffer.charAt(oldIndex));
                     }
                 }
                 return stringBuffer.toString();
            }

        }
</code></pre>

<h3>3.从尾到头打印链表</h3>

<p>   输入一个链表，从尾到头打印链表每个节点的值。</p>

<pre><code>package test;

class Node{
    private Node next;
    private int value;
    public Node getNext() {
         return next;
    }
    public void setNext(Node next) {
         this.next = next;
    }
    public int getValue() {
         return value;
    }
    public void setValue(int value) {
         this.value = value;
    }

}
public class PrintFromTailToHead {
    //可以使用栈来实现，访问一个节点时就入栈，根据栈的特点，输出时已经反向
    //递归本身就相当于栈结构
    //为了实现反向输出，每访问一个节点，先输出它的下一个节点，再输出自身
    public static void printFromTailtoHead(Node node){
         if (node!=null) {
             printFromTailtoHead(node.getNext());
             System.out.print(node.getValue()+" ");
         }
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         for (int i = 0; i &lt; 10; i++) {

         }
         Node node1=new Node();node1.setValue(4);
         Node node2=new Node();node2.setValue(6);
         Node node3=new Node();node3.setValue(12);
         Node node4=new Node();node4.setValue(8);
         Node node5=new Node();node5.setValue(1);
         Node node6=new Node();node6.setValue(3);
        node1.setNext(node2);node2.setNext(node3);node3.setNext(node4);node4.setNext(node5);node5.setNext(node6);node6.setNext(null);
         printFromTailtoHead(node1);
    }

}
</code></pre>

<h3>4.重建二叉树</h3>

<p>   输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
        package test;</p>

<pre><code>    class TreeNode {
         int val;
         TreeNode left;
         TreeNode right;
         TreeNode(int x) { val = x; }
         }
    public class RebuildBinaryTree {
         public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
                return reConstructBinaryTree(pre, 0, pre.length-1, in, 0, in.length-1);
         }
         public TreeNode reConstructBinaryTree(int[] pre,int preStart,int preEnd,int[] in,int inStart,int inEnd) {
                if (preStart&gt;preEnd||inStart&gt;inEnd) {
                     return null;
                 }
                TreeNode root=new TreeNode(pre[preStart]);//以先序遍历的第一个点构造根节点
                //遍历中序数组，找到根节点的位置，根节点的左半部分为左子树，根节点的右半边为右子树
                //再根据左右子树的长度将先序数组划分成两个数组，分别对应左右子树的先序遍历
                for (int i = inStart; i &lt;= inEnd; i++) {
                     if (in[i]==pre[preStart]) {//记录根节点在中序数组的位置
                         root.left=reConstructBinaryTree(pre, preStart+1, preStart+i-inStart, in, inStart, i-1);
                         root.right=reConstructBinaryTree(pre, preStart+i-inStart+1, preEnd, in, i+1, inEnd);
                     }
                 }
                return root;
            }
        public static void main(String[] args) {
             // TODO Auto-generated method stub

        }

    }
</code></pre>

<h3>5.用两个栈实现队列</h3>

<p>   用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>

<pre><code>    package test;

    import java.util.Stack;

    public class StackToQueue {
        //第一个栈用于压入，第二个栈用于弹出
        static Stack&lt;Integer&gt; stack1=new Stack&lt;&gt;();
        static Stack&lt;Integer&gt; stack2=new Stack&lt;&gt;();
        public static void push(int node){
             stack1.push(node);
        }
        public static int pop(){

             if (!stack2.isEmpty()) {
                 int first=stack2.pop();
                 return first;
             }else{
                 while(!stack1.isEmpty()){
                     int temp=stack1.pop();
                     stack2.push(temp);
                 }
                 return pop();
             }
        }
        public static void main(String[] args) {
             // TODO Auto-generated method stub
             push(1);push(2);push(3);
             System.out.print(pop()+" ");
             System.out.print(pop()+" ");
             System.out.print(pop()+" ");
        }

    }
</code></pre>

<h3>6.旋转数组的最小数字</h3>

<p>   把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>

<pre><code>import java.util.ArrayList;
public class Solution {
    public int minNumberInRotateArray(int [] array) {
    int low=0;
        int high=array.length-1;
        while(low&lt;=high){
            if (high-low==1) {
                return array[high];
            }
            int mid=(low+high)/2;
            if (array[mid]&lt;=array[high]) {
                high=mid;
            }
            else if (array[mid]&gt;=array[high]) {
                low=mid;
            }
        }
        return -1;
    }
}
</code></pre>

<h3>7.斐波那契数</h3>

<p>   大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。n&lt;=39</p>

<pre><code>package test;

public class Fibonacci {
    //使用递归占用内存太大；计算也会出问题，所以应该选择循环
    public static int fibonacci(int n) {
        if(n==1||n==2){
            return 1;
        }
        else if(n&gt;2){
            return fibonacci(n-2)+fibonacci(n-1);
        }
        else
            return 0;
    }
    public static int fibonacci_2(int n){
        if (n==1||n==2) {
            return 1;
        }
        else if (n&gt;2) {
            int a=1,b=1,c=0;
            for(int i=3;i&lt;=n;i++){
                c=a+b;
                a=b;
                b=c;
            }
            return c;
        }
        else {
            return 0;
        }
    }
    //思考使用递归求解动态规划导致时间复杂度为指数的原因是子问题重叠，需要重复计算子问题
    //那么动态规划自顶向下的思路是在递归的基础上添加备忘机制,所以这题也可以在递归的基础上添加备忘机制
    //但是，也可以采用自底向上的思路，建立数组存储子问题的解，再求解原问题的解
    public static int fibonacci3(int n){
        int[] array=new int[n+1];
        array[0]=0;
        array[1]=1;
        for(int i=2;i&lt;n+1;i++){
            array[i]=array[i-1]+array[i-2];
        }
        return array[n];
    }
    public static void main(String[] args) {
        System.out.println(fibonacci(10));
        System.out.println(fibonacci_2(20));
    }
}
</code></pre>

<h3>8.跳台阶</h3>

<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>

<pre><code>    package test;

    public class JumpFloor {
        //青蛙跳n阶台阶，一次可以跳1,2,3,4...n阶，求有多少种跳法
        //等同于斐波那契数
        //f(n)=f(n-1)+f(n-2)
        public static int jumpFloor(int target){
            int[] array=new int[target+1];
            array[0]=0;
            array[1]=1;
            for(int i=2;i&lt;target+1;i++){
                array[i]=array[i-1]+array[i-2];
            }
            return array[n];

             return array[target];
        }
        public static void main(String[] args) {
             // TODO Auto-generated method stub
             System.out.println(jumpFloor(4));
        }

    }
</code></pre>

<h3>9.变态跳台阶</h3>

<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>

<pre><code>package test;

public class JumpFloor {
    //青蛙跳n阶台阶，一次可以跳1,2,3,4...n阶，求有多少种跳法
    //f(n)=f(n-1)+f(n-2)+...f(1)=2*f(n-1)
    public static int jumpFloor(int target){
         if (target==1) {
             return 1;
         }
         int[] array=new int[target+1];//用来存储n的各个值的情况下的值
         array[0]=1;
         array[1]=1;
         for (int i = 2; i &lt;=target; i++) {
             array[i]=0;
             //当前位置的值等于前面所有元素的和
             for(int j=0;j&lt;i;j++){
                 array[i]=array[i]+array[j];
             }
         }
         return array[target];
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
         System.out.println(jumpFloor(4));
    }

}
</code></pre>

<h3>10.矩形覆盖</h3>

<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>

<pre><code>public class Solution {
     //类似于斐波那契数，考虑第一步是竖着覆盖，还是横着覆盖
    public int RectCover(int target) {
        if(target==1){return 1;}
        else if(target==2){return 2;}
        else if(target&gt;=3){
            return RectCover(target-2)+RectCover(target-1);
        }
        else{return 0;}
    }
}
</code></pre>

<h3>11.二进制中1的个数</h3>

<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>

<pre><code>public class Solution {
    public int NumberOf1(int n) {
        int count=0;
        while(n!=0){
            n=n&amp;(n-1);
            count++;
        }
        return count;
    }
}
</code></pre>

<h3>12.调整数组的顺序使奇数位于偶数之前</h3>

<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>

<pre><code>package test;

import java.util.ArrayList;
import java.util.Arrays;

public class ReOrderArray {

    public static void reOrderArray(int[] array){
        int n=array.length;
        //int[] array1=new int[n];
        //int[] array2=new int[n];
        ArrayList&lt;Integer&gt; arrayList1=new ArrayList&lt;&gt;();
        ArrayList&lt;Integer&gt; arrayList2=new ArrayList&lt;&gt;();
        for(int i=0;i&lt;n;i++){
            if (array[i]%2!=0) {
                arrayList1.add(array[i]);
            }
        }
        for(int i=0;i&lt;n;i++){
            if (array[i]%2==0) {
                arrayList2.add(array[i]);
            }
        }
        for (int i = 0; i &lt; arrayList1.size(); i++) {
            array[i]=arrayList1.get(i);
        }
        for (int i = 0; i &lt; arrayList2.size(); i++) {
            array[i+arrayList1.size()]=arrayList2.get(i);
        }
    }
    //这种解法类似于快排,不太稳定
    //这种方法没有保证奇数之间位置相对不变，如1,2,3,4,5,6,7
    public static void reOrderArray2(int[] array){
        int low=0;
        int high=array.length-1;
        while(low&lt;high){
            while(array[low]%2!=0&amp;&amp;low&lt;array.length){
                low++;
            }
            while(array[high]%2==0&amp;&amp;high&gt;=0){
                high--;
            }
            if (low&lt;=high) {
                int temp=array[low];
                array[low]=array[high];
                array[high]=temp;
            }
        }
    }

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] array=new int[]{1,2,3,4,5,6,7};
        reOrderArray2(array);
        System.out.println(Arrays.toString(array));

    }

}
</code></pre>

<h3>13.链表中倒数第k个节点</h3>

<p>输入一个链表，输出该链表中倒数第k个结点。</p>

<pre><code>package test;
//输入一个链表，输出该链表中倒数第k个结点。
class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
public class FindKthToTail {
    public static ListNode findKthTail(ListNode head,int k){
         //用于判断比较极端的情况
         if (head==null||k&lt;=0) {
             return null;
         }
         int count=0;
         ListNode tail=head;
         while(count&lt;k-1){
             if (tail.next!=null) {
                 tail=tail.next;//先找到从表头起，第k个节点
                 count++;
             }
             else {
                 return null;//如果链表的总节点数小于k，则退出
             }
         }
         //两个指针同时往后移动，当后面的指针到末尾时，前面的指针正好位于倒数第k个节点的位置
         while(tail.next!=null){
             tail=tail.next;
             head=head.next;
         }
         return head;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>14.反转链表</h3>

<p>输入一个链表，反转链表后，输出链表的所有元素。</p>

<pre><code>package test;
//输入一个链表，反转链表后，输出链表的头结点
//不是说直接反向输出链表（PrintFromTailtoHead）

//ps:当我们用一个指针遍历链表不能解决问题时，可以尝试使用2,3个指针

public class ReverList {
    class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }
    public static ListNode reverseList(ListNode head){
         if (head==null) {
             return null;
         }
         ListNode h,i,j;//用三个指针遍历链表，其中i代表当前正在遍历的节点，h,j分别代表前后的节点
         h=null;i=head;j=null;
         //前两个指针用来更新链表，后一个指针只是用来保存下个节点，防止链表断开，前两个节点才是用来更新链表
         while(i!=null){
             j=i.next;//先保存当前节点的下个节点，防止链表断开

             i.next=h;//更改当前节点的下个节点，使链表翻转

             //迭代更新当前节点与前一个节点
             h=i;
             i=j;

         }
         return h;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub

    }

}
</code></pre>

<h3>15.合并两个排序的链表</h3>

<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>

<pre><code>package test;
//输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
public class MergeList {
    class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }
    //出现错误，返回的是合并之后的最后一个节点
    public ListNode merge(ListNode list1,ListNode list2){
         ListNode temp=null;
         while(list1!=null||list2!=null){
             if (list1==null) {
                 temp.next=list2;
                 list2=list2.next;
             }
             else if (list2==null) {
                 temp.next=list1;
                 list1=list1.next;
             }
             else if (list1.val&lt;list2.val) {
                 temp.next=list1;
                 list1=list1.next;
             }
             else {
                 temp.next=list2;
                 list2=list2.next;
             }
             temp=temp.next;
         }
         return temp;
    }

    public ListNode merge2(ListNode list1,ListNode list2){
         ListNode temp=null;
         if (list1==null) {
             return list2;
         }
         if (list2==null) {
             return list1;
         }
         if (list1.val&lt;list2.val) {
             temp=list1;
             temp.next=merge2(list1.next, list2);
         }
         else {
             temp=list2;
             temp.next=merge2(list1, list2.next);
         }
         return temp;
    }
    public static void main(String[] args) {
         // TODO Auto-generated method stub
    }

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态规划与贪心]]></title>
    <link href="http://ttazk.github.io/blog/2017/07/30/algorithm/"/>
    <updated>2017-07-30T16:59:12+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/07/30/algorithm</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
</feed>
