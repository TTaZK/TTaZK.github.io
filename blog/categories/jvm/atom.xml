<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Jvm | Coding BY ZK]]></title>
  <link href="http://ttazk.github.io/blog/categories/jvm/atom.xml" rel="self"/>
  <link href="http://ttazk.github.io/"/>
  <updated>2017-05-15T12:04:33+08:00</updated>
  <id>http://ttazk.github.io/</id>
  <author>
    <name><![CDATA[Z K]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Object详解]]></title>
    <link href="http://ttazk.github.io/blog/2017/04/19/object/"/>
    <updated>2017-04-19T20:07:37+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/04/19/object</id>
    <content type="html"><![CDATA[<ul>
<li>Object类是所有类的父类，每个类都是由Object类扩展而来。如果没有明确指出父类，则默认为Object类为该类的父类。</li>
<li>可以使用Object类型的变量引用任何类型的对象。</li>
<li><p>在Java中，只有基本数据类型（数字，字符，布尔）不是对象。所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。</p>

<pre><code>   int[] i=new int[5];
   Object obj=i;
</code></pre></li>
</ul>


<h3>equals()方法</h3>

<ul>
<li>在Object类中，该方法用于判断两个对象是否具有相同的引用。</li>
<li><p>然而，经常需要检测两个对象的状态的相等性，所以一般需要覆写equals()方法。</p>

<pre><code>         public class Test{
             public boolean equals(Object otherObject){
                  }
         }
</code></pre></li>
<li><p>在子类中定义equals方法时，首先调用父类的equals方法。如果检测失败，则对象不可能相等。如果父类中的域都相等，就需要比较子类中的实例域。</p></li>
</ul>


<!--  more -->


<pre><code>         public class Test{
                   public boolean equals(Object otherObject){
                   if(!super.equals(otherObject)) return false;
                    //接着比较子类中扩展的实例域    
                   }
               }        
</code></pre>

<ul>
<li><p>Java规范要求equals方法具有下面的特性：</p>

<ul>
<li>自反性：对于非空引用 x,x.equals(x)应该返回true.</li>
<li>对称性：如果x.equals(y)返回true,则y.equals(x)也应该返回true</li>
<li>传递性：x.equals(y)返回true,y.equals(z)返回true，则x.equals(z)返回true</li>
<li>一致性：如果x,y引用的对象没有发生改变，反复调用x.equals(y)返回相同的结果</li>
<li>对于非空引用x，x.equals(null)应该返回false.<br/><br/></li>
</ul>
</li>
<li><p>编写equals方法的步骤：</p>

<ul>
<li>显式参数命名为otherObject，稍后需将它转换成叫做other的变量</li>
<li><p>检测this与otherObject是否引用同一个对象</p>

<pre><code>  if(this==otherObject)  return true;
</code></pre></li>
<li><p>检测otherObject是否为null，如果为null，则返回false</p>

<pre><code>   if(otherObject==null)  return false;
</code></pre></li>
<li><p>比较this与otherObject是否属于同一个类</p>

<pre><code>  if(this.getClass!==otherObject.getClass)  return false;
</code></pre></li>
<li><p>将otherObject转换为相应的类类型变量</p>

<pre><code>   ClassName other=(ClassName)otherObject
</code></pre></li>
<li><p>对所有需要比较的域进行比较。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配则返回true,否则返回false.</p>

<pre><code>  return field1==other.field&amp;&amp;Objects.equals(field,other.field)
</code></pre>

<br/><br/>

<h3>hashCode()方法</h3></li>
</ul>
</li>
<li>散列码(hash code)是由对象导出的一个整型值（可以是负数）。散列码没有规律，两个不同对象的散列码基本不同。</li>
<li>在Object类中，hashCode()方法的返回值默认为对象的存储地址。</li>
<li><p>String类型重写了hashCode()方法，字符串的散列码是由内容导出的。计算过程如下：</p>

<pre><code>        int hash=0;
        for(int i=0;i&lt;length();i++){
             hash=31*hash+charAt(i);
        }
        //String str1="string";  String str2=new String("string");
        //str1,str2的散列码值相同，因为其内容相同。
</code></pre></li>
<li><p>如果重新定义equals()方法，就必须重新定义hashCode()方法，以便用户可以将对象插入到散列表中。equals()方法与hashCode()方法的定义必须一致：如果x.equals(y)返回true,那么x.hashCode()的值必须与y.hashCode()值相等。</p></li>
<li><p>如果存在数组类型的域，可以使用静态的Arrays.hashCode()方法计算一个散列码，这个散列码由数组元素的散列码组成。</p>

<pre><code>  static int hashCode(type[] a)//数组类型可以是任意类型
</code></pre>

<br/><br/>

<h3>toString()方法</h3></li>
<li>该方法用于返回表示对象值的字符串。</li>
<li>Object类中的toString()方法返回对象所属的类名及散列码。</li>
<li>只要将对象与一个字符串通过"+&ldquo;相连，Java编译器就会自动调用toString()方法，以便获得这个对象的字符串表示。</li>
<li>大部分类覆写了toString()方法，返回值为：类的名字，随后是一对方括号括起来的域值。</li>
<li><p>数组类型继承了Object类的toString方法，如果直接输出数组，如：int[] arr={1,2,3};，会生成字符串：类型+hashCode。如果想要输出[1,2,3]，则需调用Arrays.toString()方法。</p>

<pre><code>      static String toString(type[] a)            
</code></pre>

<br/><br/>

<h3>getClass()方法</h3></li>
<li>返回此 Object 的运行时类。返回的 Class 对象是由所表示类的 static synchronized 方法锁定的对象
<br/><br/>

<h3>protected Object clone()</h3></li>
<li>创建并返回此对象的一个副本。“副本”的准确含义可能依赖于对象的类。这样做的目的是，对于任何对象 x表达式： x.clone() != x 为 true，表达式： x.clone().getClass() == x.getClass()也为 true，但这些并非必须要满足的要求。</li>
<li>一般情况下： x.clone().equals(x)为 true，但这并非必须要满足的要求。</li>
<li>按照惯例，返回的对象应该通过调用 super.clone 获得。如果一个类及其所有的超类（Object 除外）都遵守此约定，则 x.clone().getClass() == x.getClass()。</li>
<li>按照惯例，此方法返回的对象应该独立于该对象（正被复制的对象）。要获得此独立性，在 super.clone 返回对象之前，有必要对该对象的一个或多个字段进行修改。这通常意味着要复制包含正在被复制对象的内部“深层结构”的所有可变对象，并使用对副本的引用替换对这些对象的引用。如果一个类只包含基本字段或对不变对象的引用，那么通常不需要修改 super.clone 返回的对象中的字段。</li>
<li>Object 类的 clone 方法执行特定的复制操作。首先，如果此对象的类不能实现接口 Cloneable，则会抛出 CloneNotSupportedException。注意，所有的数组都被视为实现接口 Cloneable。否则，此方法会创建此对象的类的一个新实例，并像通过分配那样，严格使用此对象相应字段的内容初始化该对象的所有字段；这些字段的内容没有被自我复制。所以，此方法执行的是该对象的“浅表复制”，而不“深层复制”操作。</li>
<li>Object 类本身不实现接口 Cloneable，所以在类为 Object 的对象上调用 clone 方法将会导致在运行时抛出异常。
<br/><br/>

<h3>public final void notify()</h3></li>
<li>唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。</li>
<li>直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。</li>
<li>此方法只应由作为此对象监视器的所有者的线程来调用。通过以下三种方法之一，线程可以成为此对象监视器的所有者：

<ul>
<li>通过执行此对象的同步实例方法。</li>
<li>通过执行在此对象上进行同步的 synchronized 语句的正文。</li>
<li>对于 Class 类型的对象，可以通过执行该类的同步静态方法。</li>
</ul>
</li>
<li>一次只能有一个线程拥有对象的监视器。
<br/><br/>

<h3>public final void wait(long timeout)</h3></li>
<li>此方法导致当前线程（称之为 T）将其自身放置在对象的等待集中，然后放弃此对象上的所有同步要求。出于线程调度目的，在发生以下四种情况之一前，线程 T 被禁用，且处于休眠状态：

<ul>
<li>其他某个线程调用此对象的 notify 方法，并且线程 T 碰巧被任选为被唤醒的线程。</li>
<li>其他某个线程调用此对象的 notifyAll 方法。</li>
<li>其他某个线程中断线程 T。</li>
<li>大约已经到达指定的实际时间。但是，如果 timeout 为零，则不考虑实际时间，在获得通知前该线程将一直等待。</li>
</ul>
</li>
<li>然后，从对象的等待集中删除线程 T，并重新进行线程调度。然后，该线程以常规方式与其他线程竞争，以获得在该对象上同步的权利；一旦获得对该对象的控制权，该对象上的所有其同步声明都将被恢复到以前的状态，这就是调用 wait 方法时的情况。然后，线程 T 从 wait 方法的调用中返回。所以，从 wait 方法返回时，该对象和线程 T 的同步状态与调用 wait 方法时的情况完全相同
<br/><br/>

<h3>protected void finalize()</h3></li>
<li>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 finalize 方法，以配置系统资源或执行其他清除。</li>
</ul>


<h3>protected void finalize() throws Throwable</h3>

<ul>
<li>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 finalize 方法，以配置系统资源或执行其他清除。</li>
<li>finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象或类的终结操作执行了某个操作。finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，以便在永久丢弃对象之前中断连接。</li>
<li>Object 类的 finalize 方法执行非特殊性操作；它仅执行一些常规返回。Object 的子类可以重写此定义。</li>
<li>Java 编程语言不保证哪个线程将调用某个给定对象的 finalize 方法。但可以保证在调用 finalize 时，调用 finalize 的线程将不会持有任何用户可见的同步锁定。如果 finalize 方法抛出未捕获的异常，那么该异常将被忽略，并且该对象的终结操作将终止。</li>
<li>在启用某个对象的 finalize 方法后，将不会执行进一步操作，直到 Java 虚拟机再次确定尚未终止的任何线程无法再通过任何方法访问此对象，其中包括由准备终止的其他对象或类执行的可能操作，在执行该操作时，对象可能被丢弃。</li>
<li>对于任何给定对象，Java 虚拟机最多只调用一次 finalize 方法。</li>
<li>finalize 方法抛出的任何异常都会导致此对象的终结操作停止，但可以通过其他方法忽略它。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java内存模型]]></title>
    <link href="http://ttazk.github.io/blog/2017/04/12/jmm/"/>
    <updated>2017-04-12T11:05:15+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/04/12/jmm</id>
    <content type="html"><![CDATA[<ul>
<li><p><strong>Java 内存模型中的可见性、原子性和有序性。</strong></p></li>
<li><p><strong>可见性：</strong></p>

<ul>
<li>可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</li>
<li>可见性，是<strong>指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到</strong>。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</li>
<li><strong>在 Java 中 volatile、synchronized 和 final 实现可见性。</strong><br/><br/></li>
</ul>
</li>
</ul>


<!--  more -->


<ul>
<li><strong>原子性：</strong>

<ul>
<li>原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</li>
<li><strong>在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性</strong>。<br/><br/></li>
</ul>
</li>
<li><p><strong>有序性：</strong></p>

<ul>
<li><p>Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p>

<pre><code>  public class NoVisibility {
      private static boolean ready;
      private static int number;
      private static class ReaderThread extends Thread {
          @Override
          public void run() {
              while(!ready) {
                  Thread.yield();
              }
              System.out.println(number);
          }
      }
      public static void main(String[] args) {
          new ReaderThread().start();
          number = 42;
          ready = true;
      }
  }
</code></pre></li>
<li>NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。</li>
<li><strong>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行春旭进行判断，无法得到正确的结论。
　　这个看上去像是一个失败的设计，但却能使JVM充分地利用现代多核处理器的强大性能。例如，在缺少同步的情况下，Java内存模型允许编译器对操作顺序进行重排序，并将数值缓存在寄存器中。此外，它还允许CPU对操作顺序进行重排序，并将数值缓存在处理器特定的缓存中</strong>。<br/><br/></li>
</ul>
</li>
<li><p><strong>Volatile关键字原理：</strong></p>

<ul>
<li>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</li>
<li>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</li>
<li><em>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。
　　而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步</em>。<br/><br/></li>
</ul>
</li>
<li><p>当一个变量定义为 volatile 之后，将具备两种特性：</p>

<ul>
<li>1.<strong>保证此变量对所有的线程的可见性</strong>，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值 能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。</li>
<li>2.<strong>禁止指令重排序优化</strong>。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。<br/><br/></li>
</ul>
</li>
<li><p>volatile 性能：</p>

<ul>
<li>volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[虚拟机类加载机制]]></title>
    <link href="http://ttazk.github.io/blog/2017/02/09/jvm2/"/>
    <updated>2017-02-09T22:55:40+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/02/09/jvm2</id>
    <content type="html"><![CDATA[<ul>
<li>类的生命周期包括：加载&ndash;>连接&ndash;>初始化&ndash;>使用&ndash;>卸载，其中连接包括，验证&ndash;>准备&ndash;>解析。</li>
<li>虚拟机把描述类的数据从Class文件中加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可被虚拟机直接使用的Java类型。</li>
<li>在Java中，类的加载，连接，初始化都是在运行期间完成的，这种策略与C++等不同，但是这也实现了Java语言的运行期动态加载与动态连接的特点。</li>
</ul>


<!--more-->


<h2>类加载的过程：</h2>

<ol>
<li>加载</li>
<li>加载是类加载的一个阶段。在加载时需要 完成以下几件事情：

<ol>
<li>通过类的全限定名称获取此类的二进制字节流</li>
<li>将这个字节流所带表的静态存储结构转换为方法区的运行时数据结构</li>
<li>在内存中生成代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
</li>
<li>二进制字节流可以从Class文件中获取，也可以从网络中或者其他文件中获取。</li>
<li>在加载阶段完成后，虚拟机外部的二进制字节流就转换为方法区中的数据结构，然后再在内存中实例化一个java.lang.Class对象，作为程序访问方法区中这些数据类型的接口。</li>
<li>验证

<ul>
<li>为了确保Class文件中的字节流所包含的信息是符合当前虚拟机的要求。</li>
</ul>
</li>
<li>准备</li>
<li>准备阶段是正式为类变量设置初始值的阶段。这些变量所用的内存都将在方法区中分配。</li>
<li>此时仅分配类变量，不包括实例变量。实例变量会随着对象实例化一起在Java堆中分配。</li>
<li>这里说的初始值是数据的零值，null/false/0等。</li>
<li>解析</li>
<li>将常量池中的符号引用替换为直接引用。</li>
<li>初始化</li>
<li>在这个阶段，才是对类变量进行赋值操作。按照程序的主观计划去初始化类变量及其他资源。</li>
<li>初始化是执行类构造器<clinit>()方法的过程，<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作与静态语句块（static{}）中的语句合并。</li>
<li>类构造器<clinit>()方法与类的构造函数（实例构造器<init>()方法）不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。</li>
<li>由于父类的<clinit>()方法先执行，因此父类中定义的静态语句块要优先于子类的静态语句块。</li>
<li>对于类来说并不是必须的，如果类中没有类变量，也没有静态语句块，那么便不需要<clinit>()方法。</li>
<li>如果多个线程同时初始化一个类，那么只有一个线程会执行<clinit>()方法，其他线程阻塞等待。</li>
</ol>


<h2>虚拟机规范中严格定义了有且只有5中情况必须立即对类进行初始化（加载，验证，准备需要在此之前完成）</h2>

<ol>
<li>遇到new,getstatic,putstatic或者invokestatic这4条字节码指令时，如果类没有进行初始化，则需要对它进行初始化。生成这4条字节码指令的Java代码是：使用new关键字实例化对象，读取或者设置一个类的静态字段（被final修饰，已经在编译期就把结果放到常量池的静态字段除外），以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包中的方法对类进行反射调用的时候，如果类没有进行初始化，则需初始化。</li>
<li>当初始化一个类的时候（注意是类，不是对象），如果发现父类没有被初始化，则先初始化其父类。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法），虚拟机会先初始化这个主类。</li>
<li>当使用jdk1.7的动态语言支持时，如果一个方法解析后句柄对应的类没有初始化，则先初始化。</li>
</ol>


<p>//当调用类中普通的静态变量时（没有被final修饰的），会对类进行初始化</p>

<pre><code>public class InvokeStatic {
public static int a=1;
static{
     System.out.println("the class has been init !");
}
public static void main(String[] args) {
     // TODO Auto-generated method stub
     int i=InvokeStatic.a;
}
}

输出结果为：
the class has been init !
</code></pre>

<p>//当初始化一个类的时候，如果发现父类还没有初始化，便先将其父类进行初始化</p>

<pre><code>class Super{
static{
     System.out.println("The super has been init !");
}
}
public class InvokeChildStatic extends Super {
static int a=10;
static{
     System.out.println("The child has been init !");
}
public static void main(String[] args) {
     // TODO Auto-generated method stub
     System.out.println(InvokeChildStatic.a);
}
}
输出结果为：
The super has been init !
The child has been init !
10
</code></pre>

<h2>上面介绍的是对类进行加载及初始化，下面要介绍的是对象的创建：</h2>

<ul>
<li>当虚拟机遇到一个new指令时，首先检查这个指令的参数能否在常量池中定位一个符号引用，并且检查这个符号引用代表的类是否被加载，如果没有，便先加载这个类。</li>
<li>类加载完成之后，虚拟机为新生对象在Java堆中分配内存（对象所需的内存大小在类加载完成后便确定）。</li>
<li>接下来，虚拟机将分配的内存空间都初始化为零值（保证了实例字段在Java代码中可以不赋初值就能使用）。</li>
<li>执行实例构造器<init>()方法，把对象按照程序员的意愿初始化。这样一个对象便创建完成。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[虚拟机内存分配]]></title>
    <link href="http://ttazk.github.io/blog/2017/02/08/jvm1/"/>
    <updated>2017-02-08T15:51:45+08:00</updated>
    <id>http://ttazk.github.io/blog/2017/02/08/jvm1</id>
    <content type="html"><![CDATA[<p>Java运行时数据区分为：方法区，堆，虚拟机栈，本地方法栈，程序计数器。其中，方法区与堆为所有线程共享；虚拟机栈，本地方法栈与程序计数器为线程私有。</p>

<h2>程序计数器：</h2>

<ol>
<li>所占内存空间比较小，可以看做当前线程所执行字节码的行号指数器。字节码解释器在工作时就是通过这个计数器的值来选取下一条需要执行的字节码指令。</li>
<li>每个线程都有一个独立的程序计数器，各个线程的程序计数器互不影响，独立存储，为“线程私有”。</li>
<li>如果线程正在执行的是Java方法，那么程序计数器的值就是虚拟机字节码指令的地址；如果执行的是Native方法，那么程序计数器的值为空。</li>
<li>此内存区域是Java虚拟机运行规范中没有规定任何OutOfMemoryError情况的区域。</li>
</ol>


<!--more-->


<h2>Java虚拟机栈：</h2>

<ol>
<li>与程序计数器一样，也是线程私有，它的生命周期与线程一样。</li>
<li>Java虚拟机栈描述的是Java方法执行时的内存模型：每一个方法在执行时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</li>
<li>局部变量表存放了在编译期可知的各种基本数据类型（int,short,long,double,float,boolean），对象引用类型（reference类型，可能指向对象起始地址的指针）和returnAddress类型（指向一条字节码指令的地址）。</li>
<li>局部变量表的内存大小在编译期确定并完成分配，当进入一个方法时，这个方法需要在帧中分配的局部变量表的大小确定，并且在运行期不改变。</li>
<li>Java虚拟机栈的内存大小是可以动态扩展的，在这个区域可能会发生两种异常：OutOfMemoryError与StackOverflowError。</li>
</ol>


<h2>本地方法栈：</h2>

<ol>
<li>与虚拟机栈的作用类似，只不过虚拟机栈是为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈是为虚拟机使用到的Native方法服务。有的虚拟机（如HotSpot）直接把这两个合二为一。</li>
<li>在这个区域可能会发生两种异常：OutOfMemoryError与StackOverflowError，与虚拟机栈相同。</li>
</ol>


<h2>Java堆：</h2>

<ol>
<li>Java堆是Java虚拟机所管理的内存最大的一块区域。</li>
<li>Java堆是所有线程共享的一块区域，随着虚拟机的启动而创建。此区域的唯一目的就是存放对象的实例，几乎所有的对象实例都在这里分配内存。Java虚拟机规范描述的是：所有的对象实例及数组都在堆上分配。</li>
<li>Java堆是垃圾收集器管理的主要区域。</li>
<li>Java堆可以处在物理上连续的内存空间中，也可以处于不连续的内存空间中（只要是逻辑上连续即可）。在实现时，可以是固定大小的，也可以是可扩展的。</li>
<li>当堆中没有内存完成实例分配时，且堆也无法扩展时，可能会发生的异常为：OutOfMemoryError。</li>
</ol>


<h2>方法区：</h2>

<ol>
<li>方法区与Java堆一样也是线程共享的，它用于存储已被虚拟机加载的类信息，常量，静态变量，即编译器编译后的代码（如被final static修饰，会在编译结束后放在常量池中）等数据。</li>
<li>除了与Java堆一样可以不需要连续的内存，可以选择固定的大小或可扩展的外，还可以选择不实现垃圾收集。相对而言，垃圾收集在这里的行为很少（这一区域的回收主要是对常量池的回收和对类型的卸载）。</li>
<li>当内存无法满足要求时，会抛出：OutOfMemoryError。</li>
</ol>


<h2>运行时常量池：</h2>

<ol>
<li>运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还包括一项信息是常量池。</li>
<li>常量池用于存放编译期生成的各种字面量和符号引用。</li>
<li><p>字面量和符号引用量：字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p>

<pre><code>    * 类和接口的全限定名
    * 字段名称和描述符
    * 方法名称和描述符
</code></pre></li>
<li><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p></li>
<li>java中基本类型的包装类的大部分都实现了常量池技术，即（Byte,Short,Integer,Long,Character,Boolean）。类比于Integer类型在自动装箱时，如果值[-128,127]之间，那么就存储在常量池中。两种浮点数类型的包装类Float,Double并没有实现常量池技术。</li>
<li>只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。</li>
<li>对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</li>
</ol>


<p>*</p>

<pre><code>     String string1="te";
     String string2="st";
     String string3="test";
     String string4=string1+string2;
     String string5="te"+"st";
     String string6=new StringBuilder("test").toString();
 　　String string7=new String("test").intern();


    System.out.println(string3==string4);//false
    System.out.println(string3==string5);//true
    System.out.println(string4==string5);//false
    System.out.println(string3==string6);//false
    System.out.println(string3==string7);//true
</code></pre>

<p>　　 <br/>
*</p>
]]></content>
  </entry>
  
</feed>
