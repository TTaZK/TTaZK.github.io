
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>ZK</title>
	<meta name="author" content="Z K">

	
	<meta name="description" content="Object类是所有类的父类，每个类都是由Object类扩展而来。如果没有明确指出父类，则默认为Object类为该类的父类。
可以使用Object类型的变量引用任何类型的对象。
在Java中，只有基本数据类型（数字，字符，布尔）不是对象。所有的数组类型， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="" rel="alternate" title="ZK" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">ZK</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.baidu.com/" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:ttazk.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
    
	</div>
	<form class="search" action="https://www.baidu.com/" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:ttazk.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/04/19/object/">
		
			Object详解</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>Object类是所有类的父类，每个类都是由Object类扩展而来。如果没有明确指出父类，则默认为Object类为该类的父类。</li>
<li>可以使用Object类型的变量引用任何类型的对象。</li>
<li><p>在Java中，只有基本数据类型（数字，字符，布尔）不是对象。所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。</p>

<pre><code>  int[] i=new int[5];
  Object obj=i;
</code></pre>

<h3>equals()方法</h3></li>
<li>在Object类中，该方法用于判断两个对象是否具有相同的引用。</li>
<li><p>然而，经常需要检测两个对象的状态的相等性，所以一般需要覆写equals()方法。</p>

<pre><code>  public class Test{
             public boolean equals(Object otherObject){
                  }
         }
</code></pre></li>
<li>在子类中定义equals方法时，首先调用父类的equals方法。如果检测失败，则对象不可能相等。如果父类中的域都相等，就需要比较子类中的实例域。</li>
</ul>



		
		<a href="/blog/2017/04/19/object/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Apr 19th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/04/19/object/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/04/12/jmm/">
		
			Java内存模型</a>
	</h2>
	<div class="entry-content">
		<ul>
<li><p><strong>Java 内存模型中的可见性、原子性和有序性。</strong></p></li>
<li><p><strong>可见性：</strong></p>

<ul>
<li>可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</li>
<li>可见性，是<strong>指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到</strong>。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</li>
<li><strong>在 Java 中 volatile、synchronized 和 final 实现可见性。</strong><br/><br/></li>
</ul>
</li>
</ul>



		
		<a href="/blog/2017/04/12/jmm/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Apr 12th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/jvm/'>jvm</a>


</div>
	
	<div class="comments"><a href="/blog/2017/04/12/jmm/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/04/11/threadpool/">
		
			线程池详解</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>线程池是管理一组同构线程的资源池。线程池与工作队列密切相关，其中在工作队列中保存了所有等待执行的任务。<strong>工作者线程的任务是：从工作队列中取出一个任务，执行任务，然后返回线程等待下一个任务。线程池通过重用线程，而不是新建线程，减小线程创建与销毁的开销</strong>。</li>
<li>Excutor是顶级线程池接口</li>
<li>ExecutorService是真正的线程池接口。</li>
<li>Executors类提供了一些静态工厂用于生成一些常用的线程池，当将一个任务添加到线程池时，线程池会为每个任务创建一个线程，该线程会在某个时刻执行。</li>
</ul>



		
		<a href="/blog/2017/04/11/threadpool/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Apr 11th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/04/11/threadpool/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/03/22/generic/">
		
			泛型程序设计</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。</li>
<li><p>在增加泛型之前，泛型程序是利用继承实现的。</p>

<pre><code>  public class ArrayList{
  private Object[] data;
   ...
  public Object get(int i){}
  public void add(Object o){}
  }
</code></pre></li>
<li>这种方法有两个问题：</li>
<li>1.当获取一个值时必须进行强制类型转换。</li>
<li><p>2.没有错误检查，可以向数组列表中添加任何类的对象。</br></br></p></li>
<li><p>泛型提供了一个更好的解决方法：类型参数，用来指示存储元素的类型。如：ArrayList<String> arl=new ArrayList&lt;>();   (jdk1.7之后，构造函数中可以省略泛型类型)。</p>

<ul>
<li>对此编译器可以进行检查，避免插入错误的类型，同时在获取对象时不需要进行强制类型转换。</li>
<li><p>一个泛型类(generic class)就是具有一个或多个类型变量的类。
      public class Pair<T> {
      private T first;
      private T second;</p>

<pre><code>  public Pair(){
       this.first=null;
       this.second=null;
  }
  public Pair(T first,T second){
       this.first=first;
       this.second=second;
  }

  public T getFirst(){
       return first;
  }
  public T getSecond(){
       return second;
  }
  public void setFirst(T first){
       this.first=first;
  }
  public void setSecond(T second){
       this.second=second;
      }
  }
</code></pre></li>
<li>如上所示，Pair类引入了一个类型变量T,用&lt;>括起来，并放在类名之后。泛型类可以有多个类型变量。例如可以定义Pair类，两个域分别使用不同的类型变量：public class Pair&lt;T,V>{&hellip;}.</li>
<li>类中定义的泛型变量指定方法的返回类型，以及域和局部变量的类型。（一般来说，K,V分别表示关键字与值的类型，T表示任意类型）。</li>
<li>用具体的类型替换类型变量就可以实例化泛型类型，如Pair<String>。换句话来说，泛型类可以看做普通类的工厂。
</br></br></li>
</ul>
</li>
</ul>



		
		<a href="/blog/2017/03/22/generic/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Mar 22nd, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/03/22/generic/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/03/22/thread/">
		
			线程与并发</a>
	</h2>
	<div class="entry-content">
		<pre><code>public class Thread  extends Object  implements Runnable

线程 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。

每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。每个线程都可以或不可以标记为一个守护程序。当某个线程中运行的代码创建一个新 Thread 对象时，该新线程的初始优先级被设定为创建线程的优先级，并且当且仅当创建线程是守护线程时，新线程才是守护程序。

当 Java 虚拟机启动时，通常都会有单个非守护线程（它通常会调用某个指定类的 main 方法）。Java 虚拟机会继续执行线程，直到下列任一情况出现时为止：
    - 调用了 Runtime 类的 exit 方法，并且安全管理器允许退出操作发生。
    - 非守护线程的所有线程都已停止运行，无论是通过从对 run 方法的调用中返回，还是通过抛出一个传播到 run 方法之外的异常。

创建新执行线程有两种方法。一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。这种方法不再推荐。
创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动
</code></pre>

<ul>
<li>在一个单独线程中执行一个任务的步骤如下：

<ul>
<li>将任务代码移到实现了Runnable接口类的run()方法中。</li>
<li>由Runnable对象创建一个Thread对象。Thread thread=new Thread(new Runnable());</li>
<li>启动线程。thread.start().<br/><br/></li>
</ul>
</li>
</ul>



		
		<a href="/blog/2017/03/22/thread/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Mar 22nd, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/javase/'>javase</a>


</div>
	
	<div class="comments"><a href="/blog/2017/03/22/thread/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/03/21/spring_mybatis/">
		
			Spring整合MyBatis框架</a>
	</h2>
	<div class="entry-content">
		<ul>
<li><p>使用MyBatis，面对的是纯粹的Java对象，类似于Hbernate。但是对于具体的数据库操作，Hibernate会自动生成SQL语句，MyBatis 则要求自己自己编写SQL语句。</p></li>
<li><p>每一个MyBatis应用都是以一个SQLSessionFactory对象的实例为核心MyBatis可以拥有多个SQL映射文件，并通过一个配置文件对这些SQL映射文件进行装配，同时在该文件中定义一些控制属性信息。
如下：</p></li>
</ul>



		
		<a href="/blog/2017/03/21/spring_mybatis/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Mar 21st, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/spring/'>spring</a>


</div>
	
	<div class="comments"><a href="/blog/2017/03/21/spring_mybatis/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/03/19/generic/">
		
			泛型程序设计</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。</li>
<li><p>在增加泛型之前，泛型程序是利用继承实现的。</p>

<pre><code>  public class ArrayList{
  private Object[] data;
   ...
  public Object get(int i){}
  public void add(Object o){}
  }
</code></pre></li>
<li>这种方法有两个问题：</li>
<li>1.当获取一个值时必须进行强制类型转换。</li>
<li><p>2.没有错误检查，可以向数组列表中添加任何类的对象。</br></br></p></li>
<li><p>泛型提供了一个更好的解决方法：类型参数，用来指示存储元素的类型。如：ArrayList<String> arl=new ArrayList&lt;>();   (jdk1.7之后，构造函数中可以省略泛型类型)。</p>

<ul>
<li>对此编译器可以进行检查，避免插入错误的类型，同时在获取对象时不需要进行强制类型转换。</li>
<li><p>一个泛型类(generic class)就是具有一个或多个类型变量的类。
      public class Pair<T> {
      private T first;
      private T second;</p>

<pre><code>  public Pair(){
       this.first=null;
       this.second=null;
  }
  public Pair(T first,T second){
       this.first=first;
       this.second=second;
  }

  public T getFirst(){
       return first;
  }
  public T getSecond(){
       return second;
  }
  public void setFirst(T first){
       this.first=first;
  }
  public void setSecond(T second){
       this.second=second;
      }
  }
</code></pre></li>
<li>如上所示，Pair类引入了一个类型变量T,用&lt;>括起来，并放在类名之后。泛型类可以有多个类型变量。例如可以定义Pair类，两个域分别使用不同的类型变量：public class Pair&lt;T,V>{&hellip;}.</li>
<li>类中定义的泛型变量指定方法的返回类型，以及域和局部变量的类型。（一般来说，K,V分别表示关键字与值的类型，T表示任意类型）。</li>
<li>用具体的类型替换类型变量就可以实例化泛型类型，如Pair<String>。换句话来说，泛型类可以看做普通类的工厂。
</br></br></li>
</ul>
</li>
</ul>



		
		<a href="/blog/2017/03/19/generic/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Mar 19th, 2017</div>
	<div class="tags">

</div>
	
	<div class="comments"><a href="/blog/2017/03/19/generic/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/02/21/bean_config/">
		
			Bean的配置及注入</a>
	</h2>
	<div class="entry-content">
		<h4>Bean的配置方式有三种：xml配置，基于注解配置，基于java类配置</h4>

<ul>
<li>Bean的配置信息包含了bean的实现及各个bean之间的依赖关系，Spring容器将各种形式的Bean的配置信息进行读取，并在Spring容器内部建立Bean定义注册表，然后根据注册表对Bean进行加载，实例化，并建立Bean之间的依赖关系，最后将准备就绪的Bean放入Bean缓冲池中，等待外部程序调用。</li>
</ul>


<h3>Bean配置方式详解：</h3>


		
		<a href="/blog/2017/02/21/bean_config/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Feb 21st, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/spring/'>spring</a>


</div>
	
	<div class="comments"><a href="/blog/2017/02/21/bean_config/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/02/14/transmission/">
		
			运输层</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>运输层用于向它上面的应用层提供服务，它属于面向通信的最高层，同时也是用户功能的最低层。当网络的边缘部分的两个主机进行通信时，只有主机的协议栈中才有运输层，而网络核心部分在转发分组时都只用到下三层的功能。</li>
<li>两个主机进行通信，也就是两个主机中的应用进程进行通信，通信的真正端点是主机中的进程。</li>
<li>运输层能够“复用”与“分用”：复用是指发送方不同的应用进程都可以使用同一个运输层协议传输数据，分用是指接收方的运输层能够把接收的数据正确地交付到目的应用进程中。</li>
<li>网络层为主机之间提供逻辑通信，运输层为应用进程间提供逻辑通信。运输层向高层用户屏蔽了下面网络的核心细节。</li>
<li><p>运输层包括两个主要的协议：TCP（传输控制协议），UDP（用户数据报协议）。传输的数据单元分别为：TCP报文段与UDP用户数据报。</p></li>
<li><p>UDP在传输数据之前不需要建立连接。接收方在收到报文后也不需要给出任何确认。</p></li>
<li>TCP采用面向连接的服务，在传输数据之前先建立连接，且TCP不支持广播或者多播服务。</li>
</ul>



		
		<a href="/blog/2017/02/14/transmission/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Feb 14th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/ji-suan-ji-wang-luo/'>计算机网络</a>


</div>
	
	<div class="comments"><a href="/blog/2017/02/14/transmission/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2017/02/09/jvm2/">
		
			虚拟机类加载机制</a>
	</h2>
	<div class="entry-content">
		<ul>
<li>类的生命周期包括：加载&ndash;>连接&ndash;>初始化&ndash;>使用&ndash;>卸载，其中连接包括，验证&ndash;>准备&ndash;>解析。</li>
<li>虚拟机把描述类的数据从Class文件中加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可被虚拟机直接使用的Java类型。</li>
<li>在Java中，类的加载，连接，初始化都是在运行期间完成的，这种策略与C++等不同，但是这也实现了Java语言的运行期动态加载与动态连接的特点。</li>
</ul>



		
		<a href="/blog/2017/02/09/jvm2/" class="more-link">Read on &rarr;</a>
	</div>


<div class="meta">
	<div class="date">




Feb 9th, 2017</div>
	<div class="tags">


	<a class='category' href='/blog/categories/jvm/'>jvm</a>


</div>
	
	<div class="comments"><a href="/blog/2017/02/09/jvm2/#disqus_thread">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
        
            <a href="/" class="prev">Prev</a>
        
    
    
        <a href="/posts/3" class="next">Next</a>
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2017

    Z K

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'zkatt';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>